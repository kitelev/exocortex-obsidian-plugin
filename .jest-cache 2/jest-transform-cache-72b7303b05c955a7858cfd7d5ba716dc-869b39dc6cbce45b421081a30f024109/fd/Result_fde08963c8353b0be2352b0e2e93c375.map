{"file":"/Users/kitelev/Documents/exocortex-obsidian-plugin/src/domain/core/Result.ts","mappings":";;;AAAA;;;GAGG;AACH,MAAa,MAAM;IAMf,YAAoB,SAAkB,EAAE,KAAc,EAAE,KAAS;QAC7D,IAAI,SAAS,IAAI,KAAK,EAAE;YACpB,MAAM,IAAI,KAAK,CAAC,sEAAsE,CAAC,CAAC;SAC3F;QACD,IAAI,CAAC,SAAS,IAAI,CAAC,KAAK,EAAE;YACtB,MAAM,IAAI,KAAK,CAAC,sEAAsE,CAAC,CAAC;SAC3F;QAED,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,SAAS,GAAG,CAAC,SAAS,CAAC;QAC5B,IAAI,CAAC,KAAK,GAAG,KAAe,CAAC;QAC7B,IAAI,CAAC,MAAM,GAAG,KAAU,CAAC;QAEzB,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IACxB,CAAC;IAEM,QAAQ;QACX,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;YACjB,MAAM,IAAI,KAAK,CAAC,mEAAmE,CAAC,CAAC;SACxF;QAED,OAAO,IAAI,CAAC,MAAM,CAAC;IACvB,CAAC;IAEM,UAAU;QACb,OAAO,IAAI,CAAC,KAAK,CAAC;IACtB,CAAC;IAEM,eAAe;QAClB,OAAO,IAAI,CAAC,KAAK,CAAC;IACtB,CAAC;IAEM,QAAQ;QACX,OAAO,IAAI,CAAC,KAAK,CAAC;IACtB,CAAC;IAEM,MAAM,CAAC,EAAE,CAAI,KAAS;QACzB,OAAO,IAAI,MAAM,CAAI,IAAI,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;IACjD,CAAC;IAEM,MAAM,CAAC,IAAI,CAAI,KAAa;QAC/B,OAAO,IAAI,MAAM,CAAI,KAAK,EAAE,KAAK,CAAC,CAAC;IACvC,CAAC;IAEM,MAAM,CAAC,OAAO,CAAC,OAAsB;QACxC,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;YAC1B,IAAI,MAAM,CAAC,SAAS;gBAAE,OAAO,MAAM,CAAC;SACvC;QACD,OAAO,MAAM,CAAC,EAAE,EAAE,CAAC;IACvB,CAAC;CACJ;AAxDD,wBAwDC","names":[],"sources":["/Users/kitelev/Documents/exocortex-obsidian-plugin/src/domain/core/Result.ts"],"sourcesContent":["/**\n * Result class for handling success and failure states\n * Following functional programming patterns for error handling\n */\nexport class Result<T> {\n    public isSuccess: boolean;\n    public isFailure: boolean;\n    public error: string;\n    private _value: T;\n\n    private constructor(isSuccess: boolean, error?: string, value?: T) {\n        if (isSuccess && error) {\n            throw new Error('InvalidOperation: A result cannot be successful and contain an error');\n        }\n        if (!isSuccess && !error) {\n            throw new Error('InvalidOperation: A failing result needs to contain an error message');\n        }\n\n        this.isSuccess = isSuccess;\n        this.isFailure = !isSuccess;\n        this.error = error as string;\n        this._value = value as T;\n\n        Object.freeze(this);\n    }\n\n    public getValue(): T {\n        if (!this.isSuccess) {\n            throw new Error(`Can't get the value of an error result. Use 'errorValue' instead.`);\n        }\n\n        return this._value;\n    }\n\n    public errorValue(): string {\n        return this.error;\n    }\n\n    public getErrorMessage(): string {\n        return this.error;\n    }\n\n    public getError(): string {\n        return this.error;\n    }\n\n    public static ok<U>(value?: U): Result<U> {\n        return new Result<U>(true, undefined, value);\n    }\n\n    public static fail<U>(error: string): Result<U> {\n        return new Result<U>(false, error);\n    }\n\n    public static combine(results: Result<any>[]): Result<any> {\n        for (const result of results) {\n            if (result.isFailure) return result;\n        }\n        return Result.ok();\n    }\n}"],"version":3}