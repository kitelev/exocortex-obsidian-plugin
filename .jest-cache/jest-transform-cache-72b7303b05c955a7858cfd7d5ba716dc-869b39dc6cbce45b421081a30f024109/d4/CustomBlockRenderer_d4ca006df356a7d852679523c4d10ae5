5f2d216d151d9dab7b84fe121a217862
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomBlockRenderer = void 0;
const tslib_1 = require("tslib");
const obsidian_1 = require("obsidian");
class CustomBlockRenderer {
    constructor(app) {
        this.app = app;
    }
    render(container, config, file, frontmatter, dv) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const customConfig = config;
            try {
                // Option 1: Render from template file
                if (customConfig.templatePath) {
                    yield this.renderTemplate(container, customConfig.templatePath, file, frontmatter, dv);
                    return;
                }
                // Option 2: Execute Dataview query
                if (customConfig.dataviewQuery) {
                    yield this.renderDataviewQuery(container, customConfig.dataviewQuery, dv);
                    return;
                }
                // Option 3: Execute custom script
                if (customConfig.customScript) {
                    yield this.renderCustomScript(container, customConfig.customScript, file, frontmatter, dv);
                    return;
                }
                container.createEl('p', {
                    text: 'Custom block has no content configured',
                    cls: 'exocortex-empty'
                });
            }
            catch (error) {
                container.createEl('p', {
                    text: `Error rendering custom block: ${error}`,
                    cls: 'exocortex-error'
                });
                console.error('Custom block error:', error);
            }
        });
    }
    renderTemplate(container, templatePath, file, frontmatter, dv) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Find template file
            const templateFile = this.app.vault.getAbstractFileByPath(templatePath);
            if (!(templateFile instanceof obsidian_1.TFile)) {
                container.createEl('p', {
                    text: `Template not found: ${templatePath}`,
                    cls: 'exocortex-error'
                });
                return;
            }
            // Read template content
            const templateContent = yield this.app.vault.read(templateFile);
            // Process template variables
            const processedContent = this.processTemplateVariables(templateContent, file, frontmatter);
            // Render as markdown
            const tempContainer = container.createDiv();
            yield this.app.markdown.renderMarkdown(processedContent, tempContainer, file.path, null);
        });
    }
    renderDataviewQuery(container, query, dv) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!dv) {
                container.createEl('p', {
                    text: 'Dataview is not available',
                    cls: 'exocortex-error'
                });
                return;
            }
            try {
                // Create a wrapper for Dataview output
                const dvContainer = container.createDiv({ cls: 'exocortex-dataview-container' });
                // Execute the query
                // Note: This is a simplified version. Real implementation would need
                // to properly integrate with Dataview API
                const queryLines = query.trim().split('\n');
                if (queryLines[0].startsWith('table')) {
                    // Parse table query
                    const tableMatch = query.match(/table\s+(.+?)\s+from/s);
                    const fromMatch = query.match(/from\s+(.+?)(?:\s+where|$)/s);
                    const whereMatch = query.match(/where\s+(.+?)$/s);
                    if (fromMatch) {
                        const source = fromMatch[1].trim();
                        const fields = tableMatch ? tableMatch[1].split(',').map(f => f.trim()) : [];
                        // Use Dataview API to execute query
                        const pages = dv.pages(source);
                        if (whereMatch) {
                            // Apply where clause (simplified)
                            // In real implementation, would need proper expression evaluation
                        }
                        // Render table
                        dv.table(['File', ...fields], pages.map((p) => [
                            p.file.link,
                            ...fields.map(f => p[f] || '')
                        ]));
                    }
                }
                else if (queryLines[0].startsWith('list')) {
                    // Parse list query
                    const fromMatch = query.match(/from\s+(.+?)(?:\s+where|$)/s);
                    if (fromMatch) {
                        const source = fromMatch[1].trim();
                        const pages = dv.pages(source);
                        dv.list(pages.file.link);
                    }
                }
                else {
                    // Try to execute as raw JavaScript
                    const AsyncFunction = Object.getPrototypeOf(function () {
                        return tslib_1.__awaiter(this, void 0, void 0, function* () { });
                    }).constructor;
                    const fn = new AsyncFunction('dv', 'container', query);
                    yield fn(dv, dvContainer);
                }
            }
            catch (error) {
                container.createEl('p', {
                    text: `Dataview query error: ${error}`,
                    cls: 'exocortex-error'
                });
            }
        });
    }
    renderCustomScript(container, script, file, frontmatter, dv) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                // Create a sandboxed context for the script
                const context = {
                    app: this.app,
                    file,
                    frontmatter,
                    dv,
                    container,
                    console: {
                        log: (...args) => console.log('[Custom Block]', ...args),
                        error: (...args) => console.error('[Custom Block]', ...args)
                    }
                };
                // Execute the script in a controlled way
                const AsyncFunction = Object.getPrototypeOf(function () {
                    return tslib_1.__awaiter(this, void 0, void 0, function* () { });
                }).constructor;
                const fn = new AsyncFunction(...Object.keys(context), script);
                yield fn(...Object.values(context));
            }
            catch (error) {
                container.createEl('p', {
                    text: `Script execution error: ${error}`,
                    cls: 'exocortex-error'
                });
                console.error('Custom script error:', error);
            }
        });
    }
    processTemplateVariables(template, file, frontmatter) {
        let processed = template;
        // Replace file variables
        processed = processed.replace(/\{\{file\.name\}\}/g, file.basename);
        processed = processed.replace(/\{\{file\.path\}\}/g, file.path);
        // Replace frontmatter variables
        Object.keys(frontmatter).forEach(key => {
            const value = frontmatter[key];
            const regex = new RegExp(`\\{\\{fm\\.${key}\\}\\}`, 'g');
            processed = processed.replace(regex, this.formatValue(value));
        });
        // Replace date variables
        const now = new Date();
        processed = processed.replace(/\{\{date\}\}/g, now.toLocaleDateString());
        processed = processed.replace(/\{\{time\}\}/g, now.toLocaleTimeString());
        processed = processed.replace(/\{\{datetime\}\}/g, now.toLocaleString());
        return processed;
    }
    formatValue(value) {
        if (value === null || value === undefined)
            return '';
        if (Array.isArray(value)) {
            return value.map(v => this.cleanValue(v)).join(', ');
        }
        return this.cleanValue(value);
    }
    cleanValue(value) {
        if (!value)
            return '';
        const str = value.toString();
        return str.replace(/\[\[|\]\]/g, '');
    }
}
exports.CustomBlockRenderer = CustomBlockRenderer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2tpdGVsZXYvRG9jdW1lbnRzL2V4b2NvcnRleC1vYnNpZGlhbi1wbHVnaW4vc3JjL3ByZXNlbnRhdGlvbi9yZW5kZXJlcnMvQ3VzdG9tQmxvY2tSZW5kZXJlci50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsdUNBQXNDO0FBR3RDLE1BQWEsbUJBQW1CO0lBQzVCLFlBQW9CLEdBQVE7UUFBUixRQUFHLEdBQUgsR0FBRyxDQUFLO0lBQUcsQ0FBQztJQUUxQixNQUFNLENBQ1IsU0FBc0IsRUFDdEIsTUFBVyxFQUNYLElBQVcsRUFDWCxXQUFnQixFQUNoQixFQUFPOztZQUVQLE1BQU0sWUFBWSxHQUFHLE1BQTJCLENBQUM7WUFFakQsSUFBSTtnQkFDQSxzQ0FBc0M7Z0JBQ3RDLElBQUksWUFBWSxDQUFDLFlBQVksRUFBRTtvQkFDM0IsTUFBTSxJQUFJLENBQUMsY0FBYyxDQUFDLFNBQVMsRUFBRSxZQUFZLENBQUMsWUFBWSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsRUFBRSxDQUFDLENBQUM7b0JBQ3ZGLE9BQU87aUJBQ1Y7Z0JBRUQsbUNBQW1DO2dCQUNuQyxJQUFJLFlBQVksQ0FBQyxhQUFhLEVBQUU7b0JBQzVCLE1BQU0sSUFBSSxDQUFDLG1CQUFtQixDQUFDLFNBQVMsRUFBRSxZQUFZLENBQUMsYUFBYSxFQUFFLEVBQUUsQ0FBQyxDQUFDO29CQUMxRSxPQUFPO2lCQUNWO2dCQUVELGtDQUFrQztnQkFDbEMsSUFBSSxZQUFZLENBQUMsWUFBWSxFQUFFO29CQUMzQixNQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxTQUFTLEVBQUUsWUFBWSxDQUFDLFlBQVksRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLEVBQUUsQ0FBQyxDQUFDO29CQUMzRixPQUFPO2lCQUNWO2dCQUVELFNBQVMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFO29CQUNwQixJQUFJLEVBQUUsd0NBQXdDO29CQUM5QyxHQUFHLEVBQUUsaUJBQWlCO2lCQUN6QixDQUFDLENBQUM7YUFFTjtZQUFDLE9BQU8sS0FB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QUMsT0FBTyxDQUFDLGVBQWUsRUFBRSxHQUFHLENBQUMsa0JBQWtCLEVBQUUsQ0FBQyxDQUFDO1FBQ3pFLFNBQVMsR0FBRyxTQUFTLENBQUMsT0FBTyxDQUFDLG1CQUFtQixFQUFFLEdBQUcsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxDQUFDO1FBRXpFLE9BQU8sU0FBUyxDQUFDO0lBQ3JCLENBQUM7SUFFTyxXQUFXLENBQUMsS0FBVTtRQUMxQixJQUFJLEtBQUssS0FBSyxJQUFJLElBQUksS0FBSyxLQUFLLFNBQVM7WUFBRSxPQUFPLEVBQUUsQ0FBQztRQUVyRCxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDdEIsT0FBTyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUN4RDtRQUVELE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNsQyxDQUFDO0lBRU8sVUFBVSxDQUFDLEtBQVU7UUFDekIsSUFBSSxDQUFDLEtBQUs7WUFBRSxPQUFPLEVBQUUsQ0FBQztRQUN0QixNQUFNLEdBQUcsR0FBRyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDN0IsT0FBTyxHQUFHLENBQUMsT0FBTyxDQUFDLFlBQVksRUFBRSxFQUFFLENBQUMsQ0FBQztJQUN6QyxDQUFDO0NBQ0o7QUEzT0Qsa0RBMk9DIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9raXRlbGV2L0RvY3VtZW50cy9leG9jb3J0ZXgtb2JzaWRpYW4tcGx1Z2luL3NyYy9wcmVzZW50YXRpb24vcmVuZGVyZXJzL0N1c3RvbUJsb2NrUmVuZGVyZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBwLCBURmlsZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IEN1c3RvbUJsb2NrQ29uZmlnIH0gZnJvbSAnLi4vLi4vZG9tYWluL2VudGl0aWVzL0xheW91dEJsb2NrJztcblxuZXhwb3J0IGNsYXNzIEN1c3RvbUJsb2NrUmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgYXBwOiBBcHApIHt9XG5cbiAgICBhc3luYyByZW5kZXIoXG4gICAgICAgIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsXG4gICAgICAgIGNvbmZpZzogYW55LFxuICAgICAgICBmaWxlOiBURmlsZSxcbiAgICAgICAgZnJvbnRtYXR0ZXI6IGFueSxcbiAgICAgICAgZHY6IGFueVxuICAgICk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBjdXN0b21Db25maWcgPSBjb25maWcgYXMgQ3VzdG9tQmxvY2tDb25maWc7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gT3B0aW9uIDE6IFJlbmRlciBmcm9tIHRlbXBsYXRlIGZpbGVcbiAgICAgICAgICAgIGlmIChjdXN0b21Db25maWcudGVtcGxhdGVQYXRoKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZW5kZXJUZW1wbGF0ZShjb250YWluZXIsIGN1c3RvbUNvbmZpZy50ZW1wbGF0ZVBhdGgsIGZpbGUsIGZyb250bWF0dGVyLCBkdik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBPcHRpb24gMjogRXhlY3V0ZSBEYXRhdmlldyBxdWVyeVxuICAgICAgICAgICAgaWYgKGN1c3RvbUNvbmZpZy5kYXRhdmlld1F1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZW5kZXJEYXRhdmlld1F1ZXJ5KGNvbnRhaW5lciwgY3VzdG9tQ29uZmlnLmRhdGF2aWV3UXVlcnksIGR2KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE9wdGlvbiAzOiBFeGVjdXRlIGN1c3RvbSBzY3JpcHRcbiAgICAgICAgICAgIGlmIChjdXN0b21Db25maWcuY3VzdG9tU2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZW5kZXJDdXN0b21TY3JpcHQoY29udGFpbmVyLCBjdXN0b21Db25maWcuY3VzdG9tU2NyaXB0LCBmaWxlLCBmcm9udG1hdHRlciwgZHYpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29udGFpbmVyLmNyZWF0ZUVsKCdwJywge1xuICAgICAgICAgICAgICAgIHRleHQ6ICdDdXN0b20gYmxvY2sgaGFzIG5vIGNvbnRlbnQgY29uZmlndXJlZCcsXG4gICAgICAgICAgICAgICAgY2xzOiAnZXhvY29ydGV4LWVtcHR5J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5jcmVhdGVFbCgncCcsIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBgRXJyb3IgcmVuZGVyaW5nIGN1c3RvbSBibG9jazogJHtlcnJvcn1gLFxuICAgICAgICAgICAgICAgIGNsczogJ2V4b2NvcnRleC1lcnJvcidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ3VzdG9tIGJsb2NrIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgcmVuZGVyVGVtcGxhdGUoXG4gICAgICAgIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsXG4gICAgICAgIHRlbXBsYXRlUGF0aDogc3RyaW5nLFxuICAgICAgICBmaWxlOiBURmlsZSxcbiAgICAgICAgZnJvbnRtYXR0ZXI6IGFueSxcbiAgICAgICAgZHY6IGFueVxuICAgICk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICAvLyBGaW5kIHRlbXBsYXRlIGZpbGVcbiAgICAgICAgY29uc3QgdGVtcGxhdGVGaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHRlbXBsYXRlUGF0aCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoISh0ZW1wbGF0ZUZpbGUgaW5zdGFuY2VvZiBURmlsZSkpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5jcmVhdGVFbCgncCcsIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBgVGVtcGxhdGUgbm90IGZvdW5kOiAke3RlbXBsYXRlUGF0aH1gLFxuICAgICAgICAgICAgICAgIGNsczogJ2V4b2NvcnRleC1lcnJvcidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBSZWFkIHRlbXBsYXRlIGNvbnRlbnRcbiAgICAgICAgY29uc3QgdGVtcGxhdGVDb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZCh0ZW1wbGF0ZUZpbGUpO1xuICAgICAgICBcbiAgICAgICAgLy8gUHJvY2VzcyB0ZW1wbGF0ZSB2YXJpYWJsZXNcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkQ29udGVudCA9IHRoaXMucHJvY2Vzc1RlbXBsYXRlVmFyaWFibGVzKFxuICAgICAgICAgICAgdGVtcGxhdGVDb250ZW50LFxuICAgICAgICAgICAgZmlsZSxcbiAgICAgICAgICAgIGZyb250bWF0dGVyXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZW5kZXIgYXMgbWFya2Rvd25cbiAgICAgICAgY29uc3QgdGVtcENvbnRhaW5lciA9IGNvbnRhaW5lci5jcmVhdGVEaXYoKTtcbiAgICAgICAgYXdhaXQgKHRoaXMuYXBwIGFzIGFueSkubWFya2Rvd24ucmVuZGVyTWFya2Rvd24oXG4gICAgICAgICAgICBwcm9jZXNzZWRDb250ZW50LFxuICAgICAgICAgICAgdGVtcENvbnRhaW5lcixcbiAgICAgICAgICAgIGZpbGUucGF0aCxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIHJlbmRlckRhdGF2aWV3UXVlcnkoXG4gICAgICAgIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsXG4gICAgICAgIHF1ZXJ5OiBzdHJpbmcsXG4gICAgICAgIGR2OiBhbnlcbiAgICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKCFkdikge1xuICAgICAgICAgICAgY29udGFpbmVyLmNyZWF0ZUVsKCdwJywge1xuICAgICAgICAgICAgICAgIHRleHQ6ICdEYXRhdmlldyBpcyBub3QgYXZhaWxhYmxlJyxcbiAgICAgICAgICAgICAgICBjbHM6ICdleG9jb3J0ZXgtZXJyb3InXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHdyYXBwZXIgZm9yIERhdGF2aWV3IG91dHB1dFxuICAgICAgICAgICAgY29uc3QgZHZDb250YWluZXIgPSBjb250YWluZXIuY3JlYXRlRGl2KHsgY2xzOiAnZXhvY29ydGV4LWRhdGF2aWV3LWNvbnRhaW5lcicgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEV4ZWN1dGUgdGhlIHF1ZXJ5XG4gICAgICAgICAgICAvLyBOb3RlOiBUaGlzIGlzIGEgc2ltcGxpZmllZCB2ZXJzaW9uLiBSZWFsIGltcGxlbWVudGF0aW9uIHdvdWxkIG5lZWRcbiAgICAgICAgICAgIC8vIHRvIHByb3Blcmx5IGludGVncmF0ZSB3aXRoIERhdGF2aWV3IEFQSVxuICAgICAgICAgICAgY29uc3QgcXVlcnlMaW5lcyA9IHF1ZXJ5LnRyaW0oKS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChxdWVyeUxpbmVzWzBdLnN0YXJ0c1dpdGgoJ3RhYmxlJykpIHtcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSB0YWJsZSBxdWVyeVxuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlTWF0Y2ggPSBxdWVyeS5tYXRjaCgvdGFibGVcXHMrKC4rPylcXHMrZnJvbS9zKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9tTWF0Y2ggPSBxdWVyeS5tYXRjaCgvZnJvbVxccysoLis/KSg/Olxccyt3aGVyZXwkKS9zKTtcbiAgICAgICAgICAgICAgICBjb25zdCB3aGVyZU1hdGNoID0gcXVlcnkubWF0Y2goL3doZXJlXFxzKyguKz8pJC9zKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoZnJvbU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGZyb21NYXRjaFsxXS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkcyA9IHRhYmxlTWF0Y2ggPyB0YWJsZU1hdGNoWzFdLnNwbGl0KCcsJykubWFwKGYgPT4gZi50cmltKCkpIDogW107XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgRGF0YXZpZXcgQVBJIHRvIGV4ZWN1dGUgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFnZXMgPSBkdi5wYWdlcyhzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdoZXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHdoZXJlIGNsYXVzZSAoc2ltcGxpZmllZClcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIHJlYWwgaW1wbGVtZW50YXRpb24sIHdvdWxkIG5lZWQgcHJvcGVyIGV4cHJlc3Npb24gZXZhbHVhdGlvblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBSZW5kZXIgdGFibGVcbiAgICAgICAgICAgICAgICAgICAgZHYudGFibGUoWydGaWxlJywgLi4uZmllbGRzXSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlcy5tYXAoKHA6IGFueSkgPT4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZmlsZS5saW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmZpZWxkcy5tYXAoZiA9PiBwW2ZdIHx8ICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHF1ZXJ5TGluZXNbMF0uc3RhcnRzV2l0aCgnbGlzdCcpKSB7XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgbGlzdCBxdWVyeVxuICAgICAgICAgICAgICAgIGNvbnN0IGZyb21NYXRjaCA9IHF1ZXJ5Lm1hdGNoKC9mcm9tXFxzKyguKz8pKD86XFxzK3doZXJlfCQpL3MpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChmcm9tTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc291cmNlID0gZnJvbU1hdGNoWzFdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFnZXMgPSBkdi5wYWdlcyhzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICBkdi5saXN0KHBhZ2VzLmZpbGUubGluayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZXhlY3V0ZSBhcyByYXcgSmF2YVNjcmlwdFxuICAgICAgICAgICAgICAgIGNvbnN0IEFzeW5jRnVuY3Rpb24gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYXN5bmMgZnVuY3Rpb24oKXt9KS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgICAgICBjb25zdCBmbiA9IG5ldyBBc3luY0Z1bmN0aW9uKCdkdicsICdjb250YWluZXInLCBxdWVyeSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgZm4oZHYsIGR2Q29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5jcmVhdGVFbCgncCcsIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBgRGF0YXZpZXcgcXVlcnkgZXJyb3I6ICR7ZXJyb3J9YCxcbiAgICAgICAgICAgICAgICBjbHM6ICdleG9jb3J0ZXgtZXJyb3InXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgcmVuZGVyQ3VzdG9tU2NyaXB0KFxuICAgICAgICBjb250YWluZXI6IEhUTUxFbGVtZW50LFxuICAgICAgICBzY3JpcHQ6IHN0cmluZyxcbiAgICAgICAgZmlsZTogVEZpbGUsXG4gICAgICAgIGZyb250bWF0dGVyOiBhbnksXG4gICAgICAgIGR2OiBhbnlcbiAgICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHNhbmRib3hlZCBjb250ZXh0IGZvciB0aGUgc2NyaXB0XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIGFwcDogdGhpcy5hcHAsXG4gICAgICAgICAgICAgICAgZmlsZSxcbiAgICAgICAgICAgICAgICBmcm9udG1hdHRlcixcbiAgICAgICAgICAgICAgICBkdixcbiAgICAgICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICAgICAgY29uc29sZToge1xuICAgICAgICAgICAgICAgICAgICBsb2c6ICguLi5hcmdzOiBhbnlbXSkgPT4gY29uc29sZS5sb2coJ1tDdXN0b20gQmxvY2tdJywgLi4uYXJncyksXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiAoLi4uYXJnczogYW55W10pID0+IGNvbnNvbGUuZXJyb3IoJ1tDdXN0b20gQmxvY2tdJywgLi4uYXJncylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBFeGVjdXRlIHRoZSBzY3JpcHQgaW4gYSBjb250cm9sbGVkIHdheVxuICAgICAgICAgICAgY29uc3QgQXN5bmNGdW5jdGlvbiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihhc3luYyBmdW5jdGlvbigpe30pLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgY29uc3QgZm4gPSBuZXcgQXN5bmNGdW5jdGlvbihcbiAgICAgICAgICAgICAgICAuLi5PYmplY3Qua2V5cyhjb250ZXh0KSxcbiAgICAgICAgICAgICAgICBzY3JpcHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGF3YWl0IGZuKC4uLk9iamVjdC52YWx1ZXMoY29udGV4dCkpO1xuICAgICAgICAgICAgXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb250YWluZXIuY3JlYXRlRWwoJ3AnLCB7XG4gICAgICAgICAgICAgICAgdGV4dDogYFNjcmlwdCBleGVjdXRpb24gZXJyb3I6ICR7ZXJyb3J9YCxcbiAgICAgICAgICAgICAgICBjbHM6ICdleG9jb3J0ZXgtZXJyb3InXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0N1c3RvbSBzY3JpcHQgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwcm9jZXNzVGVtcGxhdGVWYXJpYWJsZXMoXG4gICAgICAgIHRlbXBsYXRlOiBzdHJpbmcsXG4gICAgICAgIGZpbGU6IFRGaWxlLFxuICAgICAgICBmcm9udG1hdHRlcjogYW55XG4gICAgKTogc3RyaW5nIHtcbiAgICAgICAgbGV0IHByb2Nlc3NlZCA9IHRlbXBsYXRlO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVwbGFjZSBmaWxlIHZhcmlhYmxlc1xuICAgICAgICBwcm9jZXNzZWQgPSBwcm9jZXNzZWQucmVwbGFjZSgvXFx7XFx7ZmlsZVxcLm5hbWVcXH1cXH0vZywgZmlsZS5iYXNlbmFtZSk7XG4gICAgICAgIHByb2Nlc3NlZCA9IHByb2Nlc3NlZC5yZXBsYWNlKC9cXHtcXHtmaWxlXFwucGF0aFxcfVxcfS9nLCBmaWxlLnBhdGgpO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVwbGFjZSBmcm9udG1hdHRlciB2YXJpYWJsZXNcbiAgICAgICAgT2JqZWN0LmtleXMoZnJvbnRtYXR0ZXIpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZnJvbnRtYXR0ZXJba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXFxcXHtcXFxce2ZtXFxcXC4ke2tleX1cXFxcfVxcXFx9YCwgJ2cnKTtcbiAgICAgICAgICAgIHByb2Nlc3NlZCA9IHByb2Nlc3NlZC5yZXBsYWNlKHJlZ2V4LCB0aGlzLmZvcm1hdFZhbHVlKHZhbHVlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVwbGFjZSBkYXRlIHZhcmlhYmxlc1xuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBwcm9jZXNzZWQgPSBwcm9jZXNzZWQucmVwbGFjZSgvXFx7XFx7ZGF0ZVxcfVxcfS9nLCBub3cudG9Mb2NhbGVEYXRlU3RyaW5nKCkpO1xuICAgICAgICBwcm9jZXNzZWQgPSBwcm9jZXNzZWQucmVwbGFjZSgvXFx7XFx7dGltZVxcfVxcfS9nLCBub3cudG9Mb2NhbGVUaW1lU3RyaW5nKCkpO1xuICAgICAgICBwcm9jZXNzZWQgPSBwcm9jZXNzZWQucmVwbGFjZSgvXFx7XFx7ZGF0ZXRpbWVcXH1cXH0vZywgbm93LnRvTG9jYWxlU3RyaW5nKCkpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGZvcm1hdFZhbHVlKHZhbHVlOiBhbnkpOiBzdHJpbmcge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuICAgICAgICBcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKHYgPT4gdGhpcy5jbGVhblZhbHVlKHYpKS5qb2luKCcsICcpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpcy5jbGVhblZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNsZWFuVmFsdWUodmFsdWU6IGFueSk6IHN0cmluZyB7XG4gICAgICAgIGlmICghdmFsdWUpIHJldHVybiAnJztcbiAgICAgICAgY29uc3Qgc3RyID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXFtcXFt8XFxdXFxdL2csICcnKTtcbiAgICB9XG59Il0sInZlcnNpb24iOjN9