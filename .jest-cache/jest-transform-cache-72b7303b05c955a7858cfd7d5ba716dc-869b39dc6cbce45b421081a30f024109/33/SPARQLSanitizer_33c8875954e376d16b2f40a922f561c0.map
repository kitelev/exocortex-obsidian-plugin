{"file":"/Users/kitelev/Documents/exocortex-obsidian-plugin/src/application/services/SPARQLSanitizer.ts","mappings":"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","names":[],"sources":["/Users/kitelev/Documents/exocortex-obsidian-plugin/src/application/services/SPARQLSanitizer.ts"],"sourcesContent":["/**\n * SPARQL Query Sanitizer\n * Implements security controls to prevent injection attacks\n */\n\nimport { Result } from \"../../domain/core/Result\";\n\nexport interface SanitizationResult {\n  query: string;\n  modified: boolean;\n  warnings: string[];\n}\n\nexport class SPARQLSanitizer {\n  // Dangerous patterns that could lead to security issues\n  private readonly dangerousPatterns = [\n    // File system access attempts\n    /FILE:/gi,\n    /LOAD\\s+<file:/gi,\n\n    // Command injection patterns\n    /;\\s*DELETE/gi,\n    /;\\s*DROP/gi,\n    /;\\s*INSERT/gi,\n    /;\\s*CLEAR/gi,\n\n    // Path traversal\n    /\\.\\.[\\/\\\\]/g,\n\n    // Null byte injection\n    /\\x00/g,\n\n    // Script injection\n    /<script/gi,\n    /javascript:/gi,\n    /on\\w+\\s*=/gi,\n  ];\n\n  // Allowed SPARQL keywords\n  private readonly allowedKeywords = new Set([\n    \"SELECT\",\n    \"CONSTRUCT\",\n    \"WHERE\",\n    \"FILTER\",\n    \"OPTIONAL\",\n    \"UNION\",\n    \"PREFIX\",\n    \"BASE\",\n    \"DISTINCT\",\n    \"REDUCED\",\n    \"ORDER\",\n    \"BY\",\n    \"ASC\",\n    \"DESC\",\n    \"LIMIT\",\n    \"OFFSET\",\n    \"GRAPH\",\n    \"BIND\",\n    \"VALUES\",\n    \"GROUP\",\n    \"HAVING\",\n    \"SERVICE\",\n    \"MINUS\",\n    \"EXISTS\",\n    \"NOT\",\n    \"IN\",\n    \"AS\",\n  ]);\n\n  /**\n   * Sanitize SPARQL query for safe execution\n   */\n  sanitize(query: string): Result<SanitizationResult> {\n    if (!query || query.trim().length === 0) {\n      return Result.fail(\"Empty query provided\");\n    }\n\n    const warnings: string[] = [];\n    let sanitized = query;\n    let modified = false;\n\n    // Check for dangerous patterns\n    for (const pattern of this.dangerousPatterns) {\n      if (pattern.test(sanitized)) {\n        warnings.push(\n          `Dangerous pattern detected and removed: ${pattern.source}`,\n        );\n        sanitized = sanitized.replace(pattern, \"\");\n        modified = true;\n      }\n    }\n\n    // Validate query structure\n    const validation = this.validateQueryStructure(sanitized);\n    if (validation.warnings.length > 0) {\n      warnings.push(...validation.warnings);\n    }\n\n    // Check for multiple statements\n    if (this.hasMultipleStatements(sanitized)) {\n      warnings.push(\n        \"Multiple statements detected - only first will be executed\",\n      );\n      sanitized = this.extractFirstStatement(sanitized);\n      modified = true;\n    }\n\n    // Validate IRI patterns\n    const iriValidation = this.validateIRIs(sanitized);\n    if (iriValidation.warnings.length > 0) {\n      warnings.push(...iriValidation.warnings);\n    }\n\n    // Check query complexity\n    const complexity = this.checkComplexity(sanitized);\n    if (complexity.tooComplex) {\n      return Result.fail(`Query too complex: ${complexity.reason}`);\n    }\n\n    return Result.ok({\n      query: sanitized,\n      modified,\n      warnings,\n    });\n  }\n\n  /**\n   * Validate query structure\n   */\n  private validateQueryStructure(query: string): {\n    valid: boolean;\n    warnings: string[];\n  } {\n    const warnings: string[] = [];\n    const upperQuery = query.toUpperCase();\n\n    // Check for required keywords\n    if (!upperQuery.includes(\"SELECT\") && !upperQuery.includes(\"CONSTRUCT\")) {\n      warnings.push(\"Query must be SELECT or CONSTRUCT\");\n    }\n\n    // Check for balanced brackets\n    const openBrackets = (query.match(/\\{/g) || []).length;\n    const closeBrackets = (query.match(/\\}/g) || []).length;\n    if (openBrackets !== closeBrackets) {\n      warnings.push(\"Unbalanced brackets detected\");\n    }\n\n    // Check for balanced parentheses\n    const openParens = (query.match(/\\(/g) || []).length;\n    const closeParens = (query.match(/\\)/g) || []).length;\n    if (openParens !== closeParens) {\n      warnings.push(\"Unbalanced parentheses detected\");\n    }\n\n    return {\n      valid: warnings.length === 0,\n      warnings,\n    };\n  }\n\n  /**\n   * Check if query contains multiple statements\n   */\n  private hasMultipleStatements(query: string): boolean {\n    // Look for multiple query keywords\n    const queryKeywords = [\"SELECT\", \"CONSTRUCT\", \"INSERT\", \"DELETE\", \"DROP\"];\n    let count = 0;\n\n    for (const keyword of queryKeywords) {\n      const regex = new RegExp(`\\\\b${keyword}\\\\b`, \"gi\");\n      const matches = query.match(regex);\n      if (matches) {\n        count += matches.length;\n      }\n    }\n\n    return count > 1;\n  }\n\n  /**\n   * Extract first statement from query\n   */\n  private extractFirstStatement(query: string): string {\n    // Find the end of the first complete statement\n    let depth = 0;\n    let inString = false;\n    let stringChar = \"\";\n\n    for (let i = 0; i < query.length; i++) {\n      const char = query[i];\n\n      // Handle string literals\n      if ((char === '\"' || char === \"'\") && query[i - 1] !== \"\\\\\") {\n        if (!inString) {\n          inString = true;\n          stringChar = char;\n        } else if (char === stringChar) {\n          inString = false;\n        }\n      }\n\n      if (!inString) {\n        if (char === \"{\") depth++;\n        if (char === \"}\") depth--;\n\n        // Check if we've completed a statement\n        if (depth === 0 && i > 0) {\n          // Look for next query keyword\n          const remaining = query.substring(i + 1);\n          if (/^\\s*(SELECT|CONSTRUCT|INSERT|DELETE)/i.test(remaining)) {\n            return query.substring(0, i + 1);\n          }\n        }\n      }\n    }\n\n    return query;\n  }\n\n  /**\n   * Validate IRI patterns in query\n   */\n  private validateIRIs(query: string): { valid: boolean; warnings: string[] } {\n    const warnings: string[] = [];\n\n    // Extract IRIs from query\n    const iriPattern = /<([^>]+)>/g;\n    let match;\n\n    while ((match = iriPattern.exec(query)) !== null) {\n      const iri = match[1];\n\n      // Check for suspicious IRI patterns\n      if (iri.includes(\"..\") || iri.includes(\"\\\\\")) {\n        warnings.push(`Suspicious IRI detected: ${iri}`);\n      }\n\n      // Check for local file access\n      if (iri.startsWith(\"file:\")) {\n        warnings.push(`File URI not allowed: ${iri}`);\n      }\n\n      // Check IRI length\n      if (iri.length > 2048) {\n        warnings.push(`IRI too long: ${iri.substring(0, 50)}...`);\n      }\n    }\n\n    return {\n      valid: warnings.length === 0,\n      warnings,\n    };\n  }\n\n  /**\n   * Check query complexity to prevent DoS\n   */\n  private checkComplexity(query: string): {\n    tooComplex: boolean;\n    reason?: string;\n  } {\n    // Check query length\n    if (query.length > 10000) {\n      return { tooComplex: true, reason: \"Query exceeds maximum length\" };\n    }\n\n    // Count triple patterns\n    const triplePatterns = (query.match(/\\.\\s*\\?/g) || []).length;\n    if (triplePatterns > 100) {\n      return { tooComplex: true, reason: \"Too many triple patterns\" };\n    }\n\n    // Count UNION operations\n    const unions = (query.match(/\\bUNION\\b/gi) || []).length;\n    if (unions > 10) {\n      return { tooComplex: true, reason: \"Too many UNION operations\" };\n    }\n\n    // Count nested subqueries\n    const subqueries = (query.match(/\\{[^}]*SELECT/gi) || []).length;\n    if (subqueries > 5) {\n      return { tooComplex: true, reason: \"Too many nested subqueries\" };\n    }\n\n    // Count FILTER operations\n    const filters = (query.match(/\\bFILTER\\b/gi) || []).length;\n    if (filters > 20) {\n      return { tooComplex: true, reason: \"Too many FILTER operations\" };\n    }\n\n    return { tooComplex: false };\n  }\n\n  /**\n   * Escape special characters in literals\n   */\n  escapeStringLiteral(value: string): string {\n    return value\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\"/g, '\\\\\"')\n      .replace(/'/g, \"\\\\'\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/\\t/g, \"\\\\t\");\n  }\n\n  /**\n   * Create safe IRI from user input\n   */\n  createSafeIRI(input: string): string {\n    // Remove dangerous characters\n    const safe = input\n      .replace(/[<>'\"`;]/g, \"\")\n      .replace(/\\s+/g, \"_\")\n      .replace(/[^\\w:/-]/g, \"\");\n\n    // Ensure valid IRI format\n    if (!safe.includes(\":\")) {\n      return `ex:${safe}`;\n    }\n\n    return safe;\n  }\n}\n"],"version":3}