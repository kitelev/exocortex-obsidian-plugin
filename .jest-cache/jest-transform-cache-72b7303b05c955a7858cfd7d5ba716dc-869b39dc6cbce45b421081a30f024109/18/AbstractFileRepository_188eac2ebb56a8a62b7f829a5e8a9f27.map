{"file":"/Users/kitelev/Documents/exocortex-obsidian-plugin/src/shared/AbstractFileRepository.ts","mappings":"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","names":[],"sources":["/Users/kitelev/Documents/exocortex-obsidian-plugin/src/shared/AbstractFileRepository.ts"],"sourcesContent":["import { App, TFile } from \"obsidian\";\nimport { FileOperationUtils } from \"./utils/FileOperationUtils\";\nimport { ErrorHandlingUtils } from \"./utils/ErrorHandlingUtils\";\n\n/**\n * Abstract base class for file-based repositories\n * Implements DRY principle for common file operations across repositories\n */\nexport abstract class AbstractFileRepository {\n  protected app: App;\n\n  constructor(app: App) {\n    this.app = app;\n  }\n\n  /**\n   * Find file using multiple fallback strategies\n   */\n  protected findFileWithFallback(criteria: {\n    uid?: string;\n    storedPath?: string;\n    filename?: string;\n  }): TFile | null {\n    return FileOperationUtils.findFileWithFallback(this.app, criteria);\n  }\n\n  /**\n   * Get all files filtered by frontmatter property\n   */\n  protected getFilesWithProperty(\n    propertyKey: string,\n    propertyValue?: any,\n  ): TFile[] {\n    return FileOperationUtils.getFilesWithProperty(\n      this.app,\n      propertyKey,\n      propertyValue,\n    );\n  }\n\n  /**\n   * Update file frontmatter while preserving body content\n   */\n  protected async updateFileFrontmatter(\n    file: TFile,\n    frontmatter: Record<string, any>,\n  ): Promise<void> {\n    try {\n      await FileOperationUtils.updateFileWithFrontmatter(\n        this.app,\n        file,\n        frontmatter,\n      );\n    } catch (error) {\n      ErrorHandlingUtils.handleRepositoryError(\n        \"Update file frontmatter\",\n        error,\n        { filePath: file.path, frontmatter },\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Create new file with frontmatter\n   */\n  protected async createFileWithFrontmatter(\n    filename: string,\n    frontmatter: Record<string, any>,\n  ): Promise<void> {\n    try {\n      await FileOperationUtils.createFileWithFrontmatter(\n        this.app,\n        filename,\n        frontmatter,\n      );\n    } catch (error) {\n      ErrorHandlingUtils.handleRepositoryError(\n        \"Create file with frontmatter\",\n        error,\n        { filename, frontmatter },\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Update frontmatter by file path\n   */\n  protected async updateFrontmatterByPath(\n    filePath: string,\n    updates: Record<string, any>,\n  ): Promise<void> {\n    try {\n      const file = this.app.vault.getAbstractFileByPath(filePath);\n\n      if (!(file instanceof TFile)) {\n        throw ErrorHandlingUtils.createError(\n          \"FILE_NOT_FOUND\",\n          `File not found: ${filePath}`,\n        );\n      }\n\n      const content = await this.app.vault.read(file);\n      const cache = this.app.metadataCache.getFileCache(file);\n      const currentFrontmatter = cache?.frontmatter || {};\n\n      // Merge updates with current frontmatter\n      const newFrontmatter = FileOperationUtils.mergeFrontmatter(\n        currentFrontmatter,\n        updates,\n      );\n\n      await this.updateFileFrontmatter(file, newFrontmatter);\n    } catch (error) {\n      ErrorHandlingUtils.handleRepositoryError(\n        \"Update frontmatter by path\",\n        error,\n        { filePath, updates },\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Extract entity from frontmatter with error handling\n   */\n  protected extractEntityFromFrontmatter<T>(\n    file: TFile,\n    extractorFn: (\n      frontmatter: Record<string, any>,\n      basename: string,\n    ) => T | null,\n    entityType: string,\n  ): T | null {\n    try {\n      const cache = this.app.metadataCache.getFileCache(file);\n      if (!cache?.frontmatter) {\n        return null;\n      }\n\n      return extractorFn(cache.frontmatter, file.basename);\n    } catch (error) {\n      ErrorHandlingUtils.handleRepositoryError(\n        `Extract ${entityType} from frontmatter`,\n        error,\n        { filePath: file.path },\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Save entity with consistent error handling\n   */\n  protected async saveEntityWithFrontmatter<T>(\n    entity: T,\n    getTitle: (entity: T) => string,\n    toFrontmatter: (entity: T) => Record<string, any>,\n    findExistingFile: (entity: T) => TFile | null,\n    entityType: string,\n  ): Promise<void> {\n    try {\n      const frontmatter = toFrontmatter(entity);\n      const existingFile = findExistingFile(entity);\n\n      if (existingFile) {\n        await this.updateFileFrontmatter(existingFile, frontmatter);\n      } else {\n        const fileName = `${getTitle(entity)}.md`;\n        await this.createFileWithFrontmatter(fileName, frontmatter);\n      }\n    } catch (error) {\n      ErrorHandlingUtils.handleRepositoryError(`Save ${entityType}`, error, {\n        entity,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Delete file by entity with consistent error handling\n   */\n  protected async deleteFileByEntity<T>(\n    entity: T,\n    getTitle: (entity: T) => string,\n    entityType: string,\n  ): Promise<void> {\n    try {\n      const fileName = `${getTitle(entity)}.md`;\n      const file = this.app.vault.getAbstractFileByPath(fileName);\n\n      if (file) {\n        await this.app.vault.delete(file);\n      }\n    } catch (error) {\n      ErrorHandlingUtils.handleRepositoryError(`Delete ${entityType}`, error, {\n        entity,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Check if entity exists with consistent error handling\n   */\n  protected async entityExists<T>(\n    entity: T,\n    findEntity: (entity: T) => Promise<T | null>,\n    entityType: string,\n  ): Promise<boolean> {\n    try {\n      const found = await findEntity(entity);\n      return found !== null;\n    } catch (error) {\n      ErrorHandlingUtils.handleRepositoryError(\n        `Check ${entityType} existence`,\n        error,\n        { entity },\n      );\n      return false;\n    }\n  }\n\n  /**\n   * Find all entities of a type with consistent error handling\n   */\n  protected async findAllEntities<T>(\n    propertyKey: string,\n    extractorFn: (\n      frontmatter: Record<string, any>,\n      basename: string,\n    ) => T | null,\n    entityType: string,\n    additionalFilter?: (file: TFile) => boolean,\n  ): Promise<T[]> {\n    try {\n      const files = this.getFilesWithProperty(propertyKey);\n      const entities: T[] = [];\n\n      for (const file of files) {\n        if (additionalFilter && !additionalFilter(file)) {\n          continue;\n        }\n\n        const entity = this.extractEntityFromFrontmatter(\n          file,\n          extractorFn,\n          entityType,\n        );\n\n        if (entity) {\n          entities.push(entity);\n        }\n      }\n\n      return entities;\n    } catch (error) {\n      ErrorHandlingUtils.handleRepositoryError(\n        `Find all ${entityType}s`,\n        error,\n        { propertyKey },\n      );\n      return [];\n    }\n  }\n\n  /**\n   * Check if reference value matches target asset\n   */\n  protected isReferencingAsset(\n    referenceValue: any,\n    assetName: string,\n  ): boolean {\n    return FileOperationUtils.isReferencingAsset(referenceValue, assetName);\n  }\n}\n"],"version":3}