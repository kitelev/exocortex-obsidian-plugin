{"file":"/Users/kitelev/Documents/exocortex-obsidian-plugin/src/application/services/RDFParser.ts","mappings":"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","names":[],"sources":["/Users/kitelev/Documents/exocortex-obsidian-plugin/src/application/services/RDFParser.ts"],"sourcesContent":["/**\n * RDF Parser for parsing various RDF formats and converting to Graph instances\n * Supports Turtle (.ttl), N-Triples (.nt), JSON-LD (.jsonld), and RDF/XML (.rdf)\n */\n\nimport { Graph } from \"../../domain/semantic/core/Graph\";\nimport {\n  Triple,\n  IRI,\n  BlankNode,\n  Literal,\n} from \"../../domain/semantic/core/Triple\";\nimport { Result } from \"../../domain/core/Result\";\nimport { NamespaceManager } from \"./NamespaceManager\";\nimport { RDFFormat } from \"./RDFSerializer\";\n\nexport interface ParseOptions {\n  format?: RDFFormat;\n  baseIRI?: string;\n  namespaceManager?: NamespaceManager;\n  validateInput?: boolean;\n  strictMode?: boolean;\n}\n\nexport interface ParseResult {\n  graph: Graph;\n  tripleCount: number;\n  namespaces: Record<string, string>;\n  warnings?: string[];\n  errors?: string[];\n}\n\nexport class RDFParser {\n  private namespaceManager: NamespaceManager;\n\n  constructor(namespaceManager?: NamespaceManager) {\n    this.namespaceManager = namespaceManager || new NamespaceManager();\n  }\n\n  /**\n   * Parse RDF content into a Graph\n   */\n  parse(content: string, options: ParseOptions = {}): Result<ParseResult> {\n    try {\n      const nm = options.namespaceManager || this.namespaceManager.clone();\n      const format = options.format || this.detectFormat(content);\n      const warnings: string[] = [];\n      const errors: string[] = [];\n\n      let graph: Graph;\n\n      switch (format) {\n        case \"turtle\":\n          graph = this.parseTurtle(content, nm, options, warnings, errors);\n          break;\n\n        case \"n-triples\":\n          graph = this.parseNTriples(content, warnings, errors);\n          break;\n\n        case \"json-ld\":\n          graph = this.parseJSONLD(content, nm, options, warnings, errors);\n          break;\n\n        case \"rdf-xml\":\n          graph = this.parseRDFXML(content, nm, options, warnings, errors);\n          break;\n\n        default:\n          return Result.fail(`Unsupported format: ${format}`);\n      }\n\n      // Validate graph if requested\n      if (options.validateInput) {\n        const validationErrors = this.validateGraph(graph);\n        errors.push(...validationErrors);\n      }\n\n      // Return error if strict mode and errors found\n      if (options.strictMode && errors.length > 0) {\n        return Result.fail(`Parse errors in strict mode: ${errors.join(\"; \")}`);\n      }\n\n      const result: ParseResult = {\n        graph,\n        tripleCount: graph.size(),\n        namespaces: this.extractNamespaces(nm),\n        warnings: warnings.length > 0 ? warnings : undefined,\n        errors: errors.length > 0 ? errors : undefined,\n      };\n\n      return Result.ok(result);\n    } catch (error) {\n      return Result.fail(`Parse failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Detect RDF format from content\n   */\n  private detectFormat(content: string): RDFFormat {\n    const trimmed = content.trim();\n\n    // Check for JSON-LD\n    if (trimmed.startsWith(\"{\") && trimmed.endsWith(\"}\")) {\n      try {\n        const parsed = JSON.parse(trimmed);\n        if (parsed[\"@context\"] || parsed[\"@graph\"] || parsed[\"@id\"]) {\n          return \"json-ld\";\n        }\n      } catch {\n        // Not valid JSON\n      }\n    }\n\n    // Check for RDF/XML\n    if (trimmed.startsWith(\"<?xml\") || trimmed.includes(\"<rdf:RDF\")) {\n      return \"rdf-xml\";\n    }\n\n    // Check for Turtle prefixes\n    if (trimmed.includes(\"@prefix\") || trimmed.includes(\"@base\")) {\n      return \"turtle\";\n    }\n\n    // Check for N-Triples (every line ends with ' .')\n    const lines = trimmed.split(\"\\n\").filter((line) => line.trim());\n    if (lines.every((line) => line.trim().endsWith(\" .\"))) {\n      // Further check for angle brackets (IRIs) or quotes (literals)\n      if (lines.some((line) => line.includes(\"<\") && line.includes(\">\"))) {\n        return \"n-triples\";\n      }\n    }\n\n    // Default to Turtle\n    return \"turtle\";\n  }\n\n  /**\n   * Parse Turtle format\n   */\n  private parseTurtle(\n    content: string,\n    nm: NamespaceManager,\n    options: ParseOptions,\n    warnings: string[],\n    errors: string[],\n  ): Graph {\n    const graph = new Graph();\n    let currentSubject: IRI | BlankNode | null = null;\n    let baseIRI = options.baseIRI;\n\n    // First, extract and process all prefix declarations\n    // Handle both single-line and multi-line content\n    const prefixPattern = /@prefix\\s+(\\w+):\\s+<([^>]+)>\\s*\\./g;\n    let match;\n    while ((match = prefixPattern.exec(content)) !== null) {\n      nm.addBinding(match[1], match[2]);\n    }\n\n    // Remove prefix declarations from content\n    let processedContent = content.replace(\n      /@prefix\\s+\\w+:\\s+<[^>]+>\\s*\\./g,\n      \"\",\n    );\n\n    // Also handle @base declarations\n    const basePattern = /@base\\s+<([^>]+)>\\s*\\./g;\n    const baseMatch = basePattern.exec(processedContent);\n    if (baseMatch) {\n      baseIRI = baseMatch[1];\n      processedContent = processedContent.replace(/@base\\s+<[^>]+>\\s*\\./g, \"\");\n    }\n\n    // Split the remaining content into statements\n    // Statements end with . (but not inside quotes)\n    const statements = processedContent\n      .split(/\\.\\s*(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/)\n      .filter((s) => s.trim());\n\n    for (let i = 0; i < statements.length; i++) {\n      const statement = statements[i].trim();\n\n      if (!statement || statement.startsWith(\"#\")) continue;\n\n      try {\n        // Parse the statement\n        const triples = this.parseTurtleStatement(\n          statement,\n          nm,\n          currentSubject,\n          baseIRI,\n        );\n\n        for (const triple of triples) {\n          if (triple.subject) {\n            currentSubject = triple.subject;\n          }\n\n          if (triple.triple) {\n            graph.add(triple.triple);\n          }\n        }\n      } catch (error) {\n        const errorMsg = `Statement ${i + 1}: ${error.message}`;\n        if (options.strictMode) {\n          errors.push(errorMsg);\n        } else {\n          warnings.push(errorMsg);\n        }\n      }\n    }\n\n    return graph;\n  }\n\n  /**\n   * Parse a single Turtle statement\n   */\n  private parseTurtleStatement(\n    statement: string,\n    nm: NamespaceManager,\n    currentSubject: IRI | BlankNode | null,\n    baseIRI?: string,\n  ): Array<{ subject?: IRI | BlankNode; triple?: Triple }> {\n    const results: Array<{ subject?: IRI | BlankNode; triple?: Triple }> = [];\n\n    // Clean up the statement\n    statement = statement.trim();\n    if (!statement) return results;\n\n    // Remove trailing .\n    statement = statement.replace(/\\.\\s*$/, \"\");\n\n    // Simple approach: if statement contains semicolon, it's a multi-predicate statement\n    if (statement.includes(\";\")) {\n      // Split by ; to handle multiple predicates for same subject\n      const parts = statement\n        .split(\";\")\n        .map((s) => s.trim())\n        .filter((s) => s);\n\n      let subject: IRI | BlankNode | null = null;\n\n      for (let i = 0; i < parts.length; i++) {\n        const tokens = this.tokenizeTurtleLine(parts[i]);\n\n        if (i === 0 && tokens.length >= 3) {\n          // First part has subject predicate object\n          subject = this.parseNode(tokens[0], nm, baseIRI) as IRI | BlankNode;\n          const predicate = this.parseNode(tokens[1], nm, baseIRI) as IRI;\n          const object = this.parseNode(tokens[2], nm, baseIRI);\n\n          const triple = new Triple(subject, predicate, object);\n          results.push({ subject, triple });\n        } else if (subject && tokens.length >= 2) {\n          // Subsequent parts have predicate object\n          const predicate = this.parseNode(tokens[0], nm, baseIRI) as IRI;\n          const object = this.parseNode(tokens[1], nm, baseIRI);\n\n          const triple = new Triple(subject, predicate, object);\n          results.push({ triple });\n        }\n      }\n    } else {\n      // Simple single triple\n      const tokens = this.tokenizeTurtleLine(statement);\n\n      if (tokens.length >= 3) {\n        const subject = this.parseNode(tokens[0], nm, baseIRI) as\n          | IRI\n          | BlankNode;\n        const predicate = this.parseNode(tokens[1], nm, baseIRI) as IRI;\n        const object = this.parseNode(tokens[2], nm, baseIRI);\n\n        const triple = new Triple(subject, predicate, object);\n        results.push({ subject, triple });\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Tokenize a Turtle line\n   */\n  private tokenizeTurtleLine(line: string): string[] {\n    const tokens: string[] = [];\n    let current = \"\";\n    let inQuotes = false;\n    let quoteChar = \"\";\n    let inBrackets = false;\n    let afterQuote = false;\n\n    for (let i = 0; i < line.length; i++) {\n      const char = line[i];\n      const nextChar = i < line.length - 1 ? line[i + 1] : \"\";\n\n      if (char === '\"' || char === \"'\") {\n        if (!inQuotes) {\n          inQuotes = true;\n          quoteChar = char;\n          afterQuote = false;\n        } else if (char === quoteChar) {\n          inQuotes = false;\n          quoteChar = \"\";\n          afterQuote = true;\n        }\n        current += char;\n      } else if (char === \"<\") {\n        inBrackets = true;\n        current += char;\n      } else if (char === \">\") {\n        inBrackets = false;\n        current += char;\n        // Check if this is followed by a space or end of line\n        if (nextChar === \" \" || nextChar === \"\") {\n          if (current) {\n            tokens.push(current);\n            current = \"\";\n          }\n        }\n      } else if (char === \"^\" && nextChar === \"^\" && afterQuote) {\n        // Datatype marker - include it with the literal\n        current += \"^^\";\n        i++; // Skip next ^\n      } else if (char === \" \" && !inQuotes && !inBrackets) {\n        if (current) {\n          tokens.push(current);\n          current = \"\";\n          afterQuote = false;\n        }\n      } else {\n        current += char;\n      }\n    }\n\n    if (current) {\n      tokens.push(current);\n    }\n\n    return tokens;\n  }\n\n  /**\n   * Parse N-Triples format\n   */\n  private parseNTriples(\n    content: string,\n    warnings: string[],\n    errors: string[],\n  ): Graph {\n    const graph = new Graph();\n    const lines = content.split(\"\\n\");\n\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i].trim();\n\n      if (!line || line.startsWith(\"#\")) continue;\n\n      try {\n        const triple = this.parseNTriplesLine(line);\n        if (triple) {\n          graph.add(triple);\n        }\n      } catch (error) {\n        warnings.push(`Line ${i + 1}: ${error.message}`);\n      }\n    }\n\n    return graph;\n  }\n\n  /**\n   * Parse a single N-Triples line\n   */\n  private parseNTriplesLine(line: string): Triple | null {\n    // N-Triples format: <subject> <predicate> <object> .\n    const match = line.match(\n      /^(<[^>]+>|_:[a-zA-Z0-9]+)\\s+(<[^>]+>)\\s+(<[^>]+>|_:[a-zA-Z0-9]+|\"[^\"]*\"(?:\\^\\^<[^>]+>|@[a-z-]+)?)\\s+\\.\\s*$/,\n    );\n\n    if (!match) {\n      throw new Error(`Invalid N-Triples format: ${line}`);\n    }\n\n    const [, subjectStr, predicateStr, objectStr] = match;\n\n    const subject = this.parseNTriplesNode(subjectStr) as IRI | BlankNode;\n    const predicate = this.parseNTriplesNode(predicateStr) as IRI;\n    const object = this.parseNTriplesNode(objectStr);\n\n    return new Triple(subject, predicate, object);\n  }\n\n  /**\n   * Parse JSON-LD format\n   */\n  private parseJSONLD(\n    content: string,\n    nm: NamespaceManager,\n    options: ParseOptions,\n    warnings: string[],\n    errors: string[],\n  ): Graph {\n    const graph = new Graph();\n\n    try {\n      const jsonld = JSON.parse(content);\n\n      // Extract context\n      if (jsonld[\"@context\"]) {\n        this.processJSONLDContext(jsonld[\"@context\"], nm);\n      }\n\n      // Process graph\n      const graphData =\n        jsonld[\"@graph\"] || (Array.isArray(jsonld) ? jsonld : [jsonld]);\n      const subjects = Array.isArray(graphData) ? graphData : [graphData];\n\n      for (const subject of subjects) {\n        this.processJSONLDSubject(subject, graph, nm, options.baseIRI);\n      }\n    } catch (error) {\n      errors.push(`JSON-LD parse error: ${error.message}`);\n    }\n\n    return graph;\n  }\n\n  /**\n   * Process JSON-LD context\n   */\n  private processJSONLDContext(context: any, nm: NamespaceManager): void {\n    if (typeof context === \"string\") {\n      // URL context - would need to fetch\n      return;\n    }\n\n    if (typeof context === \"object\") {\n      for (const [key, value] of Object.entries(context)) {\n        if (typeof value === \"string\" && key !== \"@base\" && key !== \"@vocab\") {\n          nm.addBinding(key, value);\n        }\n      }\n    }\n  }\n\n  /**\n   * Process JSON-LD subject\n   */\n  private processJSONLDSubject(\n    subject: any,\n    graph: Graph,\n    nm: NamespaceManager,\n    baseIRI?: string,\n  ): void {\n    if (!subject[\"@id\"]) return;\n\n    const subjectNode = this.parseJSONLDNode(subject[\"@id\"], nm, baseIRI) as\n      | IRI\n      | BlankNode;\n\n    for (const [predicate, values] of Object.entries(subject)) {\n      if (predicate === \"@id\" || predicate === \"@context\") continue;\n\n      const predicateIRI = this.parseJSONLDPredicate(predicate, nm, baseIRI);\n      const valueArray = Array.isArray(values) ? values : [values];\n\n      for (const value of valueArray) {\n        const objectNode = this.parseJSONLDValue(value, nm, baseIRI);\n        const triple = new Triple(subjectNode, predicateIRI, objectNode);\n        graph.add(triple);\n      }\n    }\n  }\n\n  /**\n   * Parse RDF/XML format (basic implementation)\n   */\n  private parseRDFXML(\n    content: string,\n    nm: NamespaceManager,\n    options: ParseOptions,\n    warnings: string[],\n    errors: string[],\n  ): Graph {\n    const graph = new Graph();\n    warnings.push(\n      \"RDF/XML parsing is limited - consider using a specialized XML parser\",\n    );\n\n    // This is a simplified implementation\n    // A full implementation would use a proper XML parser\n\n    return graph;\n  }\n\n  /**\n   * Parse a node (IRI, BlankNode, or Literal)\n   */\n  private parseNode(\n    nodeStr: string,\n    nm: NamespaceManager,\n    baseIRI?: string,\n  ): IRI | BlankNode | Literal {\n    nodeStr = nodeStr.trim();\n\n    // Blank node\n    if (nodeStr.startsWith(\"_:\")) {\n      return new BlankNode(nodeStr);\n    }\n\n    // Full IRI\n    if (nodeStr.startsWith(\"<\") && nodeStr.endsWith(\">\")) {\n      const iri = nodeStr.slice(1, -1);\n      return new IRI(baseIRI && !iri.includes(\"://\") ? baseIRI + iri : iri);\n    }\n\n    // Literal\n    if (nodeStr.startsWith('\"')) {\n      return this.parseLiteral(nodeStr);\n    }\n\n    // CURIE\n    if (nodeStr.includes(\":\")) {\n      const expanded = nm.expandCURIE(nodeStr);\n      if (expanded.isSuccess) {\n        return expanded.getValue();\n      }\n    }\n\n    throw new Error(`Cannot parse node: ${nodeStr}`);\n  }\n\n  /**\n   * Parse N-Triples node\n   */\n  private parseNTriplesNode(nodeStr: string): IRI | BlankNode | Literal {\n    nodeStr = nodeStr.trim();\n\n    // IRI\n    if (nodeStr.startsWith(\"<\") && nodeStr.endsWith(\">\")) {\n      return new IRI(nodeStr.slice(1, -1));\n    }\n\n    // Blank node\n    if (nodeStr.startsWith(\"_:\")) {\n      return new BlankNode(nodeStr);\n    }\n\n    // Literal\n    if (nodeStr.startsWith('\"')) {\n      return this.parseLiteral(nodeStr);\n    }\n\n    throw new Error(`Cannot parse N-Triples node: ${nodeStr}`);\n  }\n\n  /**\n   * Parse JSON-LD node\n   */\n  private parseJSONLDNode(\n    nodeId: string,\n    nm: NamespaceManager,\n    baseIRI?: string,\n  ): IRI | BlankNode {\n    if (nodeId.startsWith(\"_:\")) {\n      return new BlankNode(nodeId);\n    }\n\n    if (nodeId.includes(\":\") && !nodeId.startsWith(\"http\")) {\n      const expanded = nm.expandCURIE(nodeId);\n      if (expanded.isSuccess) {\n        return expanded.getValue();\n      }\n    }\n\n    return new IRI(\n      baseIRI && !nodeId.includes(\"://\") ? baseIRI + nodeId : nodeId,\n    );\n  }\n\n  /**\n   * Parse JSON-LD predicate\n   */\n  private parseJSONLDPredicate(\n    predicate: string,\n    nm: NamespaceManager,\n    baseIRI?: string,\n  ): IRI {\n    if (predicate.includes(\":\") && !predicate.startsWith(\"http\")) {\n      const expanded = nm.expandCURIE(predicate);\n      if (expanded.isSuccess) {\n        return expanded.getValue();\n      }\n    }\n\n    return new IRI(\n      baseIRI && !predicate.includes(\"://\") ? baseIRI + predicate : predicate,\n    );\n  }\n\n  /**\n   * Parse JSON-LD value\n   */\n  private parseJSONLDValue(\n    value: any,\n    nm: NamespaceManager,\n    baseIRI?: string,\n  ): IRI | BlankNode | Literal {\n    if (typeof value === \"string\") {\n      return Literal.string(value);\n    }\n\n    if (typeof value === \"number\") {\n      return Number.isInteger(value)\n        ? Literal.integer(value)\n        : Literal.double(value);\n    }\n\n    if (typeof value === \"boolean\") {\n      return Literal.boolean(value);\n    }\n\n    if (typeof value === \"object\") {\n      if (value[\"@id\"]) {\n        return this.parseJSONLDNode(value[\"@id\"], nm, baseIRI);\n      }\n\n      if (value[\"@value\"]) {\n        let literal = new Literal(value[\"@value\"]);\n\n        if (value[\"@type\"]) {\n          const datatype = this.parseJSONLDPredicate(\n            value[\"@type\"],\n            nm,\n            baseIRI,\n          );\n          literal = new Literal(value[\"@value\"], datatype);\n        }\n\n        if (value[\"@language\"]) {\n          literal = new Literal(value[\"@value\"], undefined, value[\"@language\"]);\n        }\n\n        return literal;\n      }\n    }\n\n    throw new Error(`Cannot parse JSON-LD value: ${JSON.stringify(value)}`);\n  }\n\n  /**\n   * Parse a literal string\n   */\n  private parseLiteral(literalStr: string): Literal {\n    // Basic literal: \"value\"\n    let match = literalStr.match(/^\"([^\"]*)\"$/);\n    if (match) {\n      return new Literal(match[1]);\n    }\n\n    // Literal with language: \"value\"@lang\n    match = literalStr.match(/^\"([^\"]*)\"@([a-z-]+)$/);\n    if (match) {\n      return new Literal(match[1], undefined, match[2]);\n    }\n\n    // Literal with datatype: \"value\"^^<datatype>\n    match = literalStr.match(/^\"([^\"]*)\"(?:\\^\\^)<([^>]+)>$/);\n    if (match) {\n      return new Literal(match[1], new IRI(match[2]));\n    }\n\n    // Alternative: Try without regex escaping\n    if (literalStr.includes(\"^^<\")) {\n      const parts = literalStr.split(\"^^\");\n      if (parts.length === 2) {\n        const value = parts[0].replace(/^\"|\"$/g, \"\");\n        const datatype = parts[1].replace(/^<|>$/g, \"\");\n        return new Literal(value, new IRI(datatype));\n      }\n    }\n\n    // Literal with datatype CURIE: \"value\"^^prefix:local\n    match = literalStr.match(/^\"([^\"]*)\"(?:\\^\\^)([^\\s]+)$/);\n    if (match) {\n      // Would need namespace manager to expand CURIE\n      return new Literal(match[1]);\n    }\n\n    throw new Error(`Cannot parse literal: ${literalStr}`);\n  }\n\n  /**\n   * Validate parsed graph\n   */\n  private validateGraph(graph: Graph): string[] {\n    const errors: string[] = [];\n\n    for (const triple of graph.toArray()) {\n      // Validate subject (must be IRI or BlankNode)\n      const subject = triple.getSubject();\n      if (!(subject instanceof IRI) && !(subject instanceof BlankNode)) {\n        errors.push(`Invalid subject type: ${typeof subject}`);\n      }\n\n      // Validate predicate (must be IRI)\n      const predicate = triple.getPredicate();\n      if (!(predicate instanceof IRI)) {\n        errors.push(`Invalid predicate type: ${typeof predicate}`);\n      }\n\n      // Object can be any node type - no validation needed\n    }\n\n    return errors;\n  }\n\n  /**\n   * Extract namespaces from namespace manager\n   */\n  private extractNamespaces(nm: NamespaceManager): Record<string, string> {\n    const namespaces: Record<string, string> = {};\n\n    for (const binding of nm.getAllBindings()) {\n      namespaces[binding.prefix] = binding.namespace.toString();\n    }\n\n    return namespaces;\n  }\n}\n"],"version":3}