{"file":"/Users/kitelev/Documents/exocortex-obsidian-plugin/src/infrastructure/adapters/ObsidianVaultAdapter.ts","mappings":"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","names":[],"sources":["/Users/kitelev/Documents/exocortex-obsidian-plugin/src/infrastructure/adapters/ObsidianVaultAdapter.ts"],"sourcesContent":["import { Vault, MetadataCache, TFile } from \"obsidian\";\nimport { IVaultAdapter } from \"../../application/ports/IVaultAdapter\";\n\n/**\n * Adapter for Obsidian Vault API\n * Implements the IVaultAdapter interface using Obsidian's Vault\n */\nexport class ObsidianVaultAdapter implements IVaultAdapter {\n  constructor(\n    private readonly vault: Vault,\n    private readonly metadataCache: MetadataCache,\n  ) {}\n\n  async create(path: string, content: string): Promise<void> {\n    await this.vault.create(path, content);\n  }\n\n  async read(path: string): Promise<string> {\n    const file = this.vault.getAbstractFileByPath(path);\n    if (!file || !(file instanceof TFile)) {\n      throw new Error(`File not found: ${path}`);\n    }\n    return await this.vault.read(file);\n  }\n\n  async update(path: string, content: string): Promise<void> {\n    const file = this.vault.getAbstractFileByPath(path);\n    if (!file || !(file instanceof TFile)) {\n      throw new Error(`File not found: ${path}`);\n    }\n    await this.vault.modify(file, content);\n  }\n\n  async delete(path: string): Promise<void> {\n    const file = this.vault.getAbstractFileByPath(path);\n    if (!file) {\n      throw new Error(`File not found: ${path}`);\n    }\n    await this.vault.delete(file);\n  }\n\n  async exists(path: string): Promise<boolean> {\n    const file = this.vault.getAbstractFileByPath(path);\n    return file !== null;\n  }\n\n  async list(pattern?: string): Promise<string[]> {\n    const files = this.vault.getFiles();\n    if (!pattern) {\n      return files.map((f) => f.path);\n    }\n\n    // Simple pattern matching (could be enhanced with glob)\n    const regex = new RegExp(pattern);\n    return files.filter((f) => regex.test(f.path)).map((f) => f.path);\n  }\n\n  async getMetadata(path: string): Promise<Record<string, any> | null> {\n    const file = this.vault.getAbstractFileByPath(path);\n    if (!file || !(file instanceof TFile)) {\n      return null;\n    }\n\n    const cache = this.metadataCache.getFileCache(file);\n    return cache?.frontmatter || null;\n  }\n\n  async getFiles(): Promise<any[]> {\n    return this.vault.getFiles();\n  }\n\n  async getFileMetadata(file: any): Promise<any> {\n    if (!(file instanceof TFile)) {\n      return null;\n    }\n\n    const cache = this.metadataCache.getFileCache(file);\n    return cache || null;\n  }\n}\n"],"version":3}