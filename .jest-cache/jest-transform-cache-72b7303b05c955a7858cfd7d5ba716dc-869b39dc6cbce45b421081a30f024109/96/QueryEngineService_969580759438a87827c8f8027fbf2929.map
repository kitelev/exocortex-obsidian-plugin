{"file":"/Users/kitelev/Documents/exocortex-obsidian-plugin/src/application/services/QueryEngineService.ts","mappings":";;;AAMA,+EAA4E;AAC5E,qDAAkD;AAElD;;;GAGG;AACH,MAAa,kBAAkB;IAM7B,YACU,kBAAuB,EAAE,6DAA6D;IAC9F,MAA0B;QADlB,uBAAkB,GAAlB,kBAAkB,CAAK;QANzB,eAAU,GAChB,IAAI,GAAG,EAAE,CAAC;QACJ,kBAAa,GAAwB,IAAI,CAAC;QAOhD,IAAI,CAAC,MAAM,GAAG,MAAM,IAAI,qCAAiB,CAAC,aAAa,EAAE,CAAC,QAAQ,EAAG,CAAC;IACxE,CAAC;IAED;;OAEG;IACI,KAAK,CAAC,YAAY,CACvB,KAAa,EACb,OAAsB,EACtB,gBAAkC;QAElC,oBAAoB;QACpB,IAAI,IAAI,CAAC,MAAM,CAAC,WAAW,EAAE;YAC3B,MAAM,MAAM,GAAG,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;YACpD,IAAI,MAAM,EAAE;gBACV,OAAO,eAAM,CAAC,EAAE,CAAc,MAAM,CAAC,CAAC;aACvC;SACF;QAED,yBAAyB;QACzB,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,gBAAgB,CAAC,CAAC;QACjE,IAAI,CAAC,YAAY,CAAC,SAAS,EAAE;YAC3B,OAAO,eAAM,CAAC,IAAI,CAAc,YAAY,CAAC,QAAQ,EAAE,CAAC,CAAC;SAC1D;QAED,MAAM,MAAM,GAAG,YAAY,CAAC,QAAQ,EAAG,CAAC;QAExC,gBAAgB;QAChB,MAAM,WAAW,GAAG,MAAM,MAAM,CAAC,YAAY,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;QAE9D,2BAA2B;QAC3B,IAAI,WAAW,CAAC,SAAS,IAAI,IAAI,CAAC,MAAM,CAAC,WAAW,EAAE;YACpD,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,OAAO,EAAE,WAAW,CAAC,QAAQ,EAAG,CAAC,CAAC;SAC3D;QAED,OAAO,WAAW,CAAC;IACrB,CAAC;IAED;;OAEG;IACI,KAAK,CAAC,WAAW,CACtB,SAAsB,EACtB,KAAa,EACb,OAAsB,EACtB,gBAAkC;QAElC,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,gBAAgB,CAAC,CAAC;QACjE,IAAI,CAAC,YAAY,CAAC,SAAS,EAAE;YAC3B,SAAS,CAAC,QAAQ,CAAC,GAAG,EAAE;gBACtB,IAAI,EAAE,uBAAuB,YAAY,CAAC,QAAQ,EAAE,EAAE;gBACtD,GAAG,EAAE,iBAAiB;aACvB,CAAC,CAAC;YACH,OAAO,eAAM,CAAC,IAAI,CAAO,YAAY,CAAC,QAAQ,EAAE,CAAC,CAAC;SACnD;QAED,MAAM,MAAM,GAAG,YAAY,CAAC,QAAQ,EAAG,CAAC;QACxC,OAAO,MAAM,CAAC,WAAW,CAAC,SAAS,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;IACvD,CAAC;IAED;;OAEG;IACI,KAAK,CAAC,QAAQ,CACnB,MAAc,EACd,gBAAkC;QAElC,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,gBAAgB,CAAC,CAAC;QACjE,IAAI,CAAC,YAAY,CAAC,SAAS,EAAE;YAC3B,OAAO,eAAM,CAAC,IAAI,CAAQ,YAAY,CAAC,QAAQ,EAAE,CAAC,CAAC;SACpD;QAED,MAAM,MAAM,GAAG,YAAY,CAAC,QAAQ,EAAG,CAAC;QACxC,OAAO,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;IACjC,CAAC;IAED;;OAEG;IACI,KAAK,CAAC,eAAe,CAC1B,IAAY,EACZ,gBAAkC;QAElC,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,gBAAgB,CAAC,CAAC;QACjE,IAAI,CAAC,YAAY,CAAC,SAAS,EAAE;YAC3B,OAAO,eAAM,CAAC,IAAI,CAAsB,YAAY,CAAC,QAAQ,EAAE,CAAC,CAAC;SAClE;QAED,MAAM,MAAM,GAAG,YAAY,CAAC,QAAQ,EAAG,CAAC;QACxC,OAAO,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;IACtC,CAAC;IAED;;OAEG;IACI,KAAK,CAAC,aAAa,CACxB,KAAa,EACb,UAA4B;QAE5B,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;QAC3D,IAAI,CAAC,YAAY,CAAC,SAAS,EAAE;YAC3B,OAAO,eAAM,CAAC,IAAI,CAAU,YAAY,CAAC,QAAQ,EAAE,CAAC,CAAC;SACtD;QAED,MAAM,MAAM,GAAG,YAAY,CAAC,QAAQ,EAAG,CAAC;QACxC,OAAO,eAAM,CAAC,EAAE,CAAU,MAAM,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,QAAQ,EAAE,IAAI,KAAK,CAAC,CAAC;IAC7E,CAAC;IAED;;OAEG;IACI,mBAAmB;QACxB,OAAO,IAAI,CAAC,kBAAkB,CAAC,mBAAmB,EAAE,CAAC;IACvD,CAAC;IAED;;OAEG;IACI,iBAAiB,CAAC,IAAqB;QAC5C,OAAO,IAAI,CAAC,kBAAkB,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;IACzD,CAAC;IAED;;OAEG;IACI,YAAY,CAAC,MAAyB;QAC3C,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,CAAC,kDAAkD;QAE7E,IAAI,CAAC,MAAM,CAAC,WAAW,EAAE;YACvB,IAAI,CAAC,UAAU,EAAE,CAAC;SACnB;IACH,CAAC;IAED;;OAEG;IACI,UAAU;QACf,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,CAAC;IAC1B,CAAC;IAED;;OAEG;IACI,aAAa;QAClB,kEAAkE;QAClE,OAAO;YACL,IAAI,EAAE,IAAI,CAAC,UAAU,CAAC,IAAI;YAC1B,OAAO,EAAE,CAAC;YACV,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,YAAY;SAClC,CAAC;IACJ,CAAC;IAED;;OAEG;IACI,cAAc;QACnB,OAAO;YACL,aAAa,EAAE,IAAI,CAAC,aAAa,EAAE,OAAO,EAAE,IAAI,IAAI;YACpD,gBAAgB,EAAE,IAAI,CAAC,mBAAmB,EAAE;YAC5C,MAAM,EAAE;gBACN,SAAS,EAAE,IAAI,CAAC,MAAM,CAAC,eAAe;gBACtC,QAAQ,EAAE,IAAI,CAAC,MAAM,CAAC,cAAc;gBACpC,UAAU,EAAE,IAAI,CAAC,MAAM,CAAC,UAAU;gBAClC,YAAY,EAAE,IAAI,CAAC,MAAM,CAAC,WAAW;aACtC;YACD,KAAK,EAAE,IAAI,CAAC,aAAa,EAAE;YAC3B,OAAO,EAAE,IAAI,CAAC,kBAAkB,CAAC,cAAc,EAAE;SAClD,CAAC;IACJ,CAAC;IAEO,KAAK,CAAC,cAAc,CAC1B,UAA4B;QAE5B,mDAAmD;QACnD,MAAM,UAAU,GAAG,UAAU,IAAI,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC;QAE7D,yEAAyE;QACzE,IACE,IAAI,CAAC,aAAa;YAClB,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,KAAK,UAAU;YAC3C,IAAI,CAAC,aAAa,CAAC,WAAW,EAAE,EAChC;YACA,OAAO,eAAM,CAAC,EAAE,CAAe,IAAI,CAAC,aAAa,CAAC,CAAC;SACpD;QAED,oBAAoB;QACpB,MAAM,YAAY,GAChB,MAAM,IAAI,CAAC,kBAAkB,CAAC,iBAAiB,CAAC,UAAU,CAAC,CAAC;QAE9D,IAAI,YAAY,CAAC,SAAS,EAAE;YAC1B,IAAI,CAAC,aAAa,GAAG,YAAY,CAAC,QAAQ,EAAG,CAAC;YAC9C,OAAO,YAAY,CAAC;SACrB;QAED,oCAAoC;QACpC,IACE,IAAI,CAAC,MAAM,CAAC,cAAc;YAC1B,IAAI,CAAC,MAAM,CAAC,cAAc,KAAK,UAAU,EACzC;YACA,OAAO,CAAC,IAAI,CACV,mBAAmB,UAAU,8BAA8B,IAAI,CAAC,MAAM,CAAC,cAAc,GAAG,CACzF,CAAC;YAEF,MAAM,cAAc,GAAG,MAAM,IAAI,CAAC,kBAAkB,CAAC,iBAAiB,CACpE,IAAI,CAAC,MAAM,CAAC,cAAc,CAC3B,CAAC;YACF,IAAI,cAAc,CAAC,SAAS,EAAE;gBAC5B,IAAI,CAAC,aAAa,GAAG,cAAc,CAAC,QAAQ,EAAG,CAAC;gBAChD,OAAO,cAAc,CAAC;aACvB;SACF;QAED,sDAAsD;QACtD,IAAI,IAAI,CAAC,MAAM,CAAC,UAAU,EAAE;YAC1B,OAAO,CAAC,IAAI,CACV,4DAA4D,CAC7D,CAAC;YAEF,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,kBAAkB,CAAC,iBAAiB,EAAE,CAAC;YACrE,IAAI,UAAU,CAAC,SAAS,EAAE;gBACxB,IAAI,CAAC,aAAa,GAAG,UAAU,CAAC,QAAQ,EAAG,CAAC;gBAC5C,OAAO,UAAU,CAAC;aACnB;SACF;QAED,OAAO,eAAM,CAAC,IAAI,CAAe,4BAA4B,CAAC,CAAC;IACjE,CAAC;IAEO,eAAe,CACrB,KAAa,EACb,OAAsB;QAEtB,MAAM,QAAQ,GAAG,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;QACrD,MAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QAE7C,IAAI,CAAC,MAAM,EAAE;YACX,OAAO,IAAI,CAAC;SACb;QAED,kCAAkC;QAClC,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACvB,MAAM,UAAU,GAAG,CAAC,GAAG,GAAG,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,GAAG,EAAE,CAAC,CAAC;QAE1D,IAAI,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC,YAAY,EAAE;YACzC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;YACjC,OAAO,IAAI,CAAC;SACb;QAED,OAAO,MAAM,CAAC,MAAM,CAAC;IACvB,CAAC;IAEO,WAAW,CACjB,KAAa,EACb,OAAiC,EACjC,MAAmB;QAEnB,sCAAsC;QACtC,IAAI,IAAI,CAAC,UAAU,CAAC,IAAI,IAAI,IAAI,CAAC,MAAM,CAAC,YAAY,EAAE;YACpD,mDAAmD;YACnD,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC,KAAK,CAAC;YACtD,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;SACnC;QAED,MAAM,QAAQ,GAAG,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;QACrD,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,QAAQ,EAAE;YAC5B,MAAM;YACN,SAAS,EAAE,IAAI,CAAC,GAAG,EAAE;SACtB,CAAC,CAAC;IACL,CAAC;IAEO,cAAc,CAAC,KAAa,EAAE,OAAsB;QAC1D,MAAM,UAAU,GAAG,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;QAC1D,OAAO,GAAG,KAAK,IAAI,UAAU,EAAE,CAAC;IAClC,CAAC;CACF;AA7RD,gDA6RC","names":[],"sources":["/Users/kitelev/Documents/exocortex-obsidian-plugin/src/application/services/QueryEngineService.ts"],"sourcesContent":["import {\n  IQueryEngine,\n  QueryEngineType,\n  QueryResult,\n  QueryContext,\n} from \"../../domain/ports/IQueryEngine\";\nimport { QueryEngineConfig } from \"../../domain/entities/QueryEngineConfig\";\nimport { Result } from \"../../domain/core/Result\";\n\n/**\n * Query Engine Service\n * High-level service for executing queries with caching, fallback, and configuration support\n */\nexport class QueryEngineService {\n  private queryCache: Map<string, { result: QueryResult; timestamp: number }> =\n    new Map();\n  private currentEngine: IQueryEngine | null = null;\n  private config: QueryEngineConfig;\n\n  constructor(\n    private queryEngineFactory: any, // IQueryEngineFactory - will be imported from infrastructure\n    config?: QueryEngineConfig,\n  ) {\n    this.config = config || QueryEngineConfig.createDefault().getValue()!;\n  }\n\n  /**\n   * Execute a query with automatic engine selection, caching, and fallback\n   */\n  public async executeQuery(\n    query: string,\n    context?: QueryContext,\n    enginePreference?: QueryEngineType,\n  ): Promise<Result<QueryResult>> {\n    // Check cache first\n    if (this.config.enableCache) {\n      const cached = this.getCachedResult(query, context);\n      if (cached) {\n        return Result.ok<QueryResult>(cached);\n      }\n    }\n\n    // Get appropriate engine\n    const engineResult = await this.getQueryEngine(enginePreference);\n    if (!engineResult.isSuccess) {\n      return Result.fail<QueryResult>(engineResult.getError());\n    }\n\n    const engine = engineResult.getValue()!;\n\n    // Execute query\n    const queryResult = await engine.executeQuery(query, context);\n\n    // Cache successful results\n    if (queryResult.isSuccess && this.config.enableCache) {\n      this.cacheResult(query, context, queryResult.getValue()!);\n    }\n\n    return queryResult;\n  }\n\n  /**\n   * Render a query directly to a container\n   */\n  public async renderQuery(\n    container: HTMLElement,\n    query: string,\n    context?: QueryContext,\n    enginePreference?: QueryEngineType,\n  ): Promise<Result<void>> {\n    const engineResult = await this.getQueryEngine(enginePreference);\n    if (!engineResult.isSuccess) {\n      container.createEl(\"p\", {\n        text: `Query Engine Error: ${engineResult.getError()}`,\n        cls: \"exocortex-error\",\n      });\n      return Result.fail<void>(engineResult.getError());\n    }\n\n    const engine = engineResult.getValue()!;\n    return engine.renderQuery(container, query, context);\n  }\n\n  /**\n   * Get pages from any available engine\n   */\n  public async getPages(\n    source: string,\n    enginePreference?: QueryEngineType,\n  ): Promise<Result<any[]>> {\n    const engineResult = await this.getQueryEngine(enginePreference);\n    if (!engineResult.isSuccess) {\n      return Result.fail<any[]>(engineResult.getError());\n    }\n\n    const engine = engineResult.getValue()!;\n    return engine.getPages(source);\n  }\n\n  /**\n   * Get page metadata from any available engine\n   */\n  public async getPageMetadata(\n    path: string,\n    enginePreference?: QueryEngineType,\n  ): Promise<Result<Record<string, any>>> {\n    const engineResult = await this.getQueryEngine(enginePreference);\n    if (!engineResult.isSuccess) {\n      return Result.fail<Record<string, any>>(engineResult.getError());\n    }\n\n    const engine = engineResult.getValue()!;\n    return engine.getPageMetadata(path);\n  }\n\n  /**\n   * Validate query syntax\n   */\n  public async validateQuery(\n    query: string,\n    engineType?: QueryEngineType,\n  ): Promise<Result<boolean>> {\n    const engineResult = await this.getQueryEngine(engineType);\n    if (!engineResult.isSuccess) {\n      return Result.fail<boolean>(engineResult.getError());\n    }\n\n    const engine = engineResult.getValue()!;\n    return Result.ok<boolean>(engine.validateQuery(query).getValue() || false);\n  }\n\n  /**\n   * Get information about available engines\n   */\n  public getAvailableEngines(): QueryEngineType[] {\n    return this.queryEngineFactory.getAvailableEngines();\n  }\n\n  /**\n   * Check if a specific engine is available\n   */\n  public isEngineAvailable(type: QueryEngineType): boolean {\n    return this.queryEngineFactory.isEngineAvailable(type);\n  }\n\n  /**\n   * Update configuration\n   */\n  public updateConfig(config: QueryEngineConfig): void {\n    this.config = config;\n    this.currentEngine = null; // Reset current engine to respect new preferences\n\n    if (!config.enableCache) {\n      this.clearCache();\n    }\n  }\n\n  /**\n   * Clear query cache\n   */\n  public clearCache(): void {\n    this.queryCache.clear();\n  }\n\n  /**\n   * Get cache statistics\n   */\n  public getCacheStats(): { size: number; hitRate: number; maxSize: number } {\n    // This would need to be implemented with proper hit/miss tracking\n    return {\n      size: this.queryCache.size,\n      hitRate: 0, // Placeholder\n      maxSize: this.config.maxCacheSize,\n    };\n  }\n\n  /**\n   * Get diagnostic information\n   */\n  public getDiagnostics(): Record<string, any> {\n    return {\n      currentEngine: this.currentEngine?.getType() || null,\n      availableEngines: this.getAvailableEngines(),\n      config: {\n        preferred: this.config.preferredEngine,\n        fallback: this.config.fallbackEngine,\n        autoDetect: this.config.autoDetect,\n        cacheEnabled: this.config.enableCache,\n      },\n      cache: this.getCacheStats(),\n      factory: this.queryEngineFactory.getDiagnostics(),\n    };\n  }\n\n  private async getQueryEngine(\n    preference?: QueryEngineType,\n  ): Promise<Result<IQueryEngine>> {\n    // Use preference if provided, otherwise use config\n    const engineType = preference || this.config.preferredEngine;\n\n    // Try to reuse current engine if it matches preferences and is available\n    if (\n      this.currentEngine &&\n      this.currentEngine.getType() === engineType &&\n      this.currentEngine.isAvailable()\n    ) {\n      return Result.ok<IQueryEngine>(this.currentEngine);\n    }\n\n    // Create new engine\n    const engineResult =\n      await this.queryEngineFactory.createQueryEngine(engineType);\n\n    if (engineResult.isSuccess) {\n      this.currentEngine = engineResult.getValue()!;\n      return engineResult;\n    }\n\n    // Try fallback engine if configured\n    if (\n      this.config.fallbackEngine &&\n      this.config.fallbackEngine !== engineType\n    ) {\n      console.warn(\n        `Primary engine '${engineType}' failed, trying fallback '${this.config.fallbackEngine}'`,\n      );\n\n      const fallbackResult = await this.queryEngineFactory.createQueryEngine(\n        this.config.fallbackEngine,\n      );\n      if (fallbackResult.isSuccess) {\n        this.currentEngine = fallbackResult.getValue()!;\n        return fallbackResult;\n      }\n    }\n\n    // If auto-detect is enabled, try any available engine\n    if (this.config.autoDetect) {\n      console.warn(\n        `Configured engines failed, auto-detecting available engine`,\n      );\n\n      const autoResult = await this.queryEngineFactory.createQueryEngine();\n      if (autoResult.isSuccess) {\n        this.currentEngine = autoResult.getValue()!;\n        return autoResult;\n      }\n    }\n\n    return Result.fail<IQueryEngine>(\"No query engines available\");\n  }\n\n  private getCachedResult(\n    query: string,\n    context?: QueryContext,\n  ): QueryResult | null {\n    const cacheKey = this.createCacheKey(query, context);\n    const cached = this.queryCache.get(cacheKey);\n\n    if (!cached) {\n      return null;\n    }\n\n    // Check if cache entry is expired\n    const now = Date.now();\n    const ageMinutes = (now - cached.timestamp) / (1000 * 60);\n\n    if (ageMinutes > this.config.cacheTimeout) {\n      this.queryCache.delete(cacheKey);\n      return null;\n    }\n\n    return cached.result;\n  }\n\n  private cacheResult(\n    query: string,\n    context: QueryContext | undefined,\n    result: QueryResult,\n  ): void {\n    // Ensure cache doesn't grow too large\n    if (this.queryCache.size >= this.config.maxCacheSize) {\n      // Remove oldest entries (simple LRU approximation)\n      const oldestKey = this.queryCache.keys().next().value;\n      this.queryCache.delete(oldestKey);\n    }\n\n    const cacheKey = this.createCacheKey(query, context);\n    this.queryCache.set(cacheKey, {\n      result,\n      timestamp: Date.now(),\n    });\n  }\n\n  private createCacheKey(query: string, context?: QueryContext): string {\n    const contextStr = context ? JSON.stringify(context) : \"\";\n    return `${query}|${contextStr}`;\n  }\n}\n"],"version":3}