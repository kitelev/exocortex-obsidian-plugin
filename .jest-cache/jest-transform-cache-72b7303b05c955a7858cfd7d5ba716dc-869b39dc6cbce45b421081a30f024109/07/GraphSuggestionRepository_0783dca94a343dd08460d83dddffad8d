c85a20aa373f0e3ff1bbe96faf8e5ac7
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphSuggestionRepository = void 0;
const tslib_1 = require("tslib");
const SPARQLSuggestion_1 = require("../../domain/autocomplete/SPARQLSuggestion");
const QueryContext_1 = require("../../domain/autocomplete/QueryContext");
const Result_1 = require("../../domain/core/Result");
const KeywordSuggestionProvider_1 = require("../autocomplete/KeywordSuggestionProvider");
class GraphSuggestionRepository {
    constructor(graph) {
        this.graph = graph;
        this.keywordProvider = new KeywordSuggestionProvider_1.KeywordSuggestionProvider();
        this.usageStats = {};
        this.propertyCache = new Map();
        this.classCache = new Map();
        this.cacheTimestamp = 0;
        this.cacheTTL = 60000; // 1 minute
    }
    findKeywordSuggestions(context) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const suggestions = this.keywordProvider.getSuggestions(context);
                return Result_1.Result.ok(suggestions);
            }
            catch (error) {
                return Result_1.Result.fail(`Failed to get keyword suggestions: ${error}`);
            }
        });
    }
    findPropertySuggestions(context) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                if (this.shouldRefreshCache()) {
                    this.refreshPropertyCache();
                }
                const cachedSuggestions = this.propertyCache.get(context.getCurrentToken());
                if (cachedSuggestions) {
                    return Result_1.Result.ok(cachedSuggestions);
                }
                const properties = this.extractPropertiesFromGraph();
                const suggestions = properties.map(prop => this.createPropertySuggestion(prop, context));
                this.propertyCache.set(context.getCurrentToken(), suggestions);
                return Result_1.Result.ok(suggestions);
            }
            catch (error) {
                return Result_1.Result.fail(`Failed to get property suggestions: ${error}`);
            }
        });
    }
    findClassSuggestions(context) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                if (this.shouldRefreshCache()) {
                    this.refreshClassCache();
                }
                const cachedSuggestions = this.classCache.get(context.getCurrentToken());
                if (cachedSuggestions) {
                    return Result_1.Result.ok(cachedSuggestions);
                }
                const classes = this.extractClassesFromGraph();
                const suggestions = classes.map(cls => this.createClassSuggestion(cls, context));
                this.classCache.set(context.getCurrentToken(), suggestions);
                return Result_1.Result.ok(suggestions);
            }
            catch (error) {
                return Result_1.Result.fail(`Failed to get class suggestions: ${error}`);
            }
        });
    }
    findVariableSuggestions(context) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const suggestions = [];
                const existingVariables = context.getVariablesInScope();
                const currentToken = context.getCurrentToken();
                // Suggest reuse of existing variables
                for (const variable of existingVariables) {
                    const varName = `?${variable}`;
                    if (!currentToken || varName.startsWith(currentToken)) {
                        suggestions.push(SPARQLSuggestion_1.SPARQLSuggestion.create({
                            id: `var_existing_${variable}`,
                            text: varName,
                            insertText: varName,
                            type: SPARQLSuggestion_1.SuggestionType.VARIABLE,
                            confidence: 0.9,
                            contextualScore: 0.95,
                            metadata: {
                                description: 'Existing variable in query',
                                usage: 'Reuse this variable to join patterns'
                            }
                        }));
                    }
                }
                // Suggest common variable names
                const commonVariables = [
                    { name: 'subject', desc: 'Subject of a triple' },
                    { name: 'predicate', desc: 'Predicate/property' },
                    { name: 'object', desc: 'Object value' },
                    { name: 'type', desc: 'RDF type/class' },
                    { name: 'label', desc: 'Human-readable label' },
                    { name: 'value', desc: 'Generic value' },
                    { name: 'name', desc: 'Name property' },
                    { name: 'id', desc: 'Identifier' },
                    { name: 'date', desc: 'Date/time value' },
                    { name: 'count', desc: 'Count aggregate' }
                ];
                for (const { name, desc } of commonVariables) {
                    const varName = `?${name}`;
                    if (!existingVariables.includes(name) && (!currentToken || varName.startsWith(currentToken))) {
                        suggestions.push(SPARQLSuggestion_1.SPARQLSuggestion.create({
                            id: `var_common_${name}`,
                            text: varName,
                            insertText: varName,
                            type: SPARQLSuggestion_1.SuggestionType.VARIABLE,
                            confidence: 0.7,
                            contextualScore: 0.6,
                            metadata: {
                                description: desc,
                                usage: `Common variable name for ${desc.toLowerCase()}`
                            }
                        }));
                    }
                }
                return Result_1.Result.ok(suggestions);
            }
            catch (error) {
                return Result_1.Result.fail(`Failed to get variable suggestions: ${error}`);
            }
        });
    }
    findNamespaceSuggestions(context) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const namespaces = [
                    { prefix: 'rdf:', uri: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#' },
                    { prefix: 'rdfs:', uri: 'http://www.w3.org/2000/01/rdf-schema#' },
                    { prefix: 'owl:', uri: 'http://www.w3.org/2002/07/owl#' },
                    { prefix: 'xsd:', uri: 'http://www.w3.org/2001/XMLSchema#' },
                    { prefix: 'skos:', uri: 'http://www.w3.org/2004/02/skos/core#' },
                    { prefix: 'foaf:', uri: 'http://xmlns.com/foaf/0.1/' },
                    { prefix: 'dc:', uri: 'http://purl.org/dc/elements/1.1/' },
                    { prefix: 'exo:', uri: 'http://example.org/exocortex#' }
                ];
                const suggestions = namespaces
                    .filter(ns => !context.getCurrentToken() || ns.prefix.startsWith(context.getCurrentToken()))
                    .map(ns => SPARQLSuggestion_1.SPARQLSuggestion.create({
                    id: `namespace_${ns.prefix}`,
                    text: ns.prefix,
                    insertText: `PREFIX ${ns.prefix} <${ns.uri}>`,
                    type: SPARQLSuggestion_1.SuggestionType.NAMESPACE,
                    confidence: 0.85,
                    contextualScore: 0.8,
                    metadata: {
                        description: `Namespace: ${ns.uri}`,
                        namespace: ns.uri
                    }
                }));
                return Result_1.Result.ok(suggestions);
            }
            catch (error) {
                return Result_1.Result.fail(`Failed to get namespace suggestions: ${error}`);
            }
        });
    }
    findFunctionSuggestions(context) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const functions = [
                    { name: 'STR', desc: 'Convert to string', example: 'STR(?value)' },
                    { name: 'LANG', desc: 'Get language tag', example: 'LANG(?label)' },
                    { name: 'DATATYPE', desc: 'Get datatype IRI', example: 'DATATYPE(?literal)' },
                    { name: 'BOUND', desc: 'Test if variable is bound', example: 'BOUND(?var)' },
                    { name: 'REGEX', desc: 'Regular expression match', example: 'REGEX(?text, "pattern")' },
                    { name: 'CONTAINS', desc: 'String contains', example: 'CONTAINS(?str, "substring")' },
                    { name: 'STRSTARTS', desc: 'String starts with', example: 'STRSTARTS(?str, "prefix")' },
                    { name: 'STRENDS', desc: 'String ends with', example: 'STRENDS(?str, "suffix")' },
                    { name: 'STRLEN', desc: 'String length', example: 'STRLEN(?str)' },
                    { name: 'SUBSTR', desc: 'Substring', example: 'SUBSTR(?str, 1, 10)' },
                    { name: 'UCASE', desc: 'Convert to uppercase', example: 'UCASE(?str)' },
                    { name: 'LCASE', desc: 'Convert to lowercase', example: 'LCASE(?str)' },
                    { name: 'COUNT', desc: 'Count aggregate', example: 'COUNT(?item)' },
                    { name: 'SUM', desc: 'Sum aggregate', example: 'SUM(?value)' },
                    { name: 'AVG', desc: 'Average aggregate', example: 'AVG(?value)' },
                    { name: 'MIN', desc: 'Minimum value', example: 'MIN(?value)' },
                    { name: 'MAX', desc: 'Maximum value', example: 'MAX(?value)' },
                    { name: 'NOW', desc: 'Current date/time', example: 'NOW()' },
                    { name: 'YEAR', desc: 'Extract year', example: 'YEAR(?date)' },
                    { name: 'MONTH', desc: 'Extract month', example: 'MONTH(?date)' }
                ];
                const currentToken = context.getCurrentToken().toUpperCase();
                const suggestions = functions
                    .filter(fn => !currentToken || fn.name.startsWith(currentToken))
                    .map(fn => SPARQLSuggestion_1.SPARQLSuggestion.create({
                    id: `function_${fn.name.toLowerCase()}`,
                    text: fn.name,
                    insertText: fn.name + '(',
                    type: SPARQLSuggestion_1.SuggestionType.FUNCTION,
                    confidence: 0.8,
                    contextualScore: context.isInClause(QueryContext_1.ClauseType.FILTER) ? 0.9 : 0.6,
                    metadata: {
                        description: fn.desc,
                        examples: [fn.example]
                    }
                }));
                return Result_1.Result.ok(suggestions);
            }
            catch (error) {
                return Result_1.Result.fail(`Failed to get function suggestions: ${error}`);
            }
        });
    }
    findTemplateSuggestions(context) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const templates = [
                    {
                        name: 'Basic SELECT Query',
                        template: 'SELECT ?subject ?predicate ?object\nWHERE {\n  ?subject ?predicate ?object .\n}\nLIMIT 100',
                        description: 'Simple triple pattern query'
                    },
                    {
                        name: 'Find All Classes',
                        template: 'SELECT DISTINCT ?class\nWHERE {\n  ?instance rdf:type ?class .\n}\nORDER BY ?class',
                        description: 'List all classes in the graph'
                    },
                    {
                        name: 'Find All Properties',
                        template: 'SELECT DISTINCT ?property\nWHERE {\n  ?subject ?property ?object .\n}\nORDER BY ?property',
                        description: 'List all properties used in the graph'
                    },
                    {
                        name: 'Get Class Instances',
                        template: 'SELECT ?instance ?label\nWHERE {\n  ?instance rdf:type <ClassURI> .\n  OPTIONAL { ?instance rdfs:label ?label }\n}',
                        description: 'Find all instances of a specific class'
                    },
                    {
                        name: 'Count by Type',
                        template: 'SELECT ?type (COUNT(?instance) AS ?count)\nWHERE {\n  ?instance rdf:type ?type .\n}\nGROUP BY ?type\nORDER BY DESC(?count)',
                        description: 'Count instances per class'
                    },
                    {
                        name: 'Search by Label',
                        template: 'SELECT ?resource ?label\nWHERE {\n  ?resource rdfs:label ?label .\n  FILTER(CONTAINS(LCASE(?label), "search term"))\n}',
                        description: 'Find resources by label text'
                    }
                ];
                const suggestions = templates.map((template, index) => SPARQLSuggestion_1.SPARQLSuggestion.create({
                    id: `template_${index}`,
                    text: template.name,
                    insertText: template.template,
                    type: SPARQLSuggestion_1.SuggestionType.TEMPLATE,
                    confidence: 0.75,
                    contextualScore: context.isStartOfQuery() ? 0.9 : 0.3,
                    metadata: {
                        description: template.description,
                        documentation: 'Query template - customize as needed'
                    }
                }));
                return Result_1.Result.ok(suggestions);
            }
            catch (error) {
                return Result_1.Result.fail(`Failed to get template suggestions: ${error}`);
            }
        });
    }
    updateUsageStatistics(suggestionId, selected) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                if (!this.usageStats[suggestionId]) {
                    this.usageStats[suggestionId] = { count: 0, lastUsed: 0 };
                }
                if (selected) {
                    this.usageStats[suggestionId].count++;
                    this.usageStats[suggestionId].lastUsed = Date.now();
                }
                return Result_1.Result.ok();
            }
            catch (error) {
                return Result_1.Result.fail(`Failed to update usage statistics: ${error}`);
            }
        });
    }
    getPopularSuggestions(limit) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const sortedIds = Object.entries(this.usageStats)
                    .sort((a, b) => b[1].count - a[1].count)
                    .slice(0, limit)
                    .map(([id]) => id);
                // This would need to reconstruct suggestions from IDs
                // For now, return empty array
                return Result_1.Result.ok([]);
            }
            catch (error) {
                return Result_1.Result.fail(`Failed to get popular suggestions: ${error}`);
            }
        });
    }
    extractPropertiesFromGraph() {
        const properties = new Map();
        try {
            // Use match with undefined to get all triples
            const triples = this.graph.match(undefined, undefined, undefined);
            for (const triple of triples) {
                const predicate = triple.getPredicate().toString();
                properties.set(predicate, (properties.get(predicate) || 0) + 1);
            }
        }
        catch (error) {
            console.warn('Failed to extract properties from graph:', error);
        }
        return Array.from(properties.entries())
            .map(([uri, frequency]) => ({ uri, frequency }))
            .sort((a, b) => b.frequency - a.frequency);
    }
    extractClassesFromGraph() {
        const classes = new Map();
        const rdfType = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type';
        try {
            // Use match with undefined to get all triples
            const triples = this.graph.match(undefined, undefined, undefined);
            for (const triple of triples) {
                if (triple.getPredicate().toString() === rdfType) {
                    const classUri = triple.getObject().toString();
                    classes.set(classUri, (classes.get(classUri) || 0) + 1);
                }
            }
        }
        catch (error) {
            console.warn('Failed to extract classes from graph:', error);
        }
        return Array.from(classes.entries())
            .map(([uri, instanceCount]) => ({ uri, instanceCount }))
            .sort((a, b) => b.instanceCount - a.instanceCount);
    }
    createPropertySuggestion(property, context) {
        const shortName = this.getShortName(property.uri);
        const confidence = Math.min(0.9, 0.5 + (property.frequency / 100));
        return SPARQLSuggestion_1.SPARQLSuggestion.create({
            id: `property_${property.uri}`,
            text: shortName,
            insertText: shortName,
            type: SPARQLSuggestion_1.SuggestionType.PROPERTY,
            confidence,
            contextualScore: context.isInClause(QueryContext_1.ClauseType.WHERE) ? 0.9 : 0.5,
            metadata: {
                description: `Property (used ${property.frequency} times)`,
                namespace: property.uri
            }
        });
    }
    createClassSuggestion(cls, context) {
        const shortName = this.getShortName(cls.uri);
        const confidence = Math.min(0.9, 0.5 + (cls.instanceCount / 50));
        return SPARQLSuggestion_1.SPARQLSuggestion.create({
            id: `class_${cls.uri}`,
            text: shortName,
            insertText: shortName,
            type: SPARQLSuggestion_1.SuggestionType.CLASS,
            confidence,
            contextualScore: this.isAfterRdfType(context) ? 0.95 : 0.6,
            metadata: {
                description: `Class (${cls.instanceCount} instances)`,
                namespace: cls.uri
            }
        });
    }
    getShortName(uri) {
        const hashIndex = uri.lastIndexOf('#');
        const slashIndex = uri.lastIndexOf('/');
        const splitIndex = Math.max(hashIndex, slashIndex);
        if (splitIndex > 0 && splitIndex < uri.length - 1) {
            return uri.substring(splitIndex + 1);
        }
        return uri;
    }
    isAfterRdfType(context) {
        const previousTokens = context.getPreviousTokens();
        if (previousTokens.length < 2)
            return false;
        const lastTwo = previousTokens.slice(-2).join(' ').toLowerCase();
        return lastTwo.includes('rdf:type') || lastTwo.includes(' a ');
    }
    shouldRefreshCache() {
        return Date.now() - this.cacheTimestamp > this.cacheTTL;
    }
    refreshPropertyCache() {
        this.propertyCache.clear();
        this.cacheTimestamp = Date.now();
    }
    refreshClassCache() {
        this.classCache.clear();
        this.cacheTimestamp = Date.now();
    }
}
exports.GraphSuggestionRepository = GraphSuggestionRepository;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2tpdGVsZXYvRG9jdW1lbnRzL2V4b2NvcnRleC1vYnNpZGlhbi1wbHVnaW4vc3JjL2luZnJhc3RydWN0dXJlL3JlcG9zaXRvcmllcy9HcmFwaFN1Z2dlc3Rpb25SZXBvc2l0b3J5LnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFDQSxpRkFBOEY7QUFDOUYseUVBQWtGO0FBQ2xGLHFEQUFrRDtBQUVsRCx5RkFBc0Y7QUFTdEYsTUFBYSx5QkFBeUI7SUFRbEMsWUFBNkIsS0FBWTtRQUFaLFVBQUssR0FBTCxLQUFLLENBQU87UUFQakMsb0JBQWUsR0FBRyxJQUFJLHFEQUF5QixFQUFFLENBQUM7UUFDbEQsZUFBVSxHQUFlLEVBQUUsQ0FBQztRQUM1QixrQkFBYSxHQUFvQyxJQUFJLEdBQUcsRUFBRSxDQUFDO1FBQzNELGVBQVUsR0FBb0MsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUN4RCxtQkFBYyxHQUFHLENBQUMsQ0FBQztRQUNWLGFBQVEsR0FBRyxLQUFLLENBQUMsQ0FBQyxXQUFXO0lBRUYsQ0FBQztJQUV2QyxzQkFBc0IsQ0FBQyxPQUFxQjs7WUFDOUMsSUFBSTtnQkFDQSxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDakUsT0FBTyxlQUFNLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2FBQ2pDO1lBQUMsT0FBTyxLQUFLLEVBQUU7Z0JBQ1osT0FBTyxlQUFNLENBQUMsSUFBSSxDQUFDLHNDQUFzQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO2FBQ3JFO1FBQ0wsQ0FBQztLQUFBO0lBRUssdUJBQXVCLENBQUMsT0FBcUI7O1lBQy9DLElBQUk7Z0JBQ0EsSUFBSSxJQUFJLENBQUMsa0JBQWtCLEVBQUUsRUFBRTtvQkFDM0IsSUFBSSxDQUFDLG9CQUFvQixFQUFFLENBQUM7aUJBQy9CO2dCQUVELE1BQU0saUJBQWlCLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUM7Z0JBQzVFLElBQUksaUJBQWlCLEVBQUU7b0JBQ25CLE9BQU8sZUFBTSxDQUFDLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO2lCQUN2QztnQkFFRCxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsMEJBQTBCLEVBQUUsQ0FBQztnQkFDckQsTUFBTSxXQUFXLEdBQUcsVUFBVSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQztnQkFFekYsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLGVBQWUsRUFBRSxFQUFFLFdBQVcsQ0FBQyxDQUFDO2dCQUMvRCxPQUFPLGVBQU0sQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUM7YUFDakM7WUFBQyxPQUFPLEtBQUssRUFBRTtnQkFDWixPQUFPLGVBQU0sQ0FBQyxJQUFJLENBQUMsdUNBQXVDLEtBQUssRUFBRSxDQUFDLENBQUM7YUFDdEU7UUFDTCxDQUFDO0tBQUE7SUFFSyxvQkFBb0IsQ0FBQyxPQUFxQjs7WUFDNUMsSUFBSTtnQkFDQSxJQUFJLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxFQUFFO29CQUMzQixJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztpQkFDNUI7Z0JBRUQsTUFBTSxpQkFBaUIsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsZUFBZSxFQUFFLENBQUMsQ0FBQztnQkFDekUsSUFBSSxpQkFBaUIsRUFBRTtvQkFDbkIsT0FBTyxlQUFNLENBQUMsRUFBRSxDQUFDLGlCQUFpQixDQUFDLENBQUM7aUJBQ3ZDO2dCQUVELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyx1QkFBdUIsRUFBRSxDQUFDO2dCQUMvQyxNQUFNLFdBQVcsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLEdBQUcsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO2dCQUVqRixJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsZUFBZSxFQUFFLEVBQUUsV0FBVyxDQUFDLENBQUM7Z0JBQzVELE9BQU8sZUFBTSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsQ0FBQzthQUNqQztZQUFDLE9BQU8sS0FBSyxFQUFFO2dCQUNaLE9BQU8sZUFBTSxDQUFDLElBQUksQ0FBQyxvQ0FBb0MsS0FBSyxFQUFFLENBQUMsQ0FBQzthQUNuRTtRQUNMLENBQUM7S0FBQTtJQUVLLHVCQUF1QixDQUFDLE9BQXFCOztZQUMvQyxJQUFJO2dCQUNBLE1BQU0sV0FBVyxHQUF1QixFQUFFLENBQUM7Z0JBQzNDLE1BQU0saUJBQWlCLEdBQUcsT0FBTyxDQUFDLG1CQUFtQixFQUFFLENBQUM7Z0JBQ3hELE1BQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxlQUFlLEVBQUUsQ0FBQztnQkFFL0Msc0NBQXNDO2dCQUN0QyxLQUFLLE1BQU0sUUFBUSxJQUFJLGlCQUFpQixFQUFFO29CQUN0QyxNQUFNLE9BQU8sR0FBRyxJQUFJLFFBQVEsRUFBRSxDQUFDO29CQUMvQixJQUFJLENBQUMsWUFBWSxJQUFJLE9BQU8sQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLEVBQUU7d0JBQ25ELFdBQVcsQ0FBQyxJQUFJLENBQUMsbUNBQWdCLENBQUMsTUFBTSxDQUFDOzRCQUNyQyxFQUFFLEVBQUUsZ0JBQWdCLFFBQVEsRUFBRTs0QkFDOUIsSUFBSSxFQUFFLE9BQU87NEJBQ2IsVUFBVSxFQUFFLE9BQU87NEJBQ25CLElBQUksRUFBRSxpQ0FBYyxDQUFDLFFBQVE7NEJBQzdCLFVBQVUsRUFBRSxHQUFHOzRCQUNmLGVBQWUsRUFBRSxJQUFJOzRCQUNyQixRQUFRLEVBQUU7Z0NBQ04sV0FBVyxFQUFFLDRCQUE0QjtnQ0FDekMsS0FBSyxFQUFFLHNDQUFzQzs2QkFDaEQ7eUJBQ0osQ0FBQyxDQUFDLENBQUM7cUJBQ1A7aUJBQ0o7Z0JBRUQsZ0NBQWdDO2dCQUNoQyxNQUFNLGVBQWUsR0FBRztvQkFDcEIsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxxQkFBcUIsRUFBRTtvQkFDaEQsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRSxvQkFBb0IsRUFBRTtvQkFDakQsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxjQUFjLEVBQUU7b0JBQ3hDLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsZ0JBQWdCLEVBQUU7b0JBQ3hDLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsc0JBQXNCLEVBQUU7b0JBQy9DLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsZUFBZSxFQUFFO29CQUN4QyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLGVBQWUsRUFBRTtvQkFDdkMsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxZQUFZLEVBQUU7b0JBQ2xDLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsaUJBQWlCLEVBQUU7b0JBQ3pDLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsaUJBQWlCLEVBQUU7aUJBQzdDLENBQUM7Z0JBRUYsS0FBSyxNQUFNLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLGVBQWUsRUFBRTtvQkFDMUMsTUFBTSxPQUFPLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQztvQkFDM0IsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsWUFBWSxJQUFJLE9BQU8sQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLENBQUMsRUFBRTt3QkFDMUYsV0FBVyxDQUFDLElBQUksQ0FBQyxtQ0FBZ0IsQ0FBQyxNQUFNLENBQUM7NEJBQ3JDLEVBQUUsRUFBRSxjQUFjLElBQUksRUFBRTs0QkFDeEIsSUFBSSxFQUFFLE9BQU87NEJBQ2IsVUFBVSxFQUFFLE9BQU87NEJBQ25CLElBQUksRUFBRSxpQ0FBYyxDQUFDLFFBQVE7NEJBQzdCLFVBQVUsRUFBRSxHQUFHOzRCQUNmLGVBQWUsRUFBRSxHQUFHOzRCQUNwQixRQUFRLEVBQUU7Z0NBQ04sV0FBVyxFQUFFLElBQUk7Z0NBQ2pCLEtBQUssRUFBRSw0QkFBNEIsSUFBSSxDQUFDLFdBQVcsRUFBRSxFQUFFOzZCQUMxRDt5QkFDSixDQUFDLENBQUMsQ0FBQztxQkFDUDtpQkFDSjtnQkFFRCxPQUFPLGVBQU0sQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUM7YUFDakM7WUFBQyxPQUFPLEtBQUssRUFBRTtnQkFDWixPQUFPLGVBQU0sQ0FBQyxJQUFJLENBQUMsdUNBQXVDLEtBQUssRUFBRSxDQUFDLENBQUM7YUFDdEU7UUFDTCxDQUFDO0tBQUE7SUFFSyx3QkFBd0IsQ0FBQyxPQUFxQjs7WUFDaEQsSUFBSTtnQkFDQSxNQUFNLFVBQVUsR0FBRztvQkFDZixFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLDZDQUE2QyxFQUFFO29CQUN0RSxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsR0FBRyxFQUFFLHVDQUF1QyxFQUFFO29CQUNqRSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLGdDQUFnQyxFQUFFO29CQUN6RCxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLG1DQUFtQyxFQUFFO29CQUM1RCxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsR0FBRyxFQUFFLHNDQUFzQyxFQUFFO29CQUNoRSxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsR0FBRyxFQUFFLDRCQUE0QixFQUFFO29CQUN0RCxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLGtDQUFrQyxFQUFFO29CQUMxRCxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLCtCQUErQixFQUFFO2lCQUMzRCxDQUFDO2dCQUVGLE1BQU0sV0FBVyxHQUFHLFVBQVU7cUJBQ3pCLE1BQU0sQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLGVBQWUsRUFBRSxJQUFJLEVBQUUsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUFDO3FCQUMzRixHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxtQ0FBZ0IsQ0FBQyxNQUFNLENBQUM7b0JBQy9CLEVBQUUsRUFBRSxhQUFhLEVBQUUsQ0FBQyxNQUFNLEVBQUU7b0JBQzVCLElBQUksRUFBRSxFQUFFLENBQUMsTUFBTTtvQkFDZixVQUFVLEVBQUUsVUFBVSxFQUFFLENBQUMsTUFBTSxLQUFLLEVBQUUsQ0FBQyxHQUFHLEdBQUc7b0JBQzdDLElBQUksRUFBRSxpQ0FBYyxDQUFDLFNBQVM7b0JBQzlCLFVBQVUsRUFBRSxJQUFJO29CQUNoQixlQUFlLEVBQUUsR0FBRztvQkFDcEIsUUFBUSxFQUFFO3dCQUNOLFdBQVcsRUFBRSxjQUFjLEVBQUUsQ0FBQyxHQUFHLEVBQUU7d0JBQ25DLFNBQVMsRUFBRSxFQUFFLENBQUMsR0FBRztxQkFDcEI7aUJBQ0osQ0FBQyxDQUFDLENBQUM7Z0JBRVIsT0FBTyxlQUFNLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2FBQ2pDO1lBQUMsT0FBTyxLQUFLLEVBQUU7Z0JBQ1osT0FBTyxlQUFNLENBQUMsSUFBSSxDQUFDLHdDQUF3QyxLQUFLLEVBQUUsQ0FBQyxDQUFDO2FBQ3ZFO1FBQ0wsQ0FBQztLQUFBO0lBRUssdUJBQXVCLENBQUMsT0FBcUI7O1lBQy9DLElBQUk7Z0JBQ0EsTUFBTSxTQUFTLEdBQUc7b0JBQ2QsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxtQkFBbUIsRUFBRSxPQUFPLEVBQUUsYUFBYSxFQUFFO29CQUNsRSxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLGtCQUFrQixFQUFFLE9BQU8sRUFBRSxjQUFjLEVBQUU7b0JBQ25FLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsa0JBQWtCLEVBQUUsT0FBTyxFQUFFLG9CQUFvQixFQUFFO29CQUM3RSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLDJCQUEyQixFQUFFLE9BQU8sRUFBRSxhQUFhLEVBQUU7b0JBQzVFLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsMEJBQTBCLEVBQUUsT0FBTyxFQUFFLHlCQUF5QixFQUFFO29CQUN2RixFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsSUFBSSxFQUFFLGlCQUFpQixFQUFFLE9BQU8sRUFBRSw2QkFBNkIsRUFBRTtvQkFDckYsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRSxvQkFBb0IsRUFBRSxPQUFPLEVBQUUsMkJBQTJCLEVBQUU7b0JBQ3ZGLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsa0JBQWtCLEVBQUUsT0FBTyxFQUFFLHlCQUF5QixFQUFFO29CQUNqRixFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLGVBQWUsRUFBRSxPQUFPLEVBQUUsY0FBYyxFQUFFO29CQUNsRSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxPQUFPLEVBQUUscUJBQXFCLEVBQUU7b0JBQ3JFLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsc0JBQXNCLEVBQUUsT0FBTyxFQUFFLGFBQWEsRUFBRTtvQkFDdkUsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxzQkFBc0IsRUFBRSxPQUFPLEVBQUUsYUFBYSxFQUFFO29CQUN2RSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLGlCQUFpQixFQUFFLE9BQU8sRUFBRSxjQUFjLEVBQUU7b0JBQ25FLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsZUFBZSxFQUFFLE9BQU8sRUFBRSxhQUFhLEVBQUU7b0JBQzlELEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsbUJBQW1CLEVBQUUsT0FBTyxFQUFFLGFBQWEsRUFBRTtvQkFDbEUsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxlQUFlLEVBQUUsT0FBTyxFQUFFLGFBQWEsRUFBRTtvQkFDOUQsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxlQUFlLEVBQUUsT0FBTyxFQUFFLGFBQWEsRUFBRTtvQkFDOUQsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxtQkFBbUIsRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFO29CQUM1RCxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLGNBQWMsRUFBRSxPQUFPLEVBQUUsYUFBYSxFQUFFO29CQUM5RCxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLGVBQWUsRUFBRSxPQUFPLEVBQUUsY0FBYyxFQUFFO2lCQUNwRSxDQUFDO2dCQUVGLE1BQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxlQUFlLEVBQUUsQ0FBQyxXQUFXLEVBQUUsQ0FBQztnQkFDN0QsTUFBTSxXQUFXLEdBQUcsU0FBUztxQkFDeEIsTUFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxZQUFZLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLENBQUM7cUJBQy9ELEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLG1DQUFnQixDQUFDLE1BQU0sQ0FBQztvQkFDL0IsRUFBRSxFQUFFLFlBQVksRUFBRSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsRUFBRTtvQkFDdkMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJO29CQUNiLFVBQVUsRUFBRSxFQUFFLENBQUMsSUFBSSxHQUFHLEdBQUc7b0JBQ3pCLElBQUksRUFBRSxpQ0FBYyxDQUFDLFFBQVE7b0JBQzdCLFVBQVUsRUFBRSxHQUFHO29CQUNmLGVBQWUsRUFBRSxPQUFPLENBQUMsVUFBVSxDQUFDLHlCQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRztvQkFDbEUsUUFBUSxFQUFFO3dCQUNOLFdBQVcsRUFBRSxFQUFFLENBQUMsSUFBSTt3QkFDcEIsUUFBUSxFQUFFLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQztxQkFDekI7aUJBQ0osQ0FBQyxDQUFDLENBQUM7Z0JBRVIsT0FBTyxlQUFNLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2FBQ2pDO1lBQUMsT0FBTyxLQUFLLEVBQUU7Z0JBQ1osT0FBTyxlQUFNLENBQUMsSUFBSSxDQUFDLHVDQUF1QyxLQUFLLEVBQUUsQ0FBQyxDQUFDO2FBQ3RFO1FBQ0wsQ0FBQztLQUFBO0lBRUssdUJBQXVCLENBQUMsT0FBcUI7O1lBQy9DLElBQUk7Z0JBQ0EsTUFBTSxTQUFTLEdBQUc7b0JBQ2Q7d0JBQ0ksSUFBSSxFQUFFLG9CQUFvQjt3QkFDMUIsUUFBUSxFQUFFLDRGQUE0Rjt3QkFDdEcsV0FBVyxFQUFFLDZCQUE2QjtxQkFDN0M7b0JBQ0Q7d0JBQ0ksSUFBSSxFQUFFLGtCQUFrQjt3QkFDeEIsUUFBUSxFQUFFLG9GQUFvRjt3QkFDOUYsV0FBVyxFQUFFLCtCQUErQjtxQkFDL0M7b0JBQ0Q7d0JBQ0ksSUFBSSxFQUFFLHFCQUFxQjt3QkFDM0IsUUFBUSxFQUFFLDJGQUEyRjt3QkFDckcsV0FBVyxFQUFFLHVDQUF1QztxQkFDdkQ7b0JBQ0Q7d0JBQ0ksSUFBSSxFQUFFLHFCQUFxQjt3QkFDM0IsUUFBUSxFQUFFLG9IQUFvSDt3QkFDOUgsV0FBVyxFQUFFLHdDQUF3QztxQkFDeEQ7b0JBQ0Q7d0JBQ0ksSUFBSSxFQUFFLGVBQWU7d0JBQ3JCLFFBQVEsRUFBRSw0SEFBNEg7d0JBQ3RJLFdBQVcsRUFBRSwyQkFBMkI7cUJBQzNDO29CQUNEO3dCQUNJLElBQUksRUFBRSxpQkFBaUI7d0JBQ3ZCLFFBQVEsRUFBRSx3SEFBd0g7d0JBQ2xJLFdBQVcsRUFBRSw4QkFBOEI7cUJBQzlDO2lCQUNKLENBQUM7Z0JBRUYsTUFBTSxXQUFXLEdBQUcsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFFBQVEsRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUNsRCxtQ0FBZ0IsQ0FBQyxNQUFNLENBQUM7b0JBQ3BCLEVBQUUsRUFBRSxZQUFZLEtBQUssRUFBRTtvQkFDdkIsSUFBSSxFQUFFLFFBQVEsQ0FBQyxJQUFJO29CQUNuQixVQUFVLEVBQUUsUUFBUSxDQUFDLFFBQVE7b0JBQzdCLElBQUksRUFBRSxpQ0FBYyxDQUFDLFFBQVE7b0JBQzdCLFVBQVUsRUFBRSxJQUFJO29CQUNoQixlQUFlLEVBQUUsT0FBTyxDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUc7b0JBQ3JELFFBQVEsRUFBRTt3QkFDTixXQUFXLEVBQUUsUUFBUSxDQUFDLFdBQVc7d0JBQ2pDLGFBQWEsRUFBRSxzQ0FBc0M7cUJBQ3hEO2lCQUNKLENBQUMsQ0FDTCxDQUFDO2dCQUVGLE9BQU8sZUFBTSxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsQ0FBQzthQUNqQztZQUFDLE9BQU8sS0FBSyxFQUFFO2dCQUNaLE9BQU8sZUFBTSxDQUFDLElBQUksQ0FBQyx1Q0FBdUMsS0FBSyxFQUFFLENBQUMsQ0FBQzthQUN0RTtRQUNMLENBQUM7S0FBQTtJQUVLLHFCQUFxQixDQUFDLFlBQW9CLEVBQUUsUUFBaUI7O1lBQy9ELElBQUk7Z0JBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLEVBQUU7b0JBQ2hDLElBQUksQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLFFBQVEsRUFBRSxDQUFDLEVBQUUsQ0FBQztpQkFDN0Q7Z0JBRUQsSUFBSSxRQUFRLEVBQUU7b0JBQ1YsSUFBSSxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztvQkFDdEMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO2lCQUN2RDtnQkFFRCxPQUFPLGVBQU0sQ0FBQyxFQUFFLEVBQUUsQ0FBQzthQUN0QjtZQUFDLE9BQU8sS0FBSyxFQUFFO2dCQUNaLE9BQU8sZUFBTSxDQUFDLElBQUksQ0FBQyxzQ0FBc0MsS0FBSyxFQUFFLENBQUMsQ0FBQzthQUNyRTtRQUNMLENBQUM7S0FBQTtJQUVLLHFCQUFxQixDQUFDLEtBQWE7O1lBQ3JDLElBQUk7Z0JBQ0EsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO3FCQUM1QyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7cUJBQ3ZDLEtBQUssQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDO3FCQUNmLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2dCQUV2QixzREFBc0Q7Z0JBQ3RELDhCQUE4QjtnQkFDOUIsT0FBTyxlQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2FBQ3hCO1lBQUMsT0FBTyxLQUFLLEVBQUU7Z0JBQ1osT0FBTyxlQUFNLENBQUMsSUFBSSxDQUFDLHNDQUFzQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO2FBQ3JFO1FBQ0wsQ0FBQztLQUFBO0lBRU8sMEJBQTBCO1FBQzlCLE1BQU0sVUFBVSxHQUFHLElBQUksR0FBRyxFQUFrQixDQUFDO1FBRTdDLElBQUk7WUFDQSw4Q0FBOEM7WUFDOUMsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQztZQUNsRSxLQUFLLE1BQU0sTUFBTSxJQUFJLE9BQU8sRUFBRTtnQkFDMUIsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDO2dCQUNuRCxVQUFVLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7YUFDbkU7U0FDSjtRQUFDLE9BQU8sS0FBSyxFQUFFO1lBQ1osT0FBTyxDQUFDLElBQUksQ0FBQywwQ0FBMEMsRUFBRSxLQUFLLENBQUMsQ0FBQztTQUNuRTtRQUVELE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLENBQUM7YUFDbEMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsU0FBUyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLENBQUMsQ0FBQzthQUMvQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBRU8sdUJBQXVCO1FBQzNCLE1BQU0sT0FBTyxHQUFHLElBQUksR0FBRyxFQUFrQixDQUFDO1FBQzFDLE1BQU0sT0FBTyxHQUFHLGlEQUFpRCxDQUFDO1FBRWxFLElBQUk7WUFDQSw4Q0FBOEM7WUFDOUMsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQztZQUNsRSxLQUFLLE1BQU0sTUFBTSxJQUFJLE9BQU8sRUFBRTtnQkFDMUIsSUFBSSxNQUFNLENBQUMsWUFBWSxFQUFFLENBQUMsUUFBUSxFQUFFLEtBQUssT0FBTyxFQUFFO29CQUM5QyxNQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMsU0FBUyxFQUFFLENBQUMsUUFBUSxFQUFFLENBQUM7b0JBQy9DLE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztpQkFDM0Q7YUFDSjtTQUNKO1FBQUMsT0FBTyxLQUFLLEVBQUU7WUFDWixPQUFPLENBQUMsSUFBSSxDQUFDLHVDQUF1QyxFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQ2hFO1FBRUQsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQzthQUMvQixHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxhQUFhLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxhQUFhLEVBQUUsQ0FBQyxDQUFDO2FBQ3ZELElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBQzNELENBQUM7SUFFTyx3QkFBd0IsQ0FBQyxRQUE0QyxFQUFFLE9BQXFCO1FBQ2hHLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2xELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsR0FBRyxDQUFDLFFBQVEsQ0FBQyxTQUFTLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUVuRSxPQUFPLG1DQUFnQixDQUFDLE1BQU0sQ0FBQztZQUMzQixFQUFFLEVBQUUsWUFBWSxRQUFRLENBQUMsR0FBRyxFQUFFO1lBQzlCLElBQUksRUFBRSxTQUFTO1lBQ2YsVUFBVSxFQUFFLFNBQVM7WUFDckIsSUFBSSxFQUFFLGlDQUFjLENBQUMsUUFBUTtZQUM3QixVQUFVO1lBQ1YsZUFBZSxFQUFFLE9BQU8sQ0FBQyxVQUFVLENBQUMseUJBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHO1lBQ2pFLFFBQVEsRUFBRTtnQkFDTixXQUFXLEVBQUUsa0JBQWtCLFFBQVEsQ0FBQyxTQUFTLFNBQVM7Z0JBQzFELFNBQVMsRUFBRSxRQUFRLENBQUMsR0FBRzthQUMxQjtTQUNKLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFTyxxQkFBcUIsQ0FBQyxHQUEyQyxFQUFFLE9BQXFCO1FBQzVGLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzdDLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxhQUFhLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUVqRSxPQUFPLG1DQUFnQixDQUFDLE1BQU0sQ0FBQztZQUMzQixFQUFFLEVBQUUsU0FBUyxHQUFHLENBQUMsR0FBRyxFQUFFO1lBQ3RCLElBQUksRUFBRSxTQUFTO1lBQ2YsVUFBVSxFQUFFLFNBQVM7WUFDckIsSUFBSSxFQUFFLGlDQUFjLENBQUMsS0FBSztZQUMxQixVQUFVO1lBQ1YsZUFBZSxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRztZQUMxRCxRQUFRLEVBQUU7Z0JBQ04sV0FBVyxFQUFFLFVBQVUsR0FBRyxDQUFDLGFBQWEsYUFBYTtnQkFDckQsU0FBUyxFQUFFLEdBQUcsQ0FBQyxHQUFHO2FBQ3JCO1NBQ0osQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVPLFlBQVksQ0FBQyxHQUFXO1FBQzVCLE1BQU0sU0FBUyxHQUFHLEdBQUcsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDdkMsTUFBTSxVQUFVLEdBQUcsR0FBRyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN4QyxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxVQUFVLENBQUMsQ0FBQztRQUVuRCxJQUFJLFVBQVUsR0FBRyxDQUFDLElBQUksVUFBVSxHQUFHLEdBQUcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQy9DLE9BQU8sR0FBRyxDQUFDLFNBQVMsQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDLENBQUM7U0FDeEM7UUFFRCxPQUFPLEdBQUcsQ0FBQztJQUNmLENBQUM7SUFFTyxjQUFjLENBQUMsT0FBcUI7UUFDeEMsTUFBTSxjQUFjLEdBQUcsT0FBTyxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDbkQsSUFBSSxjQUFjLENBQUMsTUFBTSxHQUFHLENBQUM7WUFBRSxPQUFPLEtBQUssQ0FBQztRQUU1QyxNQUFNLE9BQU8sR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ2pFLE9BQU8sT0FBTyxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsSUFBSSxPQUFPLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ25FLENBQUM7SUFFTyxrQkFBa0I7UUFDdEIsT0FBTyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQzVELENBQUM7SUFFTyxvQkFBb0I7UUFDeEIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUMzQixJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUNyQyxDQUFDO0lBRU8saUJBQWlCO1FBQ3JCLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDeEIsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDckMsQ0FBQztDQUNKO0FBblpELDhEQW1aQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMva2l0ZWxldi9Eb2N1bWVudHMvZXhvY29ydGV4LW9ic2lkaWFuLXBsdWdpbi9zcmMvaW5mcmFzdHJ1Y3R1cmUvcmVwb3NpdG9yaWVzL0dyYXBoU3VnZ2VzdGlvblJlcG9zaXRvcnkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSVN1Z2dlc3Rpb25SZXBvc2l0b3J5IH0gZnJvbSAnLi4vLi4vZG9tYWluL3JlcG9zaXRvcmllcy9JU3VnZ2VzdGlvblJlcG9zaXRvcnknO1xuaW1wb3J0IHsgU1BBUlFMU3VnZ2VzdGlvbiwgU3VnZ2VzdGlvblR5cGUgfSBmcm9tICcuLi8uLi9kb21haW4vYXV0b2NvbXBsZXRlL1NQQVJRTFN1Z2dlc3Rpb24nO1xuaW1wb3J0IHsgUXVlcnlDb250ZXh0LCBDbGF1c2VUeXBlIH0gZnJvbSAnLi4vLi4vZG9tYWluL2F1dG9jb21wbGV0ZS9RdWVyeUNvbnRleHQnO1xuaW1wb3J0IHsgUmVzdWx0IH0gZnJvbSAnLi4vLi4vZG9tYWluL2NvcmUvUmVzdWx0JztcbmltcG9ydCB7IEdyYXBoIH0gZnJvbSAnLi4vLi4vZG9tYWluL3NlbWFudGljL2NvcmUvR3JhcGgnO1xuaW1wb3J0IHsgS2V5d29yZFN1Z2dlc3Rpb25Qcm92aWRlciB9IGZyb20gJy4uL2F1dG9jb21wbGV0ZS9LZXl3b3JkU3VnZ2VzdGlvblByb3ZpZGVyJztcblxuaW50ZXJmYWNlIFVzYWdlU3RhdHMge1xuICAgIFtrZXk6IHN0cmluZ106IHtcbiAgICAgICAgY291bnQ6IG51bWJlcjtcbiAgICAgICAgbGFzdFVzZWQ6IG51bWJlcjtcbiAgICB9O1xufVxuXG5leHBvcnQgY2xhc3MgR3JhcGhTdWdnZXN0aW9uUmVwb3NpdG9yeSBpbXBsZW1lbnRzIElTdWdnZXN0aW9uUmVwb3NpdG9yeSB7XG4gICAgcHJpdmF0ZSBrZXl3b3JkUHJvdmlkZXIgPSBuZXcgS2V5d29yZFN1Z2dlc3Rpb25Qcm92aWRlcigpO1xuICAgIHByaXZhdGUgdXNhZ2VTdGF0czogVXNhZ2VTdGF0cyA9IHt9O1xuICAgIHByaXZhdGUgcHJvcGVydHlDYWNoZTogTWFwPHN0cmluZywgU1BBUlFMU3VnZ2VzdGlvbltdPiA9IG5ldyBNYXAoKTtcbiAgICBwcml2YXRlIGNsYXNzQ2FjaGU6IE1hcDxzdHJpbmcsIFNQQVJRTFN1Z2dlc3Rpb25bXT4gPSBuZXcgTWFwKCk7XG4gICAgcHJpdmF0ZSBjYWNoZVRpbWVzdGFtcCA9IDA7XG4gICAgcHJpdmF0ZSByZWFkb25seSBjYWNoZVRUTCA9IDYwMDAwOyAvLyAxIG1pbnV0ZVxuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBncmFwaDogR3JhcGgpIHt9XG5cbiAgICBhc3luYyBmaW5kS2V5d29yZFN1Z2dlc3Rpb25zKGNvbnRleHQ6IFF1ZXJ5Q29udGV4dCk6IFByb21pc2U8UmVzdWx0PFNQQVJRTFN1Z2dlc3Rpb25bXT4+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN1Z2dlc3Rpb25zID0gdGhpcy5rZXl3b3JkUHJvdmlkZXIuZ2V0U3VnZ2VzdGlvbnMoY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gUmVzdWx0Lm9rKHN1Z2dlc3Rpb25zKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBSZXN1bHQuZmFpbChgRmFpbGVkIHRvIGdldCBrZXl3b3JkIHN1Z2dlc3Rpb25zOiAke2Vycm9yfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZmluZFByb3BlcnR5U3VnZ2VzdGlvbnMoY29udGV4dDogUXVlcnlDb250ZXh0KTogUHJvbWlzZTxSZXN1bHQ8U1BBUlFMU3VnZ2VzdGlvbltdPj4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkUmVmcmVzaENhY2hlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hQcm9wZXJ0eUNhY2hlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZFN1Z2dlc3Rpb25zID0gdGhpcy5wcm9wZXJ0eUNhY2hlLmdldChjb250ZXh0LmdldEN1cnJlbnRUb2tlbigpKTtcbiAgICAgICAgICAgIGlmIChjYWNoZWRTdWdnZXN0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiBSZXN1bHQub2soY2FjaGVkU3VnZ2VzdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gdGhpcy5leHRyYWN0UHJvcGVydGllc0Zyb21HcmFwaCgpO1xuICAgICAgICAgICAgY29uc3Qgc3VnZ2VzdGlvbnMgPSBwcm9wZXJ0aWVzLm1hcChwcm9wID0+IHRoaXMuY3JlYXRlUHJvcGVydHlTdWdnZXN0aW9uKHByb3AsIGNvbnRleHQpKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eUNhY2hlLnNldChjb250ZXh0LmdldEN1cnJlbnRUb2tlbigpLCBzdWdnZXN0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gUmVzdWx0Lm9rKHN1Z2dlc3Rpb25zKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBSZXN1bHQuZmFpbChgRmFpbGVkIHRvIGdldCBwcm9wZXJ0eSBzdWdnZXN0aW9uczogJHtlcnJvcn1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZpbmRDbGFzc1N1Z2dlc3Rpb25zKGNvbnRleHQ6IFF1ZXJ5Q29udGV4dCk6IFByb21pc2U8UmVzdWx0PFNQQVJRTFN1Z2dlc3Rpb25bXT4+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFJlZnJlc2hDYWNoZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoQ2xhc3NDYWNoZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBjYWNoZWRTdWdnZXN0aW9ucyA9IHRoaXMuY2xhc3NDYWNoZS5nZXQoY29udGV4dC5nZXRDdXJyZW50VG9rZW4oKSk7XG4gICAgICAgICAgICBpZiAoY2FjaGVkU3VnZ2VzdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVzdWx0Lm9rKGNhY2hlZFN1Z2dlc3Rpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY2xhc3NlcyA9IHRoaXMuZXh0cmFjdENsYXNzZXNGcm9tR3JhcGgoKTtcbiAgICAgICAgICAgIGNvbnN0IHN1Z2dlc3Rpb25zID0gY2xhc3Nlcy5tYXAoY2xzID0+IHRoaXMuY3JlYXRlQ2xhc3NTdWdnZXN0aW9uKGNscywgY29udGV4dCkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmNsYXNzQ2FjaGUuc2V0KGNvbnRleHQuZ2V0Q3VycmVudFRva2VuKCksIHN1Z2dlc3Rpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBSZXN1bHQub2soc3VnZ2VzdGlvbnMpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIFJlc3VsdC5mYWlsKGBGYWlsZWQgdG8gZ2V0IGNsYXNzIHN1Z2dlc3Rpb25zOiAke2Vycm9yfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZmluZFZhcmlhYmxlU3VnZ2VzdGlvbnMoY29udGV4dDogUXVlcnlDb250ZXh0KTogUHJvbWlzZTxSZXN1bHQ8U1BBUlFMU3VnZ2VzdGlvbltdPj4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3VnZ2VzdGlvbnM6IFNQQVJRTFN1Z2dlc3Rpb25bXSA9IFtdO1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdWYXJpYWJsZXMgPSBjb250ZXh0LmdldFZhcmlhYmxlc0luU2NvcGUoKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUb2tlbiA9IGNvbnRleHQuZ2V0Q3VycmVudFRva2VuKCk7XG5cbiAgICAgICAgICAgIC8vIFN1Z2dlc3QgcmV1c2Ugb2YgZXhpc3RpbmcgdmFyaWFibGVzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhcmlhYmxlIG9mIGV4aXN0aW5nVmFyaWFibGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFyTmFtZSA9IGA/JHt2YXJpYWJsZX1gO1xuICAgICAgICAgICAgICAgIGlmICghY3VycmVudFRva2VuIHx8IHZhck5hbWUuc3RhcnRzV2l0aChjdXJyZW50VG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Z2dlc3Rpb25zLnB1c2goU1BBUlFMU3VnZ2VzdGlvbi5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGB2YXJfZXhpc3RpbmdfJHt2YXJpYWJsZX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdmFyTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydFRleHQ6IHZhck5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTdWdnZXN0aW9uVHlwZS5WQVJJQUJMRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZGVuY2U6IDAuOSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHR1YWxTY29yZTogMC45NSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdFeGlzdGluZyB2YXJpYWJsZSBpbiBxdWVyeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNhZ2U6ICdSZXVzZSB0aGlzIHZhcmlhYmxlIHRvIGpvaW4gcGF0dGVybnMnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN1Z2dlc3QgY29tbW9uIHZhcmlhYmxlIG5hbWVzXG4gICAgICAgICAgICBjb25zdCBjb21tb25WYXJpYWJsZXMgPSBbXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnc3ViamVjdCcsIGRlc2M6ICdTdWJqZWN0IG9mIGEgdHJpcGxlJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ3ByZWRpY2F0ZScsIGRlc2M6ICdQcmVkaWNhdGUvcHJvcGVydHknIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnb2JqZWN0JywgZGVzYzogJ09iamVjdCB2YWx1ZScgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICd0eXBlJywgZGVzYzogJ1JERiB0eXBlL2NsYXNzJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ2xhYmVsJywgZGVzYzogJ0h1bWFuLXJlYWRhYmxlIGxhYmVsJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ3ZhbHVlJywgZGVzYzogJ0dlbmVyaWMgdmFsdWUnIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnbmFtZScsIGRlc2M6ICdOYW1lIHByb3BlcnR5JyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ2lkJywgZGVzYzogJ0lkZW50aWZpZXInIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnZGF0ZScsIGRlc2M6ICdEYXRlL3RpbWUgdmFsdWUnIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnY291bnQnLCBkZXNjOiAnQ291bnQgYWdncmVnYXRlJyB9XG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgbmFtZSwgZGVzYyB9IG9mIGNvbW1vblZhcmlhYmxlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhck5hbWUgPSBgPyR7bmFtZX1gO1xuICAgICAgICAgICAgICAgIGlmICghZXhpc3RpbmdWYXJpYWJsZXMuaW5jbHVkZXMobmFtZSkgJiYgKCFjdXJyZW50VG9rZW4gfHwgdmFyTmFtZS5zdGFydHNXaXRoKGN1cnJlbnRUb2tlbikpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Z2dlc3Rpb25zLnB1c2goU1BBUlFMU3VnZ2VzdGlvbi5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGB2YXJfY29tbW9uXyR7bmFtZX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdmFyTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydFRleHQ6IHZhck5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBTdWdnZXN0aW9uVHlwZS5WQVJJQUJMRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZGVuY2U6IDAuNyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHR1YWxTY29yZTogMC42LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogZGVzYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2FnZTogYENvbW1vbiB2YXJpYWJsZSBuYW1lIGZvciAke2Rlc2MudG9Mb3dlckNhc2UoKX1gXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBSZXN1bHQub2soc3VnZ2VzdGlvbnMpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIFJlc3VsdC5mYWlsKGBGYWlsZWQgdG8gZ2V0IHZhcmlhYmxlIHN1Z2dlc3Rpb25zOiAke2Vycm9yfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZmluZE5hbWVzcGFjZVN1Z2dlc3Rpb25zKGNvbnRleHQ6IFF1ZXJ5Q29udGV4dCk6IFByb21pc2U8UmVzdWx0PFNQQVJRTFN1Z2dlc3Rpb25bXT4+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzcGFjZXMgPSBbXG4gICAgICAgICAgICAgICAgeyBwcmVmaXg6ICdyZGY6JywgdXJpOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIycgfSxcbiAgICAgICAgICAgICAgICB7IHByZWZpeDogJ3JkZnM6JywgdXJpOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC8wMS9yZGYtc2NoZW1hIycgfSxcbiAgICAgICAgICAgICAgICB7IHByZWZpeDogJ293bDonLCB1cmk6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAyLzA3L293bCMnIH0sXG4gICAgICAgICAgICAgICAgeyBwcmVmaXg6ICd4c2Q6JywgdXJpOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEjJyB9LFxuICAgICAgICAgICAgICAgIHsgcHJlZml4OiAnc2tvczonLCB1cmk6ICdodHRwOi8vd3d3LnczLm9yZy8yMDA0LzAyL3Nrb3MvY29yZSMnIH0sXG4gICAgICAgICAgICAgICAgeyBwcmVmaXg6ICdmb2FmOicsIHVyaTogJ2h0dHA6Ly94bWxucy5jb20vZm9hZi8wLjEvJyB9LFxuICAgICAgICAgICAgICAgIHsgcHJlZml4OiAnZGM6JywgdXJpOiAnaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8nIH0sXG4gICAgICAgICAgICAgICAgeyBwcmVmaXg6ICdleG86JywgdXJpOiAnaHR0cDovL2V4YW1wbGUub3JnL2V4b2NvcnRleCMnIH1cbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIGNvbnN0IHN1Z2dlc3Rpb25zID0gbmFtZXNwYWNlc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIobnMgPT4gIWNvbnRleHQuZ2V0Q3VycmVudFRva2VuKCkgfHwgbnMucHJlZml4LnN0YXJ0c1dpdGgoY29udGV4dC5nZXRDdXJyZW50VG9rZW4oKSkpXG4gICAgICAgICAgICAgICAgLm1hcChucyA9PiBTUEFSUUxTdWdnZXN0aW9uLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBgbmFtZXNwYWNlXyR7bnMucHJlZml4fWAsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IG5zLnByZWZpeCxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogYFBSRUZJWCAke25zLnByZWZpeH0gPCR7bnMudXJpfT5gLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTdWdnZXN0aW9uVHlwZS5OQU1FU1BBQ0UsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZGVuY2U6IDAuODUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHR1YWxTY29yZTogMC44LFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGBOYW1lc3BhY2U6ICR7bnMudXJpfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IG5zLnVyaVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICByZXR1cm4gUmVzdWx0Lm9rKHN1Z2dlc3Rpb25zKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBSZXN1bHQuZmFpbChgRmFpbGVkIHRvIGdldCBuYW1lc3BhY2Ugc3VnZ2VzdGlvbnM6ICR7ZXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmaW5kRnVuY3Rpb25TdWdnZXN0aW9ucyhjb250ZXh0OiBRdWVyeUNvbnRleHQpOiBQcm9taXNlPFJlc3VsdDxTUEFSUUxTdWdnZXN0aW9uW10+PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBmdW5jdGlvbnMgPSBbXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnU1RSJywgZGVzYzogJ0NvbnZlcnQgdG8gc3RyaW5nJywgZXhhbXBsZTogJ1NUUig/dmFsdWUpJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ0xBTkcnLCBkZXNjOiAnR2V0IGxhbmd1YWdlIHRhZycsIGV4YW1wbGU6ICdMQU5HKD9sYWJlbCknIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnREFUQVRZUEUnLCBkZXNjOiAnR2V0IGRhdGF0eXBlIElSSScsIGV4YW1wbGU6ICdEQVRBVFlQRSg/bGl0ZXJhbCknIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnQk9VTkQnLCBkZXNjOiAnVGVzdCBpZiB2YXJpYWJsZSBpcyBib3VuZCcsIGV4YW1wbGU6ICdCT1VORCg/dmFyKScgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdSRUdFWCcsIGRlc2M6ICdSZWd1bGFyIGV4cHJlc3Npb24gbWF0Y2gnLCBleGFtcGxlOiAnUkVHRVgoP3RleHQsIFwicGF0dGVyblwiKScgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdDT05UQUlOUycsIGRlc2M6ICdTdHJpbmcgY29udGFpbnMnLCBleGFtcGxlOiAnQ09OVEFJTlMoP3N0ciwgXCJzdWJzdHJpbmdcIiknIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnU1RSU1RBUlRTJywgZGVzYzogJ1N0cmluZyBzdGFydHMgd2l0aCcsIGV4YW1wbGU6ICdTVFJTVEFSVFMoP3N0ciwgXCJwcmVmaXhcIiknIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnU1RSRU5EUycsIGRlc2M6ICdTdHJpbmcgZW5kcyB3aXRoJywgZXhhbXBsZTogJ1NUUkVORFMoP3N0ciwgXCJzdWZmaXhcIiknIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnU1RSTEVOJywgZGVzYzogJ1N0cmluZyBsZW5ndGgnLCBleGFtcGxlOiAnU1RSTEVOKD9zdHIpJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ1NVQlNUUicsIGRlc2M6ICdTdWJzdHJpbmcnLCBleGFtcGxlOiAnU1VCU1RSKD9zdHIsIDEsIDEwKScgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdVQ0FTRScsIGRlc2M6ICdDb252ZXJ0IHRvIHVwcGVyY2FzZScsIGV4YW1wbGU6ICdVQ0FTRSg/c3RyKScgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdMQ0FTRScsIGRlc2M6ICdDb252ZXJ0IHRvIGxvd2VyY2FzZScsIGV4YW1wbGU6ICdMQ0FTRSg/c3RyKScgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdDT1VOVCcsIGRlc2M6ICdDb3VudCBhZ2dyZWdhdGUnLCBleGFtcGxlOiAnQ09VTlQoP2l0ZW0pJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ1NVTScsIGRlc2M6ICdTdW0gYWdncmVnYXRlJywgZXhhbXBsZTogJ1NVTSg/dmFsdWUpJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ0FWRycsIGRlc2M6ICdBdmVyYWdlIGFnZ3JlZ2F0ZScsIGV4YW1wbGU6ICdBVkcoP3ZhbHVlKScgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdNSU4nLCBkZXNjOiAnTWluaW11bSB2YWx1ZScsIGV4YW1wbGU6ICdNSU4oP3ZhbHVlKScgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdNQVgnLCBkZXNjOiAnTWF4aW11bSB2YWx1ZScsIGV4YW1wbGU6ICdNQVgoP3ZhbHVlKScgfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdOT1cnLCBkZXNjOiAnQ3VycmVudCBkYXRlL3RpbWUnLCBleGFtcGxlOiAnTk9XKCknIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnWUVBUicsIGRlc2M6ICdFeHRyYWN0IHllYXInLCBleGFtcGxlOiAnWUVBUig/ZGF0ZSknIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnTU9OVEgnLCBkZXNjOiAnRXh0cmFjdCBtb250aCcsIGV4YW1wbGU6ICdNT05USCg/ZGF0ZSknIH1cbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUb2tlbiA9IGNvbnRleHQuZ2V0Q3VycmVudFRva2VuKCkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IHN1Z2dlc3Rpb25zID0gZnVuY3Rpb25zXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmbiA9PiAhY3VycmVudFRva2VuIHx8IGZuLm5hbWUuc3RhcnRzV2l0aChjdXJyZW50VG9rZW4pKVxuICAgICAgICAgICAgICAgIC5tYXAoZm4gPT4gU1BBUlFMU3VnZ2VzdGlvbi5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICBpZDogYGZ1bmN0aW9uXyR7Zm4ubmFtZS50b0xvd2VyQ2FzZSgpfWAsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGZuLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGluc2VydFRleHQ6IGZuLm5hbWUgKyAnKCcsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN1Z2dlc3Rpb25UeXBlLkZVTkNUSU9OLFxuICAgICAgICAgICAgICAgICAgICBjb25maWRlbmNlOiAwLjgsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHR1YWxTY29yZTogY29udGV4dC5pc0luQ2xhdXNlKENsYXVzZVR5cGUuRklMVEVSKSA/IDAuOSA6IDAuNixcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBmbi5kZXNjLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhbXBsZXM6IFtmbi5leGFtcGxlXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICByZXR1cm4gUmVzdWx0Lm9rKHN1Z2dlc3Rpb25zKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBSZXN1bHQuZmFpbChgRmFpbGVkIHRvIGdldCBmdW5jdGlvbiBzdWdnZXN0aW9uczogJHtlcnJvcn1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZpbmRUZW1wbGF0ZVN1Z2dlc3Rpb25zKGNvbnRleHQ6IFF1ZXJ5Q29udGV4dCk6IFByb21pc2U8UmVzdWx0PFNQQVJRTFN1Z2dlc3Rpb25bXT4+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlcyA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdCYXNpYyBTRUxFQ1QgUXVlcnknLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJ1NFTEVDVCA/c3ViamVjdCA/cHJlZGljYXRlID9vYmplY3RcXG5XSEVSRSB7XFxuICA/c3ViamVjdCA/cHJlZGljYXRlID9vYmplY3QgLlxcbn1cXG5MSU1JVCAxMDAnLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1NpbXBsZSB0cmlwbGUgcGF0dGVybiBxdWVyeSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0ZpbmQgQWxsIENsYXNzZXMnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJ1NFTEVDVCBESVNUSU5DVCA/Y2xhc3NcXG5XSEVSRSB7XFxuICA/aW5zdGFuY2UgcmRmOnR5cGUgP2NsYXNzIC5cXG59XFxuT1JERVIgQlkgP2NsYXNzJyxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdMaXN0IGFsbCBjbGFzc2VzIGluIHRoZSBncmFwaCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0ZpbmQgQWxsIFByb3BlcnRpZXMnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJ1NFTEVDVCBESVNUSU5DVCA/cHJvcGVydHlcXG5XSEVSRSB7XFxuICA/c3ViamVjdCA/cHJvcGVydHkgP29iamVjdCAuXFxufVxcbk9SREVSIEJZID9wcm9wZXJ0eScsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnTGlzdCBhbGwgcHJvcGVydGllcyB1c2VkIGluIHRoZSBncmFwaCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0dldCBDbGFzcyBJbnN0YW5jZXMnLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogJ1NFTEVDVCA/aW5zdGFuY2UgP2xhYmVsXFxuV0hFUkUge1xcbiAgP2luc3RhbmNlIHJkZjp0eXBlIDxDbGFzc1VSST4gLlxcbiAgT1BUSU9OQUwgeyA/aW5zdGFuY2UgcmRmczpsYWJlbCA/bGFiZWwgfVxcbn0nLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0ZpbmQgYWxsIGluc3RhbmNlcyBvZiBhIHNwZWNpZmljIGNsYXNzJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQ291bnQgYnkgVHlwZScsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnU0VMRUNUID90eXBlIChDT1VOVCg/aW5zdGFuY2UpIEFTID9jb3VudClcXG5XSEVSRSB7XFxuICA/aW5zdGFuY2UgcmRmOnR5cGUgP3R5cGUgLlxcbn1cXG5HUk9VUCBCWSA/dHlwZVxcbk9SREVSIEJZIERFU0MoP2NvdW50KScsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQ291bnQgaW5zdGFuY2VzIHBlciBjbGFzcydcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1NlYXJjaCBieSBMYWJlbCcsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAnU0VMRUNUID9yZXNvdXJjZSA/bGFiZWxcXG5XSEVSRSB7XFxuICA/cmVzb3VyY2UgcmRmczpsYWJlbCA/bGFiZWwgLlxcbiAgRklMVEVSKENPTlRBSU5TKExDQVNFKD9sYWJlbCksIFwic2VhcmNoIHRlcm1cIikpXFxufScsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnRmluZCByZXNvdXJjZXMgYnkgbGFiZWwgdGV4dCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBjb25zdCBzdWdnZXN0aW9ucyA9IHRlbXBsYXRlcy5tYXAoKHRlbXBsYXRlLCBpbmRleCkgPT4gXG4gICAgICAgICAgICAgICAgU1BBUlFMU3VnZ2VzdGlvbi5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICBpZDogYHRlbXBsYXRlXyR7aW5kZXh9YCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdGVtcGxhdGUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogdGVtcGxhdGUudGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFN1Z2dlc3Rpb25UeXBlLlRFTVBMQVRFLFxuICAgICAgICAgICAgICAgICAgICBjb25maWRlbmNlOiAwLjc1LFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0dWFsU2NvcmU6IGNvbnRleHQuaXNTdGFydE9mUXVlcnkoKSA/IDAuOSA6IDAuMyxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0ZW1wbGF0ZS5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb246ICdRdWVyeSB0ZW1wbGF0ZSAtIGN1c3RvbWl6ZSBhcyBuZWVkZWQnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgcmV0dXJuIFJlc3VsdC5vayhzdWdnZXN0aW9ucyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVzdWx0LmZhaWwoYEZhaWxlZCB0byBnZXQgdGVtcGxhdGUgc3VnZ2VzdGlvbnM6ICR7ZXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyB1cGRhdGVVc2FnZVN0YXRpc3RpY3Moc3VnZ2VzdGlvbklkOiBzdHJpbmcsIHNlbGVjdGVkOiBib29sZWFuKTogUHJvbWlzZTxSZXN1bHQ8dm9pZD4+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghdGhpcy51c2FnZVN0YXRzW3N1Z2dlc3Rpb25JZF0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVzYWdlU3RhdHNbc3VnZ2VzdGlvbklkXSA9IHsgY291bnQ6IDAsIGxhc3RVc2VkOiAwIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXNhZ2VTdGF0c1tzdWdnZXN0aW9uSWRdLmNvdW50Kys7XG4gICAgICAgICAgICAgICAgdGhpcy51c2FnZVN0YXRzW3N1Z2dlc3Rpb25JZF0ubGFzdFVzZWQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gUmVzdWx0Lm9rKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVzdWx0LmZhaWwoYEZhaWxlZCB0byB1cGRhdGUgdXNhZ2Ugc3RhdGlzdGljczogJHtlcnJvcn1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGdldFBvcHVsYXJTdWdnZXN0aW9ucyhsaW1pdDogbnVtYmVyKTogUHJvbWlzZTxSZXN1bHQ8U1BBUlFMU3VnZ2VzdGlvbltdPj4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc29ydGVkSWRzID0gT2JqZWN0LmVudHJpZXModGhpcy51c2FnZVN0YXRzKVxuICAgICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBiWzFdLmNvdW50IC0gYVsxXS5jb3VudClcbiAgICAgICAgICAgICAgICAuc2xpY2UoMCwgbGltaXQpXG4gICAgICAgICAgICAgICAgLm1hcCgoW2lkXSkgPT4gaWQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBUaGlzIHdvdWxkIG5lZWQgdG8gcmVjb25zdHJ1Y3Qgc3VnZ2VzdGlvbnMgZnJvbSBJRHNcbiAgICAgICAgICAgIC8vIEZvciBub3csIHJldHVybiBlbXB0eSBhcnJheVxuICAgICAgICAgICAgcmV0dXJuIFJlc3VsdC5vayhbXSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVzdWx0LmZhaWwoYEZhaWxlZCB0byBnZXQgcG9wdWxhciBzdWdnZXN0aW9uczogJHtlcnJvcn1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgZXh0cmFjdFByb3BlcnRpZXNGcm9tR3JhcGgoKTogQXJyYXk8eyB1cmk6IHN0cmluZzsgZnJlcXVlbmN5OiBudW1iZXIgfT4ge1xuICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBVc2UgbWF0Y2ggd2l0aCB1bmRlZmluZWQgdG8gZ2V0IGFsbCB0cmlwbGVzXG4gICAgICAgICAgICBjb25zdCB0cmlwbGVzID0gdGhpcy5ncmFwaC5tYXRjaCh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdHJpcGxlIG9mIHRyaXBsZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVkaWNhdGUgPSB0cmlwbGUuZ2V0UHJlZGljYXRlKCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnNldChwcmVkaWNhdGUsIChwcm9wZXJ0aWVzLmdldChwcmVkaWNhdGUpIHx8IDApICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBleHRyYWN0IHByb3BlcnRpZXMgZnJvbSBncmFwaDonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHByb3BlcnRpZXMuZW50cmllcygpKVxuICAgICAgICAgICAgLm1hcCgoW3VyaSwgZnJlcXVlbmN5XSkgPT4gKHsgdXJpLCBmcmVxdWVuY3kgfSkpXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYi5mcmVxdWVuY3kgLSBhLmZyZXF1ZW5jeSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBleHRyYWN0Q2xhc3Nlc0Zyb21HcmFwaCgpOiBBcnJheTx7IHVyaTogc3RyaW5nOyBpbnN0YW5jZUNvdW50OiBudW1iZXIgfT4ge1xuICAgICAgICBjb25zdCBjbGFzc2VzID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcbiAgICAgICAgY29uc3QgcmRmVHlwZSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjdHlwZSc7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVXNlIG1hdGNoIHdpdGggdW5kZWZpbmVkIHRvIGdldCBhbGwgdHJpcGxlc1xuICAgICAgICAgICAgY29uc3QgdHJpcGxlcyA9IHRoaXMuZ3JhcGgubWF0Y2godW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRyaXBsZSBvZiB0cmlwbGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyaXBsZS5nZXRQcmVkaWNhdGUoKS50b1N0cmluZygpID09PSByZGZUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsYXNzVXJpID0gdHJpcGxlLmdldE9iamVjdCgpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzZXMuc2V0KGNsYXNzVXJpLCAoY2xhc3Nlcy5nZXQoY2xhc3NVcmkpIHx8IDApICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gZXh0cmFjdCBjbGFzc2VzIGZyb20gZ3JhcGg6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShjbGFzc2VzLmVudHJpZXMoKSlcbiAgICAgICAgICAgIC5tYXAoKFt1cmksIGluc3RhbmNlQ291bnRdKSA9PiAoeyB1cmksIGluc3RhbmNlQ291bnQgfSkpXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYi5pbnN0YW5jZUNvdW50IC0gYS5pbnN0YW5jZUNvdW50KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNyZWF0ZVByb3BlcnR5U3VnZ2VzdGlvbihwcm9wZXJ0eTogeyB1cmk6IHN0cmluZzsgZnJlcXVlbmN5OiBudW1iZXIgfSwgY29udGV4dDogUXVlcnlDb250ZXh0KTogU1BBUlFMU3VnZ2VzdGlvbiB7XG4gICAgICAgIGNvbnN0IHNob3J0TmFtZSA9IHRoaXMuZ2V0U2hvcnROYW1lKHByb3BlcnR5LnVyaSk7XG4gICAgICAgIGNvbnN0IGNvbmZpZGVuY2UgPSBNYXRoLm1pbigwLjksIDAuNSArIChwcm9wZXJ0eS5mcmVxdWVuY3kgLyAxMDApKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBTUEFSUUxTdWdnZXN0aW9uLmNyZWF0ZSh7XG4gICAgICAgICAgICBpZDogYHByb3BlcnR5XyR7cHJvcGVydHkudXJpfWAsXG4gICAgICAgICAgICB0ZXh0OiBzaG9ydE5hbWUsXG4gICAgICAgICAgICBpbnNlcnRUZXh0OiBzaG9ydE5hbWUsXG4gICAgICAgICAgICB0eXBlOiBTdWdnZXN0aW9uVHlwZS5QUk9QRVJUWSxcbiAgICAgICAgICAgIGNvbmZpZGVuY2UsXG4gICAgICAgICAgICBjb250ZXh0dWFsU2NvcmU6IGNvbnRleHQuaXNJbkNsYXVzZShDbGF1c2VUeXBlLldIRVJFKSA/IDAuOSA6IDAuNSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGBQcm9wZXJ0eSAodXNlZCAke3Byb3BlcnR5LmZyZXF1ZW5jeX0gdGltZXMpYCxcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IHByb3BlcnR5LnVyaVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNyZWF0ZUNsYXNzU3VnZ2VzdGlvbihjbHM6IHsgdXJpOiBzdHJpbmc7IGluc3RhbmNlQ291bnQ6IG51bWJlciB9LCBjb250ZXh0OiBRdWVyeUNvbnRleHQpOiBTUEFSUUxTdWdnZXN0aW9uIHtcbiAgICAgICAgY29uc3Qgc2hvcnROYW1lID0gdGhpcy5nZXRTaG9ydE5hbWUoY2xzLnVyaSk7XG4gICAgICAgIGNvbnN0IGNvbmZpZGVuY2UgPSBNYXRoLm1pbigwLjksIDAuNSArIChjbHMuaW5zdGFuY2VDb3VudCAvIDUwKSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gU1BBUlFMU3VnZ2VzdGlvbi5jcmVhdGUoe1xuICAgICAgICAgICAgaWQ6IGBjbGFzc18ke2Nscy51cml9YCxcbiAgICAgICAgICAgIHRleHQ6IHNob3J0TmFtZSxcbiAgICAgICAgICAgIGluc2VydFRleHQ6IHNob3J0TmFtZSxcbiAgICAgICAgICAgIHR5cGU6IFN1Z2dlc3Rpb25UeXBlLkNMQVNTLFxuICAgICAgICAgICAgY29uZmlkZW5jZSxcbiAgICAgICAgICAgIGNvbnRleHR1YWxTY29yZTogdGhpcy5pc0FmdGVyUmRmVHlwZShjb250ZXh0KSA/IDAuOTUgOiAwLjYsXG4gICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ2xhc3MgKCR7Y2xzLmluc3RhbmNlQ291bnR9IGluc3RhbmNlcylgLFxuICAgICAgICAgICAgICAgIG5hbWVzcGFjZTogY2xzLnVyaVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFNob3J0TmFtZSh1cmk6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGhhc2hJbmRleCA9IHVyaS5sYXN0SW5kZXhPZignIycpO1xuICAgICAgICBjb25zdCBzbGFzaEluZGV4ID0gdXJpLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgICAgIGNvbnN0IHNwbGl0SW5kZXggPSBNYXRoLm1heChoYXNoSW5kZXgsIHNsYXNoSW5kZXgpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHNwbGl0SW5kZXggPiAwICYmIHNwbGl0SW5kZXggPCB1cmkubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHVyaS5zdWJzdHJpbmcoc3BsaXRJbmRleCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdXJpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaXNBZnRlclJkZlR5cGUoY29udGV4dDogUXVlcnlDb250ZXh0KTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzVG9rZW5zID0gY29udGV4dC5nZXRQcmV2aW91c1Rva2VucygpO1xuICAgICAgICBpZiAocHJldmlvdXNUb2tlbnMubGVuZ3RoIDwgMikgcmV0dXJuIGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgbGFzdFR3byA9IHByZXZpb3VzVG9rZW5zLnNsaWNlKC0yKS5qb2luKCcgJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIGxhc3RUd28uaW5jbHVkZXMoJ3JkZjp0eXBlJykgfHwgbGFzdFR3by5pbmNsdWRlcygnIGEgJyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzaG91bGRSZWZyZXNoQ2FjaGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGhpcy5jYWNoZVRpbWVzdGFtcCA+IHRoaXMuY2FjaGVUVEw7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZWZyZXNoUHJvcGVydHlDYWNoZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5wcm9wZXJ0eUNhY2hlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuY2FjaGVUaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIH1cblxuICAgIHByaXZhdGUgcmVmcmVzaENsYXNzQ2FjaGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY2xhc3NDYWNoZS5jbGVhcigpO1xuICAgICAgICB0aGlzLmNhY2hlVGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICB9XG59Il0sInZlcnNpb24iOjN9