375814ddda334cb93486aa0a5c0aa157
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CircuitBreakerState = exports.CircuitBreakerService = void 0;
const Result_1 = require("../../domain/core/Result");
/**
 * Circuit breaker implementation for resilient asset creation
 * Prevents cascade failures and provides graceful degradation
 */
class CircuitBreakerService {
    constructor() {
        this.circuits = new Map();
        this.defaultConfig = {
            failureThreshold: 5,
            resetTimeout: 60000,
            monitoringPeriod: 10000,
            halfOpenMaxCalls: 3,
        };
        this.setupCleanupTimer();
    }
    static getInstance() {
        if (!CircuitBreakerService.instance) {
            CircuitBreakerService.instance = new CircuitBreakerService();
        }
        return CircuitBreakerService.instance;
    }
    /**
     * Executes an operation with circuit breaker protection
     * @param circuitName Unique identifier for the circuit
     * @param operation The operation to execute
     * @param config Optional circuit configuration
     * @returns Result of the operation or circuit breaker response
     */
    async execute(circuitName, operation, config) {
        const circuit = this.getOrCreateCircuit(circuitName, config);
        // Check circuit state
        const stateCheck = this.checkCircuitState(circuit);
        if (!stateCheck.canExecute) {
            return Result_1.Result.fail(stateCheck.reason);
        }
        const startTime = Date.now();
        try {
            // Execute the operation
            const result = await operation();
            const duration = Date.now() - startTime;
            if (result.isSuccess) {
                this.recordSuccess(circuit, duration);
            }
            else {
                this.recordFailure(circuit, result.getError(), duration);
            }
            return result;
        }
        catch (error) {
            const duration = Date.now() - startTime;
            const errorMessage = error instanceof Error ? error.message : String(error);
            this.recordFailure(circuit, errorMessage, duration);
            return Result_1.Result.fail(`Circuit breaker caught error: ${errorMessage}`);
        }
    }
    /**
     * Gets current state of a circuit
     * @param circuitName The circuit to check
     * @returns Current circuit state
     */
    getCircuitState(circuitName) {
        const circuit = this.circuits.get(circuitName);
        if (!circuit) {
            return CircuitBreakerState.CLOSED;
        }
        return circuit.state;
    }
    /**
     * Gets circuit statistics for monitoring
     * @param circuitName The circuit to get stats for
     * @returns Circuit statistics or null if not found
     */
    getCircuitStats(circuitName) {
        const circuit = this.circuits.get(circuitName);
        if (!circuit) {
            return null;
        }
        return {
            circuitName,
            state: circuit.state,
            failureCount: circuit.failureCount,
            successCount: circuit.successCount,
            lastFailureTime: circuit.lastFailureTime,
            lastSuccessTime: circuit.lastSuccessTime,
            averageResponseTime: circuit.averageResponseTime,
            totalCalls: circuit.successCount + circuit.failureCount,
            uptime: this.calculateUptime(circuit),
        };
    }
    /**
     * Manually opens a circuit (for testing or emergency)
     * @param circuitName The circuit to open
     */
    openCircuit(circuitName) {
        const circuit = this.getOrCreateCircuit(circuitName);
        circuit.state = CircuitBreakerState.OPEN;
        circuit.lastStateChange = Date.now();
        console.warn(`Circuit ${circuitName} manually opened`);
    }
    /**
     * Manually closes a circuit (resets it)
     * @param circuitName The circuit to close
     */
    closeCircuit(circuitName) {
        const circuit = this.getOrCreateCircuit(circuitName);
        circuit.state = CircuitBreakerState.CLOSED;
        circuit.failureCount = 0;
        circuit.lastStateChange = Date.now();
        console.info(`Circuit ${circuitName} manually closed`);
    }
    /**
     * Gets all circuit names and their states
     * @returns Map of circuit names to states
     */
    getAllCircuitStates() {
        const states = new Map();
        for (const [name, circuit] of this.circuits) {
            states.set(name, circuit.state);
        }
        return states;
    }
    /**
     * Clears all circuit data (for testing)
     */
    clearAllCircuits() {
        this.circuits.clear();
        console.debug("All circuits cleared");
    }
    getOrCreateCircuit(circuitName, config) {
        let circuit = this.circuits.get(circuitName);
        if (!circuit) {
            circuit = {
                name: circuitName,
                state: CircuitBreakerState.CLOSED,
                config: { ...this.defaultConfig, ...config },
                failureCount: 0,
                successCount: 0,
                lastFailureTime: 0,
                lastSuccessTime: 0,
                lastStateChange: Date.now(),
                averageResponseTime: 0,
                responseTimes: [],
            };
            this.circuits.set(circuitName, circuit);
            console.debug(`Created new circuit: ${circuitName}`);
        }
        return circuit;
    }
    checkCircuitState(circuit) {
        const now = Date.now();
        switch (circuit.state) {
            case CircuitBreakerState.CLOSED:
                return { canExecute: true, reason: "" };
            case CircuitBreakerState.OPEN:
                if (now - circuit.lastStateChange >= circuit.config.resetTimeout) {
                    // Transition to half-open
                    circuit.state = CircuitBreakerState.HALF_OPEN;
                    circuit.lastStateChange = now;
                    console.info(`Circuit ${circuit.name} transitioned to HALF_OPEN`);
                    return { canExecute: true, reason: "" };
                }
                return {
                    canExecute: false,
                    reason: `Circuit ${circuit.name} is OPEN. Try again in ${Math.ceil((circuit.config.resetTimeout - (now - circuit.lastStateChange)) / 1000)} seconds`,
                };
            case CircuitBreakerState.HALF_OPEN:
                // Allow limited calls in half-open state
                const recentCalls = this.getRecentCalls(circuit);
                if (recentCalls < circuit.config.halfOpenMaxCalls) {
                    return { canExecute: true, reason: "" };
                }
                return {
                    canExecute: false,
                    reason: `Circuit ${circuit.name} is HALF_OPEN with max calls reached`,
                };
            default:
                return { canExecute: true, reason: "" };
        }
    }
    recordSuccess(circuit, duration) {
        circuit.successCount++;
        circuit.lastSuccessTime = Date.now();
        this.updateResponseTime(circuit, duration);
        if (circuit.state === CircuitBreakerState.HALF_OPEN) {
            // Success in half-open state - close the circuit
            circuit.state = CircuitBreakerState.CLOSED;
            circuit.failureCount = 0;
            circuit.lastStateChange = Date.now();
            console.info(`Circuit ${circuit.name} closed after successful half-open test`);
        }
    }
    recordFailure(circuit, error, duration) {
        circuit.failureCount++;
        circuit.lastFailureTime = Date.now();
        this.updateResponseTime(circuit, duration);
        console.warn(`Circuit ${circuit.name} failure ${circuit.failureCount}: ${error}`);
        // Check if we should open the circuit
        if (circuit.state === CircuitBreakerState.CLOSED &&
            circuit.failureCount >= circuit.config.failureThreshold) {
            circuit.state = CircuitBreakerState.OPEN;
            circuit.lastStateChange = Date.now();
            console.error(`Circuit ${circuit.name} opened due to ${circuit.failureCount} failures`);
        }
        else if (circuit.state === CircuitBreakerState.HALF_OPEN) {
            // Failure in half-open state - reopen the circuit
            circuit.state = CircuitBreakerState.OPEN;
            circuit.lastStateChange = Date.now();
            console.error(`Circuit ${circuit.name} reopened after half-open failure`);
        }
    }
    updateResponseTime(circuit, duration) {
        circuit.responseTimes.push(duration);
        // Keep only recent response times for average calculation
        const maxSamples = 100;
        if (circuit.responseTimes.length > maxSamples) {
            circuit.responseTimes = circuit.responseTimes.slice(-maxSamples);
        }
        // Calculate moving average
        circuit.averageResponseTime =
            circuit.responseTimes.reduce((sum, time) => sum + time, 0) /
                circuit.responseTimes.length;
    }
    getRecentCalls(circuit) {
        const now = Date.now();
        const period = circuit.config.monitoringPeriod;
        // This is simplified - in a real implementation, you'd track actual call times
        return Math.max(0, circuit.successCount + circuit.failureCount -
            Math.floor((now - circuit.lastStateChange) / period));
    }
    calculateUptime(circuit) {
        const totalTime = Date.now() - circuit.lastStateChange;
        if (totalTime === 0)
            return 100;
        // Simplified calculation - in reality you'd track open/closed periods
        const openTime = circuit.state === CircuitBreakerState.OPEN ? totalTime : 0;
        return Math.max(0, ((totalTime - openTime) / totalTime) * 100);
    }
    setupCleanupTimer() {
        // Clean up old circuits every hour
        if (typeof setInterval !== 'undefined') {
            setInterval(() => {
                const now = Date.now();
                const maxAge = 60 * 60 * 1000; // 1 hour
                for (const [name, circuit] of this.circuits) {
                    if (now - circuit.lastStateChange > maxAge &&
                        circuit.successCount === 0 &&
                        circuit.failureCount === 0) {
                        this.circuits.delete(name);
                        console.debug(`Cleaned up inactive circuit: ${name}`);
                    }
                }
            }, 60 * 60 * 1000);
        }
    }
}
exports.CircuitBreakerService = CircuitBreakerService;
CircuitBreakerService.instance = null;
var CircuitBreakerState;
(function (CircuitBreakerState) {
    CircuitBreakerState["CLOSED"] = "CLOSED";
    CircuitBreakerState["OPEN"] = "OPEN";
    CircuitBreakerState["HALF_OPEN"] = "HALF_OPEN";
})(CircuitBreakerState = exports.CircuitBreakerState || (exports.CircuitBreakerState = {}));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2tpdGVsZXYvRG9jdW1lbnRzL2V4b2NvcnRleC1vYnNpZGlhbi1wbHVnaW4vc3JjL2luZnJhc3RydWN0dXJlL3Jlc2lsaWVuY2UvQ2lyY3VpdEJyZWFrZXJTZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7OztBQUFBLHFEQUFrRDtBQUVsRDs7O0dBR0c7QUFDSCxNQUFhLHFCQUFxQjtJQVVoQztRQVJRLGFBQVEsR0FBRyxJQUFJLEdBQUcsRUFBd0IsQ0FBQztRQUNsQyxrQkFBYSxHQUFrQjtZQUM5QyxnQkFBZ0IsRUFBRSxDQUFDO1lBQ25CLFlBQVksRUFBRSxLQUFLO1lBQ25CLGdCQUFnQixFQUFFLEtBQUs7WUFDdkIsZ0JBQWdCLEVBQUUsQ0FBQztTQUNwQixDQUFDO1FBR0EsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7SUFDM0IsQ0FBQztJQUVELE1BQU0sQ0FBQyxXQUFXO1FBQ2hCLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxRQUFRLEVBQUU7WUFDbkMscUJBQXFCLENBQUMsUUFBUSxHQUFHLElBQUkscUJBQXFCLEVBQUUsQ0FBQztTQUM5RDtRQUNELE9BQU8scUJBQXFCLENBQUMsUUFBUSxDQUFDO0lBQ3hDLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxLQUFLLENBQUMsT0FBTyxDQUNYLFdBQW1CLEVBQ25CLFNBQW1DLEVBQ25DLE1BQStCO1FBRS9CLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxXQUFXLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFFN0Qsc0JBQXNCO1FBQ3RCLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNuRCxJQUFJLENBQUMsVUFBVSxDQUFDLFVBQVUsRUFBRTtZQUMxQixPQUFPLGVBQU0sQ0FBQyxJQUFJLENBQUksVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQzFDO1FBRUQsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBRTdCLElBQUk7WUFD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UUFDdkIsbUNBQW1DO1FBQ25DLElBQUksT0FBTyxXQUFXLEtBQUssV0FBVyxFQUFFO1lBQ3RDLFdBQVcsQ0FBQyxHQUFHLEVBQUU7Z0JBQ2YsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO2dCQUN2QixNQUFNLE1BQU0sR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDLFNBQVM7Z0JBRXhDLEtBQUssTUFBTSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO29CQUMzQyxJQUFJLEdBQUcsR0FBRyxPQUFPLENBQUMsZUFBZSxHQUFHLE1BQU07d0JBQ3RDLE9BQU8sQ0FBQyxZQUFZLEtBQUssQ0FBQzt3QkFDMUIsT0FBTyxDQUFDLFlBQVksS0FBSyxDQUFDLEVBQUU7d0JBQzlCLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO3dCQUMzQixPQUFPLENBQUMsS0FBSyxDQUFDLGdDQUFnQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO3FCQUN2RDtpQkFDRjtZQUNILENBQUMsRUFBRSxFQUFFLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDO1NBQ3BCO0lBQ0gsQ0FBQzs7QUE1U0gsc0RBNlNDO0FBNVNnQiw4QkFBUSxHQUFpQyxJQUFJLENBQUM7QUE4Uy9ELElBQVksbUJBSVg7QUFKRCxXQUFZLG1CQUFtQjtJQUM3Qix3Q0FBaUIsQ0FBQTtJQUNqQixvQ0FBYSxDQUFBO0lBQ2IsOENBQXVCLENBQUE7QUFDekIsQ0FBQyxFQUpXLG1CQUFtQixHQUFuQiwyQkFBbUIsS0FBbkIsMkJBQW1CLFFBSTlCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9raXRlbGV2L0RvY3VtZW50cy9leG9jb3J0ZXgtb2JzaWRpYW4tcGx1Z2luL3NyYy9pbmZyYXN0cnVjdHVyZS9yZXNpbGllbmNlL0NpcmN1aXRCcmVha2VyU2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSZXN1bHQgfSBmcm9tIFwiLi4vLi4vZG9tYWluL2NvcmUvUmVzdWx0XCI7XG5cbi8qKlxuICogQ2lyY3VpdCBicmVha2VyIGltcGxlbWVudGF0aW9uIGZvciByZXNpbGllbnQgYXNzZXQgY3JlYXRpb25cbiAqIFByZXZlbnRzIGNhc2NhZGUgZmFpbHVyZXMgYW5kIHByb3ZpZGVzIGdyYWNlZnVsIGRlZ3JhZGF0aW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBDaXJjdWl0QnJlYWtlclNlcnZpY2Uge1xuICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogQ2lyY3VpdEJyZWFrZXJTZXJ2aWNlIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgY2lyY3VpdHMgPSBuZXcgTWFwPHN0cmluZywgQ2lyY3VpdFN0YXRlPigpO1xuICBwcml2YXRlIHJlYWRvbmx5IGRlZmF1bHRDb25maWc6IENpcmN1aXRDb25maWcgPSB7XG4gICAgZmFpbHVyZVRocmVzaG9sZDogNSxcbiAgICByZXNldFRpbWVvdXQ6IDYwMDAwLCAvLyAxIG1pbnV0ZVxuICAgIG1vbml0b3JpbmdQZXJpb2Q6IDEwMDAwLCAvLyAxMCBzZWNvbmRzXG4gICAgaGFsZk9wZW5NYXhDYWxsczogMyxcbiAgfTtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2V0dXBDbGVhbnVwVGltZXIoKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBDaXJjdWl0QnJlYWtlclNlcnZpY2Uge1xuICAgIGlmICghQ2lyY3VpdEJyZWFrZXJTZXJ2aWNlLmluc3RhbmNlKSB7XG4gICAgICBDaXJjdWl0QnJlYWtlclNlcnZpY2UuaW5zdGFuY2UgPSBuZXcgQ2lyY3VpdEJyZWFrZXJTZXJ2aWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBDaXJjdWl0QnJlYWtlclNlcnZpY2UuaW5zdGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgYW4gb3BlcmF0aW9uIHdpdGggY2lyY3VpdCBicmVha2VyIHByb3RlY3Rpb25cbiAgICogQHBhcmFtIGNpcmN1aXROYW1lIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgY2lyY3VpdFxuICAgKiBAcGFyYW0gb3BlcmF0aW9uIFRoZSBvcGVyYXRpb24gdG8gZXhlY3V0ZVxuICAgKiBAcGFyYW0gY29uZmlnIE9wdGlvbmFsIGNpcmN1aXQgY29uZmlndXJhdGlvblxuICAgKiBAcmV0dXJucyBSZXN1bHQgb2YgdGhlIG9wZXJhdGlvbiBvciBjaXJjdWl0IGJyZWFrZXIgcmVzcG9uc2VcbiAgICovXG4gIGFzeW5jIGV4ZWN1dGU8VD4oXG4gICAgY2lyY3VpdE5hbWU6IHN0cmluZyxcbiAgICBvcGVyYXRpb246ICgpID0+IFByb21pc2U8UmVzdWx0PFQ+PixcbiAgICBjb25maWc/OiBQYXJ0aWFsPENpcmN1aXRDb25maWc+LFxuICApOiBQcm9taXNlPFJlc3VsdDxUPj4ge1xuICAgIGNvbnN0IGNpcmN1aXQgPSB0aGlzLmdldE9yQ3JlYXRlQ2lyY3VpdChjaXJjdWl0TmFtZSwgY29uZmlnKTtcblxuICAgIC8vIENoZWNrIGNpcmN1aXQgc3RhdGVcbiAgICBjb25zdCBzdGF0ZUNoZWNrID0gdGhpcy5jaGVja0NpcmN1aXRTdGF0ZShjaXJjdWl0KTtcbiAgICBpZiAoIXN0YXRlQ2hlY2suY2FuRXhlY3V0ZSkge1xuICAgICAgcmV0dXJuIFJlc3VsdC5mYWlsPFQ+KHN0YXRlQ2hlY2sucmVhc29uKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEV4ZWN1dGUgdGhlIG9wZXJhdGlvblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb3BlcmF0aW9uKCk7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG5cbiAgICAgIGlmIChyZXN1bHQuaXNTdWNjZXNzKSB7XG4gICAgICAgIHRoaXMucmVjb3JkU3VjY2VzcyhjaXJjdWl0LCBkdXJhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlY29yZEZhaWx1cmUoY2lyY3VpdCwgcmVzdWx0LmdldEVycm9yKCksIGR1cmF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgXG4gICAgICB0aGlzLnJlY29yZEZhaWx1cmUoY2lyY3VpdCwgZXJyb3JNZXNzYWdlLCBkdXJhdGlvbik7XG4gICAgICByZXR1cm4gUmVzdWx0LmZhaWw8VD4oYENpcmN1aXQgYnJlYWtlciBjYXVnaHQgZXJyb3I6ICR7ZXJyb3JNZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGN1cnJlbnQgc3RhdGUgb2YgYSBjaXJjdWl0XG4gICAqIEBwYXJhbSBjaXJjdWl0TmFtZSBUaGUgY2lyY3VpdCB0byBjaGVja1xuICAgKiBAcmV0dXJucyBDdXJyZW50IGNpcmN1aXQgc3RhdGVcbiAgICovXG4gIGdldENpcmN1aXRTdGF0ZShjaXJjdWl0TmFtZTogc3RyaW5nKTogQ2lyY3VpdEJyZWFrZXJTdGF0ZSB7XG4gICAgY29uc3QgY2lyY3VpdCA9IHRoaXMuY2lyY3VpdHMuZ2V0KGNpcmN1aXROYW1lKTtcbiAgICBpZiAoIWNpcmN1aXQpIHtcbiAgICAgIHJldHVybiBDaXJjdWl0QnJlYWtlclN0YXRlLkNMT1NFRDtcbiAgICB9XG5cbiAgICByZXR1cm4gY2lyY3VpdC5zdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNpcmN1aXQgc3RhdGlzdGljcyBmb3IgbW9uaXRvcmluZ1xuICAgKiBAcGFyYW0gY2lyY3VpdE5hbWUgVGhlIGNpcmN1aXQgdG8gZ2V0IHN0YXRzIGZvclxuICAgKiBAcmV0dXJucyBDaXJjdWl0IHN0YXRpc3RpY3Mgb3IgbnVsbCBpZiBub3QgZm91bmRcbiAgICovXG4gIGdldENpcmN1aXRTdGF0cyhjaXJjdWl0TmFtZTogc3RyaW5nKTogQ2lyY3VpdFN0YXRzIHwgbnVsbCB7XG4gICAgY29uc3QgY2lyY3VpdCA9IHRoaXMuY2lyY3VpdHMuZ2V0KGNpcmN1aXROYW1lKTtcbiAgICBpZiAoIWNpcmN1aXQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjaXJjdWl0TmFtZSxcbiAgICAgIHN0YXRlOiBjaXJjdWl0LnN0YXRlLFxuICAgICAgZmFpbHVyZUNvdW50OiBjaXJjdWl0LmZhaWx1cmVDb3VudCxcbiAgICAgIHN1Y2Nlc3NDb3VudDogY2lyY3VpdC5zdWNjZXNzQ291bnQsXG4gICAgICBsYXN0RmFpbHVyZVRpbWU6IGNpcmN1aXQubGFzdEZhaWx1cmVUaW1lLFxuICAgICAgbGFzdFN1Y2Nlc3NUaW1lOiBjaXJjdWl0Lmxhc3RTdWNjZXNzVGltZSxcbiAgICAgIGF2ZXJhZ2VSZXNwb25zZVRpbWU6IGNpcmN1aXQuYXZlcmFnZVJlc3BvbnNlVGltZSxcbiAgICAgIHRvdGFsQ2FsbHM6IGNpcmN1aXQuc3VjY2Vzc0NvdW50ICsgY2lyY3VpdC5mYWlsdXJlQ291bnQsXG4gICAgICB1cHRpbWU6IHRoaXMuY2FsY3VsYXRlVXB0aW1lKGNpcmN1aXQpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogTWFudWFsbHkgb3BlbnMgYSBjaXJjdWl0IChmb3IgdGVzdGluZyBvciBlbWVyZ2VuY3kpXG4gICAqIEBwYXJhbSBjaXJjdWl0TmFtZSBUaGUgY2lyY3VpdCB0byBvcGVuXG4gICAqL1xuICBvcGVuQ2lyY3VpdChjaXJjdWl0TmFtZTogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgY2lyY3VpdCA9IHRoaXMuZ2V0T3JDcmVhdGVDaXJjdWl0KGNpcmN1aXROYW1lKTtcbiAgICBjaXJjdWl0LnN0YXRlID0gQ2lyY3VpdEJyZWFrZXJTdGF0ZS5PUEVOO1xuICAgIGNpcmN1aXQubGFzdFN0YXRlQ2hhbmdlID0gRGF0ZS5ub3coKTtcbiAgICBjb25zb2xlLndhcm4oYENpcmN1aXQgJHtjaXJjdWl0TmFtZX0gbWFudWFsbHkgb3BlbmVkYCk7XG4gIH1cblxuICAvKipcbiAgICogTWFudWFsbHkgY2xvc2VzIGEgY2lyY3VpdCAocmVzZXRzIGl0KVxuICAgKiBAcGFyYW0gY2lyY3VpdE5hbWUgVGhlIGNpcmN1aXQgdG8gY2xvc2VcbiAgICovXG4gIGNsb3NlQ2lyY3VpdChjaXJjdWl0TmFtZTogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgY2lyY3VpdCA9IHRoaXMuZ2V0T3JDcmVhdGVDaXJjdWl0KGNpcmN1aXROYW1lKTtcbiAgICBjaXJjdWl0LnN0YXRlID0gQ2lyY3VpdEJyZWFrZXJTdGF0ZS5DTE9TRUQ7XG4gICAgY2lyY3VpdC5mYWlsdXJlQ291bnQgPSAwO1xuICAgIGNpcmN1aXQubGFzdFN0YXRlQ2hhbmdlID0gRGF0ZS5ub3coKTtcbiAgICBjb25zb2xlLmluZm8oYENpcmN1aXQgJHtjaXJjdWl0TmFtZX0gbWFudWFsbHkgY2xvc2VkYCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbGwgY2lyY3VpdCBuYW1lcyBhbmQgdGhlaXIgc3RhdGVzXG4gICAqIEByZXR1cm5zIE1hcCBvZiBjaXJjdWl0IG5hbWVzIHRvIHN0YXRlc1xuICAgKi9cbiAgZ2V0QWxsQ2lyY3VpdFN0YXRlcygpOiBNYXA8c3RyaW5nLCBDaXJjdWl0QnJlYWtlclN0YXRlPiB7XG4gICAgY29uc3Qgc3RhdGVzID0gbmV3IE1hcDxzdHJpbmcsIENpcmN1aXRCcmVha2VyU3RhdGU+KCk7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgY2lyY3VpdF0gb2YgdGhpcy5jaXJjdWl0cykge1xuICAgICAgc3RhdGVzLnNldChuYW1lLCBjaXJjdWl0LnN0YXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgYWxsIGNpcmN1aXQgZGF0YSAoZm9yIHRlc3RpbmcpXG4gICAqL1xuICBjbGVhckFsbENpcmN1aXRzKCk6IHZvaWQge1xuICAgIHRoaXMuY2lyY3VpdHMuY2xlYXIoKTtcbiAgICBjb25zb2xlLmRlYnVnKFwiQWxsIGNpcmN1aXRzIGNsZWFyZWRcIik7XG4gIH1cblxuICBwcml2YXRlIGdldE9yQ3JlYXRlQ2lyY3VpdChcbiAgICBjaXJjdWl0TmFtZTogc3RyaW5nLFxuICAgIGNvbmZpZz86IFBhcnRpYWw8Q2lyY3VpdENvbmZpZz4sXG4gICk6IENpcmN1aXRTdGF0ZSB7XG4gICAgbGV0IGNpcmN1aXQgPSB0aGlzLmNpcmN1aXRzLmdldChjaXJjdWl0TmFtZSk7XG4gICAgXG4gICAgaWYgKCFjaXJjdWl0KSB7XG4gICAgICBjaXJjdWl0ID0ge1xuICAgICAgICBuYW1lOiBjaXJjdWl0TmFtZSxcbiAgICAgICAgc3RhdGU6IENpcmN1aXRCcmVha2VyU3RhdGUuQ0xPU0VELFxuICAgICAgICBjb25maWc6IHsgLi4udGhpcy5kZWZhdWx0Q29uZmlnLCAuLi5jb25maWcgfSxcbiAgICAgICAgZmFpbHVyZUNvdW50OiAwLFxuICAgICAgICBzdWNjZXNzQ291bnQ6IDAsXG4gICAgICAgIGxhc3RGYWlsdXJlVGltZTogMCxcbiAgICAgICAgbGFzdFN1Y2Nlc3NUaW1lOiAwLFxuICAgICAgICBsYXN0U3RhdGVDaGFuZ2U6IERhdGUubm93KCksXG4gICAgICAgIGF2ZXJhZ2VSZXNwb25zZVRpbWU6IDAsXG4gICAgICAgIHJlc3BvbnNlVGltZXM6IFtdLFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgdGhpcy5jaXJjdWl0cy5zZXQoY2lyY3VpdE5hbWUsIGNpcmN1aXQpO1xuICAgICAgY29uc29sZS5kZWJ1ZyhgQ3JlYXRlZCBuZXcgY2lyY3VpdDogJHtjaXJjdWl0TmFtZX1gKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGNpcmN1aXQ7XG4gIH1cblxuICBwcml2YXRlIGNoZWNrQ2lyY3VpdFN0YXRlKGNpcmN1aXQ6IENpcmN1aXRTdGF0ZSk6IHtcbiAgICBjYW5FeGVjdXRlOiBib29sZWFuO1xuICAgIHJlYXNvbjogc3RyaW5nO1xuICB9IHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgc3dpdGNoIChjaXJjdWl0LnN0YXRlKSB7XG4gICAgICBjYXNlIENpcmN1aXRCcmVha2VyU3RhdGUuQ0xPU0VEOlxuICAgICAgICByZXR1cm4geyBjYW5FeGVjdXRlOiB0cnVlLCByZWFzb246IFwiXCIgfTtcblxuICAgICAgY2FzZSBDaXJjdWl0QnJlYWtlclN0YXRlLk9QRU46XG4gICAgICAgIGlmIChub3cgLSBjaXJjdWl0Lmxhc3RTdGF0ZUNoYW5nZSA+PSBjaXJjdWl0LmNvbmZpZy5yZXNldFRpbWVvdXQpIHtcbiAgICAgICAgICAvLyBUcmFuc2l0aW9uIHRvIGhhbGYtb3BlblxuICAgICAgICAgIGNpcmN1aXQuc3RhdGUgPSBDaXJjdWl0QnJlYWtlclN0YXRlLkhBTEZfT1BFTjtcbiAgICAgICAgICBjaXJjdWl0Lmxhc3RTdGF0ZUNoYW5nZSA9IG5vdztcbiAgICAgICAgICBjb25zb2xlLmluZm8oYENpcmN1aXQgJHtjaXJjdWl0Lm5hbWV9IHRyYW5zaXRpb25lZCB0byBIQUxGX09QRU5gKTtcbiAgICAgICAgICByZXR1cm4geyBjYW5FeGVjdXRlOiB0cnVlLCByZWFzb246IFwiXCIgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNhbkV4ZWN1dGU6IGZhbHNlLFxuICAgICAgICAgIHJlYXNvbjogYENpcmN1aXQgJHtjaXJjdWl0Lm5hbWV9IGlzIE9QRU4uIFRyeSBhZ2FpbiBpbiAke1xuICAgICAgICAgICAgTWF0aC5jZWlsKChjaXJjdWl0LmNvbmZpZy5yZXNldFRpbWVvdXQgLSAobm93IC0gY2lyY3VpdC5sYXN0U3RhdGVDaGFuZ2UpKSAvIDEwMDApXG4gICAgICAgICAgfSBzZWNvbmRzYCxcbiAgICAgICAgfTtcblxuICAgICAgY2FzZSBDaXJjdWl0QnJlYWtlclN0YXRlLkhBTEZfT1BFTjpcbiAgICAgICAgLy8gQWxsb3cgbGltaXRlZCBjYWxscyBpbiBoYWxmLW9wZW4gc3RhdGVcbiAgICAgICAgY29uc3QgcmVjZW50Q2FsbHMgPSB0aGlzLmdldFJlY2VudENhbGxzKGNpcmN1aXQpO1xuICAgICAgICBpZiAocmVjZW50Q2FsbHMgPCBjaXJjdWl0LmNvbmZpZy5oYWxmT3Blbk1heENhbGxzKSB7XG4gICAgICAgICAgcmV0dXJuIHsgY2FuRXhlY3V0ZTogdHJ1ZSwgcmVhc29uOiBcIlwiIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjYW5FeGVjdXRlOiBmYWxzZSxcbiAgICAgICAgICByZWFzb246IGBDaXJjdWl0ICR7Y2lyY3VpdC5uYW1lfSBpcyBIQUxGX09QRU4gd2l0aCBtYXggY2FsbHMgcmVhY2hlZGAsXG4gICAgICAgIH07XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB7IGNhbkV4ZWN1dGU6IHRydWUsIHJlYXNvbjogXCJcIiB9O1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVjb3JkU3VjY2VzcyhjaXJjdWl0OiBDaXJjdWl0U3RhdGUsIGR1cmF0aW9uOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjaXJjdWl0LnN1Y2Nlc3NDb3VudCsrO1xuICAgIGNpcmN1aXQubGFzdFN1Y2Nlc3NUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLnVwZGF0ZVJlc3BvbnNlVGltZShjaXJjdWl0LCBkdXJhdGlvbik7XG5cbiAgICBpZiAoY2lyY3VpdC5zdGF0ZSA9PT0gQ2lyY3VpdEJyZWFrZXJTdGF0ZS5IQUxGX09QRU4pIHtcbiAgICAgIC8vIFN1Y2Nlc3MgaW4gaGFsZi1vcGVuIHN0YXRlIC0gY2xvc2UgdGhlIGNpcmN1aXRcbiAgICAgIGNpcmN1aXQuc3RhdGUgPSBDaXJjdWl0QnJlYWtlclN0YXRlLkNMT1NFRDtcbiAgICAgIGNpcmN1aXQuZmFpbHVyZUNvdW50ID0gMDtcbiAgICAgIGNpcmN1aXQubGFzdFN0YXRlQ2hhbmdlID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnNvbGUuaW5mbyhgQ2lyY3VpdCAke2NpcmN1aXQubmFtZX0gY2xvc2VkIGFmdGVyIHN1Y2Nlc3NmdWwgaGFsZi1vcGVuIHRlc3RgKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlY29yZEZhaWx1cmUoY2lyY3VpdDogQ2lyY3VpdFN0YXRlLCBlcnJvcjogc3RyaW5nLCBkdXJhdGlvbjogbnVtYmVyKTogdm9pZCB7XG4gICAgY2lyY3VpdC5mYWlsdXJlQ291bnQrKztcbiAgICBjaXJjdWl0Lmxhc3RGYWlsdXJlVGltZSA9IERhdGUubm93KCk7XG4gICAgdGhpcy51cGRhdGVSZXNwb25zZVRpbWUoY2lyY3VpdCwgZHVyYXRpb24pO1xuXG4gICAgY29uc29sZS53YXJuKGBDaXJjdWl0ICR7Y2lyY3VpdC5uYW1lfSBmYWlsdXJlICR7Y2lyY3VpdC5mYWlsdXJlQ291bnR9OiAke2Vycm9yfWApO1xuXG4gICAgLy8gQ2hlY2sgaWYgd2Ugc2hvdWxkIG9wZW4gdGhlIGNpcmN1aXRcbiAgICBpZiAoXG4gICAgICBjaXJjdWl0LnN0YXRlID09PSBDaXJjdWl0QnJlYWtlclN0YXRlLkNMT1NFRCAmJlxuICAgICAgY2lyY3VpdC5mYWlsdXJlQ291bnQgPj0gY2lyY3VpdC5jb25maWcuZmFpbHVyZVRocmVzaG9sZFxuICAgICkge1xuICAgICAgY2lyY3VpdC5zdGF0ZSA9IENpcmN1aXRCcmVha2VyU3RhdGUuT1BFTjtcbiAgICAgIGNpcmN1aXQubGFzdFN0YXRlQ2hhbmdlID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYENpcmN1aXQgJHtjaXJjdWl0Lm5hbWV9IG9wZW5lZCBkdWUgdG8gJHtjaXJjdWl0LmZhaWx1cmVDb3VudH0gZmFpbHVyZXNgKTtcbiAgICB9IGVsc2UgaWYgKGNpcmN1aXQuc3RhdGUgPT09IENpcmN1aXRCcmVha2VyU3RhdGUuSEFMRl9PUEVOKSB7XG4gICAgICAvLyBGYWlsdXJlIGluIGhhbGYtb3BlbiBzdGF0ZSAtIHJlb3BlbiB0aGUgY2lyY3VpdFxuICAgICAgY2lyY3VpdC5zdGF0ZSA9IENpcmN1aXRCcmVha2VyU3RhdGUuT1BFTjtcbiAgICAgIGNpcmN1aXQubGFzdFN0YXRlQ2hhbmdlID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYENpcmN1aXQgJHtjaXJjdWl0Lm5hbWV9IHJlb3BlbmVkIGFmdGVyIGhhbGYtb3BlbiBmYWlsdXJlYCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVSZXNwb25zZVRpbWUoY2lyY3VpdDogQ2lyY3VpdFN0YXRlLCBkdXJhdGlvbjogbnVtYmVyKTogdm9pZCB7XG4gICAgY2lyY3VpdC5yZXNwb25zZVRpbWVzLnB1c2goZHVyYXRpb24pO1xuICAgIFxuICAgIC8vIEtlZXAgb25seSByZWNlbnQgcmVzcG9uc2UgdGltZXMgZm9yIGF2ZXJhZ2UgY2FsY3VsYXRpb25cbiAgICBjb25zdCBtYXhTYW1wbGVzID0gMTAwO1xuICAgIGlmIChjaXJjdWl0LnJlc3BvbnNlVGltZXMubGVuZ3RoID4gbWF4U2FtcGxlcykge1xuICAgICAgY2lyY3VpdC5yZXNwb25zZVRpbWVzID0gY2lyY3VpdC5yZXNwb25zZVRpbWVzLnNsaWNlKC1tYXhTYW1wbGVzKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIG1vdmluZyBhdmVyYWdlXG4gICAgY2lyY3VpdC5hdmVyYWdlUmVzcG9uc2VUaW1lID0gXG4gICAgICBjaXJjdWl0LnJlc3BvbnNlVGltZXMucmVkdWNlKChzdW0sIHRpbWUpID0+IHN1bSArIHRpbWUsIDApIC8gXG4gICAgICBjaXJjdWl0LnJlc3BvbnNlVGltZXMubGVuZ3RoO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRSZWNlbnRDYWxscyhjaXJjdWl0OiBDaXJjdWl0U3RhdGUpOiBudW1iZXIge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgcGVyaW9kID0gY2lyY3VpdC5jb25maWcubW9uaXRvcmluZ1BlcmlvZDtcbiAgICBcbiAgICAvLyBUaGlzIGlzIHNpbXBsaWZpZWQgLSBpbiBhIHJlYWwgaW1wbGVtZW50YXRpb24sIHlvdSdkIHRyYWNrIGFjdHVhbCBjYWxsIHRpbWVzXG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIGNpcmN1aXQuc3VjY2Vzc0NvdW50ICsgY2lyY3VpdC5mYWlsdXJlQ291bnQgLSBcbiAgICAgIE1hdGguZmxvb3IoKG5vdyAtIGNpcmN1aXQubGFzdFN0YXRlQ2hhbmdlKSAvIHBlcmlvZCkpO1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVVcHRpbWUoY2lyY3VpdDogQ2lyY3VpdFN0YXRlKTogbnVtYmVyIHtcbiAgICBjb25zdCB0b3RhbFRpbWUgPSBEYXRlLm5vdygpIC0gY2lyY3VpdC5sYXN0U3RhdGVDaGFuZ2U7XG4gICAgaWYgKHRvdGFsVGltZSA9PT0gMCkgcmV0dXJuIDEwMDtcbiAgICBcbiAgICAvLyBTaW1wbGlmaWVkIGNhbGN1bGF0aW9uIC0gaW4gcmVhbGl0eSB5b3UnZCB0cmFjayBvcGVuL2Nsb3NlZCBwZXJpb2RzXG4gICAgY29uc3Qgb3BlblRpbWUgPSBjaXJjdWl0LnN0YXRlID09PSBDaXJjdWl0QnJlYWtlclN0YXRlLk9QRU4gPyB0b3RhbFRpbWUgOiAwO1xuICAgIHJldHVybiBNYXRoLm1heCgwLCAoKHRvdGFsVGltZSAtIG9wZW5UaW1lKSAvIHRvdGFsVGltZSkgKiAxMDApO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXR1cENsZWFudXBUaW1lcigpOiB2b2lkIHtcbiAgICAvLyBDbGVhbiB1cCBvbGQgY2lyY3VpdHMgZXZlcnkgaG91clxuICAgIGlmICh0eXBlb2Ygc2V0SW50ZXJ2YWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IG1heEFnZSA9IDYwICogNjAgKiAxMDAwOyAvLyAxIGhvdXJcbiAgICAgICAgXG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIGNpcmN1aXRdIG9mIHRoaXMuY2lyY3VpdHMpIHtcbiAgICAgICAgICBpZiAobm93IC0gY2lyY3VpdC5sYXN0U3RhdGVDaGFuZ2UgPiBtYXhBZ2UgJiYgXG4gICAgICAgICAgICAgIGNpcmN1aXQuc3VjY2Vzc0NvdW50ID09PSAwICYmIFxuICAgICAgICAgICAgICBjaXJjdWl0LmZhaWx1cmVDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5jaXJjdWl0cy5kZWxldGUobmFtZSk7XG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKGBDbGVhbmVkIHVwIGluYWN0aXZlIGNpcmN1aXQ6ICR7bmFtZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIDYwICogNjAgKiAxMDAwKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGVudW0gQ2lyY3VpdEJyZWFrZXJTdGF0ZSB7XG4gIENMT1NFRCA9IFwiQ0xPU0VEXCIsXG4gIE9QRU4gPSBcIk9QRU5cIiwgXG4gIEhBTEZfT1BFTiA9IFwiSEFMRl9PUEVOXCIsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2lyY3VpdENvbmZpZyB7XG4gIGZhaWx1cmVUaHJlc2hvbGQ6IG51bWJlcjtcbiAgcmVzZXRUaW1lb3V0OiBudW1iZXI7XG4gIG1vbml0b3JpbmdQZXJpb2Q6IG51bWJlcjtcbiAgaGFsZk9wZW5NYXhDYWxsczogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgQ2lyY3VpdFN0YXRlIHtcbiAgbmFtZTogc3RyaW5nO1xuICBzdGF0ZTogQ2lyY3VpdEJyZWFrZXJTdGF0ZTtcbiAgY29uZmlnOiBDaXJjdWl0Q29uZmlnO1xuICBmYWlsdXJlQ291bnQ6IG51bWJlcjtcbiAgc3VjY2Vzc0NvdW50OiBudW1iZXI7XG4gIGxhc3RGYWlsdXJlVGltZTogbnVtYmVyO1xuICBsYXN0U3VjY2Vzc1RpbWU6IG51bWJlcjtcbiAgbGFzdFN0YXRlQ2hhbmdlOiBudW1iZXI7XG4gIGF2ZXJhZ2VSZXNwb25zZVRpbWU6IG51bWJlcjtcbiAgcmVzcG9uc2VUaW1lczogbnVtYmVyW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2lyY3VpdFN0YXRzIHtcbiAgY2lyY3VpdE5hbWU6IHN0cmluZztcbiAgc3RhdGU6IENpcmN1aXRCcmVha2VyU3RhdGU7XG4gIGZhaWx1cmVDb3VudDogbnVtYmVyO1xuICBzdWNjZXNzQ291bnQ6IG51bWJlcjtcbiAgbGFzdEZhaWx1cmVUaW1lOiBudW1iZXI7XG4gIGxhc3RTdWNjZXNzVGltZTogbnVtYmVyO1xuICBhdmVyYWdlUmVzcG9uc2VUaW1lOiBudW1iZXI7XG4gIHRvdGFsQ2FsbHM6IG51bWJlcjtcbiAgdXB0aW1lOiBudW1iZXI7XG59Il0sInZlcnNpb24iOjN9