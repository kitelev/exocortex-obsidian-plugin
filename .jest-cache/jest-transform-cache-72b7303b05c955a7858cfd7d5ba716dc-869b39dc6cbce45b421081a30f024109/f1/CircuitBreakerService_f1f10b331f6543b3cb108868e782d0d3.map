{"file":"/Users/kitelev/Documents/exocortex-obsidian-plugin/src/infrastructure/resilience/CircuitBreakerService.ts","mappings":";;;AAAA,qDAAkD;AAElD;;;GAGG;AACH,MAAa,qBAAqB;IAUhC;QARQ,aAAQ,GAAG,IAAI,GAAG,EAAwB,CAAC;QAClC,kBAAa,GAAkB;YAC9C,gBAAgB,EAAE,CAAC;YACnB,YAAY,EAAE,KAAK;YACnB,gBAAgB,EAAE,KAAK;YACvB,gBAAgB,EAAE,CAAC;SACpB,CAAC;QAGA,IAAI,CAAC,iBAAiB,EAAE,CAAC;IAC3B,CAAC;IAED,MAAM,CAAC,WAAW;QAChB,IAAI,CAAC,qBAAqB,CAAC,QAAQ,EAAE;YACnC,qBAAqB,CAAC,QAAQ,GAAG,IAAI,qBAAqB,EAAE,CAAC;SAC9D;QACD,OAAO,qBAAqB,CAAC,QAAQ,CAAC;IACxC,CAAC;IAED;;;;;;OAMG;IACH,KAAK,CAAC,OAAO,CACX,WAAmB,EACnB,SAAmC,EACnC,MAA+B;QAE/B,MAAM,OAAO,GAAG,IAAI,CAAC,kBAAkB,CAAC,WAAW,EAAE,MAAM,CAAC,CAAC;QAE7D,sBAAsB;QACtB,MAAM,UAAU,GAAG,IAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;QACnD,IAAI,CAAC,UAAU,CAAC,UAAU,EAAE;YAC1B,OAAO,eAAM,CAAC,IAAI,CAAI,UAAU,CAAC,MAAM,CAAC,CAAC;SAC1C;QAED,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QAE7B,IAAI;YACF,wBAAwB;YACxB,MAAM,MAAM,GAAG,MAAM,SAAS,EAAE,CAAC;YACjC,MAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,SAAS,CAAC;YAExC,IAAI,MAAM,CAAC,SAAS,EAAE;gBACpB,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;aACvC;iBAAM;gBACL,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,MAAM,CAAC,QAAQ,EAAE,EAAE,QAAQ,CAAC,CAAC;aAC1D;YAED,OAAO,MAAM,CAAC;SACf;QAAC,OAAO,KAAK,EAAE;YACd,MAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,SAAS,CAAC;YACxC,MAAM,YAAY,GAAG,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YAE5E,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,YAAY,EAAE,QAAQ,CAAC,CAAC;YACpD,OAAO,eAAM,CAAC,IAAI,CAAI,iCAAiC,YAAY,EAAE,CAAC,CAAC;SACxE;IACH,CAAC;IAED;;;;OAIG;IACH,eAAe,CAAC,WAAmB;QACjC,MAAM,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;QAC/C,IAAI,CAAC,OAAO,EAAE;YACZ,OAAO,mBAAmB,CAAC,MAAM,CAAC;SACnC;QAED,OAAO,OAAO,CAAC,KAAK,CAAC;IACvB,CAAC;IAED;;;;OAIG;IACH,eAAe,CAAC,WAAmB;QACjC,MAAM,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;QAC/C,IAAI,CAAC,OAAO,EAAE;YACZ,OAAO,IAAI,CAAC;SACb;QAED,OAAO;YACL,WAAW;YACX,KAAK,EAAE,OAAO,CAAC,KAAK;YACpB,YAAY,EAAE,OAAO,CAAC,YAAY;YAClC,YAAY,EAAE,OAAO,CAAC,YAAY;YAClC,eAAe,EAAE,OAAO,CAAC,eAAe;YACxC,eAAe,EAAE,OAAO,CAAC,eAAe;YACxC,mBAAmB,EAAE,OAAO,CAAC,mBAAmB;YAChD,UAAU,EAAE,OAAO,CAAC,YAAY,GAAG,OAAO,CAAC,YAAY;YACvD,MAAM,EAAE,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC;SACtC,CAAC;IACJ,CAAC;IAED;;;OAGG;IACH,WAAW,CAAC,WAAmB;QAC7B,MAAM,OAAO,GAAG,IAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,CAAC;QACrD,OAAO,CAAC,KAAK,GAAG,mBAAmB,CAAC,IAAI,CAAC;QACzC,OAAO,CAAC,eAAe,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACrC,OAAO,CAAC,IAAI,CAAC,WAAW,WAAW,kBAAkB,CAAC,CAAC;IACzD,CAAC;IAED;;;OAGG;IACH,YAAY,CAAC,WAAmB;QAC9B,MAAM,OAAO,GAAG,IAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,CAAC;QACrD,OAAO,CAAC,KAAK,GAAG,mBAAmB,CAAC,MAAM,CAAC;QAC3C,OAAO,CAAC,YAAY,GAAG,CAAC,CAAC;QACzB,OAAO,CAAC,eAAe,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACrC,OAAO,CAAC,IAAI,CAAC,WAAW,WAAW,kBAAkB,CAAC,CAAC;IACzD,CAAC;IAED;;;OAGG;IACH,mBAAmB;QACjB,MAAM,MAAM,GAAG,IAAI,GAAG,EAA+B,CAAC;QACtD,KAAK,MAAM,CAAC,IAAI,EAAE,OAAO,CAAC,IAAI,IAAI,CAAC,QAAQ,EAAE;YAC3C,MAAM,CAAC,GAAG,CAAC,IAAI,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC;SACjC;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;OAEG;IACH,gBAAgB;QACd,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;QACtB,OAAO,CAAC,KAAK,CAAC,sBAAsB,CAAC,CAAC;IACxC,CAAC;IAEO,kBAAkB,CACxB,WAAmB,EACnB,MAA+B;QAE/B,IAAI,OAAO,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;QAE7C,IAAI,CAAC,OAAO,EAAE;YACZ,OAAO,GAAG;gBACR,IAAI,EAAE,WAAW;gBACjB,KAAK,EAAE,mBAAmB,CAAC,MAAM;gBACjC,MAAM,EAAE,EAAE,GAAG,IAAI,CAAC,aAAa,EAAE,GAAG,MAAM,EAAE;gBAC5C,YAAY,EAAE,CAAC;gBACf,YAAY,EAAE,CAAC;gBACf,eAAe,EAAE,CAAC;gBAClB,eAAe,EAAE,CAAC;gBAClB,eAAe,EAAE,IAAI,CAAC,GAAG,EAAE;gBAC3B,mBAAmB,EAAE,CAAC;gBACtB,aAAa,EAAE,EAAE;aAClB,CAAC;YAEF,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;YACxC,OAAO,CAAC,KAAK,CAAC,wBAAwB,WAAW,EAAE,CAAC,CAAC;SACtD;QAED,OAAO,OAAO,CAAC;IACjB,CAAC;IAEO,iBAAiB,CAAC,OAAqB;QAI7C,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QAEvB,QAAQ,OAAO,CAAC,KAAK,EAAE;YACrB,KAAK,mBAAmB,CAAC,MAAM;gBAC7B,OAAO,EAAE,UAAU,EAAE,IAAI,EAAE,MAAM,EAAE,EAAE,EAAE,CAAC;YAE1C,KAAK,mBAAmB,CAAC,IAAI;gBAC3B,IAAI,GAAG,GAAG,OAAO,CAAC,eAAe,IAAI,OAAO,CAAC,MAAM,CAAC,YAAY,EAAE;oBAChE,0BAA0B;oBAC1B,OAAO,CAAC,KAAK,GAAG,mBAAmB,CAAC,SAAS,CAAC;oBAC9C,OAAO,CAAC,eAAe,GAAG,GAAG,CAAC;oBAC9B,OAAO,CAAC,IAAI,CAAC,WAAW,OAAO,CAAC,IAAI,4BAA4B,CAAC,CAAC;oBAClE,OAAO,EAAE,UAAU,EAAE,IAAI,EAAE,MAAM,EAAE,EAAE,EAAE,CAAC;iBACzC;gBACD,OAAO;oBACL,UAAU,EAAE,KAAK;oBACjB,MAAM,EAAE,WAAW,OAAO,CAAC,IAAI,0BAC7B,IAAI,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,YAAY,GAAG,CAAC,GAAG,GAAG,OAAO,CAAC,eAAe,CAAC,CAAC,GAAG,IAAI,CAClF,UAAU;iBACX,CAAC;YAEJ,KAAK,mBAAmB,CAAC,SAAS;gBAChC,yCAAyC;gBACzC,MAAM,WAAW,GAAG,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;gBACjD,IAAI,WAAW,GAAG,OAAO,CAAC,MAAM,CAAC,gBAAgB,EAAE;oBACjD,OAAO,EAAE,UAAU,EAAE,IAAI,EAAE,MAAM,EAAE,EAAE,EAAE,CAAC;iBACzC;gBACD,OAAO;oBACL,UAAU,EAAE,KAAK;oBACjB,MAAM,EAAE,WAAW,OAAO,CAAC,IAAI,sCAAsC;iBACtE,CAAC;YAEJ;gBACE,OAAO,EAAE,UAAU,EAAE,IAAI,EAAE,MAAM,EAAE,EAAE,EAAE,CAAC;SAC3C;IACH,CAAC;IAEO,aAAa,CAAC,OAAqB,EAAE,QAAgB;QAC3D,OAAO,CAAC,YAAY,EAAE,CAAC;QACvB,OAAO,CAAC,eAAe,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACrC,IAAI,CAAC,kBAAkB,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;QAE3C,IAAI,OAAO,CAAC,KAAK,KAAK,mBAAmB,CAAC,SAAS,EAAE;YACnD,iDAAiD;YACjD,OAAO,CAAC,KAAK,GAAG,mBAAmB,CAAC,MAAM,CAAC;YAC3C,OAAO,CAAC,YAAY,GAAG,CAAC,CAAC;YACzB,OAAO,CAAC,eAAe,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;YACrC,OAAO,CAAC,IAAI,CAAC,WAAW,OAAO,CAAC,IAAI,yCAAyC,CAAC,CAAC;SAChF;IACH,CAAC;IAEO,aAAa,CAAC,OAAqB,EAAE,KAAa,EAAE,QAAgB;QAC1E,OAAO,CAAC,YAAY,EAAE,CAAC;QACvB,OAAO,CAAC,eAAe,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACrC,IAAI,CAAC,kBAAkB,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;QAE3C,OAAO,CAAC,IAAI,CAAC,WAAW,OAAO,CAAC,IAAI,YAAY,OAAO,CAAC,YAAY,KAAK,KAAK,EAAE,CAAC,CAAC;QAElF,sCAAsC;QACtC,IACE,OAAO,CAAC,KAAK,KAAK,mBAAmB,CAAC,MAAM;YAC5C,OAAO,CAAC,YAAY,IAAI,OAAO,CAAC,MAAM,CAAC,gBAAgB,EACvD;YACA,OAAO,CAAC,KAAK,GAAG,mBAAmB,CAAC,IAAI,CAAC;YACzC,OAAO,CAAC,eAAe,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;YACrC,OAAO,CAAC,KAAK,CAAC,WAAW,OAAO,CAAC,IAAI,kBAAkB,OAAO,CAAC,YAAY,WAAW,CAAC,CAAC;SACzF;aAAM,IAAI,OAAO,CAAC,KAAK,KAAK,mBAAmB,CAAC,SAAS,EAAE;YAC1D,kDAAkD;YAClD,OAAO,CAAC,KAAK,GAAG,mBAAmB,CAAC,IAAI,CAAC;YACzC,OAAO,CAAC,eAAe,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;YACrC,OAAO,CAAC,KAAK,CAAC,WAAW,OAAO,CAAC,IAAI,mCAAmC,CAAC,CAAC;SAC3E;IACH,CAAC;IAEO,kBAAkB,CAAC,OAAqB,EAAE,QAAgB;QAChE,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAErC,0DAA0D;QAC1D,MAAM,UAAU,GAAG,GAAG,CAAC;QACvB,IAAI,OAAO,CAAC,aAAa,CAAC,MAAM,GAAG,UAAU,EAAE;YAC7C,OAAO,CAAC,aAAa,GAAG,OAAO,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,UAAU,CAAC,CAAC;SAClE;QAED,2BAA2B;QAC3B,OAAO,CAAC,mBAAmB;YACzB,OAAO,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,IAAI,EAAE,EAAE,CAAC,GAAG,GAAG,IAAI,EAAE,CAAC,CAAC;gBAC1D,OAAO,CAAC,aAAa,CAAC,MAAM,CAAC;IACjC,CAAC;IAEO,cAAc,CAAC,OAAqB;QAC1C,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACvB,MAAM,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC,gBAAgB,CAAC;QAE/C,+EAA+E;QAC/E,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,OAAO,CAAC,YAAY,GAAG,OAAO,CAAC,YAAY;YAC5D,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,GAAG,OAAO,CAAC,eAAe,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC;IAC1D,CAAC;IAEO,eAAe,CAAC,OAAqB;QAC3C,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,OAAO,CAAC,eAAe,CAAC;QACvD,IAAI,SAAS,KAAK,CAAC;YAAE,OAAO,GAAG,CAAC;QAEhC,sEAAsE;QACtE,MAAM,QAAQ,GAAG,OAAO,CAAC,KAAK,KAAK,mBAAmB,CAAC,IAAI,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;QAC5E,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,SAAS,GAAG,QAAQ,CAAC,GAAG,SAAS,CAAC,GAAG,GAAG,CAAC,CAAC;IACjE,CAAC;IAEO,iBAAiB;QACvB,mCAAmC;QACnC,IAAI,OAAO,WAAW,KAAK,WAAW,EAAE;YACtC,WAAW,CAAC,GAAG,EAAE;gBACf,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;gBACvB,MAAM,MAAM,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC,SAAS;gBAExC,KAAK,MAAM,CAAC,IAAI,EAAE,OAAO,CAAC,IAAI,IAAI,CAAC,QAAQ,EAAE;oBAC3C,IAAI,GAAG,GAAG,OAAO,CAAC,eAAe,GAAG,MAAM;wBACtC,OAAO,CAAC,YAAY,KAAK,CAAC;wBAC1B,OAAO,CAAC,YAAY,KAAK,CAAC,EAAE;wBAC9B,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;wBAC3B,OAAO,CAAC,KAAK,CAAC,gCAAgC,IAAI,EAAE,CAAC,CAAC;qBACvD;iBACF;YACH,CAAC,EAAE,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC;SACpB;IACH,CAAC;;AA5SH,sDA6SC;AA5SgB,8BAAQ,GAAiC,IAAI,CAAC;AA8S/D,IAAY,mBAIX;AAJD,WAAY,mBAAmB;IAC7B,wCAAiB,CAAA;IACjB,oCAAa,CAAA;IACb,8CAAuB,CAAA;AACzB,CAAC,EAJW,mBAAmB,GAAnB,2BAAmB,KAAnB,2BAAmB,QAI9B","names":[],"sources":["/Users/kitelev/Documents/exocortex-obsidian-plugin/src/infrastructure/resilience/CircuitBreakerService.ts"],"sourcesContent":["import { Result } from \"../../domain/core/Result\";\n\n/**\n * Circuit breaker implementation for resilient asset creation\n * Prevents cascade failures and provides graceful degradation\n */\nexport class CircuitBreakerService {\n  private static instance: CircuitBreakerService | null = null;\n  private circuits = new Map<string, CircuitState>();\n  private readonly defaultConfig: CircuitConfig = {\n    failureThreshold: 5,\n    resetTimeout: 60000, // 1 minute\n    monitoringPeriod: 10000, // 10 seconds\n    halfOpenMaxCalls: 3,\n  };\n\n  private constructor() {\n    this.setupCleanupTimer();\n  }\n\n  static getInstance(): CircuitBreakerService {\n    if (!CircuitBreakerService.instance) {\n      CircuitBreakerService.instance = new CircuitBreakerService();\n    }\n    return CircuitBreakerService.instance;\n  }\n\n  /**\n   * Executes an operation with circuit breaker protection\n   * @param circuitName Unique identifier for the circuit\n   * @param operation The operation to execute\n   * @param config Optional circuit configuration\n   * @returns Result of the operation or circuit breaker response\n   */\n  async execute<T>(\n    circuitName: string,\n    operation: () => Promise<Result<T>>,\n    config?: Partial<CircuitConfig>,\n  ): Promise<Result<T>> {\n    const circuit = this.getOrCreateCircuit(circuitName, config);\n\n    // Check circuit state\n    const stateCheck = this.checkCircuitState(circuit);\n    if (!stateCheck.canExecute) {\n      return Result.fail<T>(stateCheck.reason);\n    }\n\n    const startTime = Date.now();\n\n    try {\n      // Execute the operation\n      const result = await operation();\n      const duration = Date.now() - startTime;\n\n      if (result.isSuccess) {\n        this.recordSuccess(circuit, duration);\n      } else {\n        this.recordFailure(circuit, result.getError(), duration);\n      }\n\n      return result;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      \n      this.recordFailure(circuit, errorMessage, duration);\n      return Result.fail<T>(`Circuit breaker caught error: ${errorMessage}`);\n    }\n  }\n\n  /**\n   * Gets current state of a circuit\n   * @param circuitName The circuit to check\n   * @returns Current circuit state\n   */\n  getCircuitState(circuitName: string): CircuitBreakerState {\n    const circuit = this.circuits.get(circuitName);\n    if (!circuit) {\n      return CircuitBreakerState.CLOSED;\n    }\n\n    return circuit.state;\n  }\n\n  /**\n   * Gets circuit statistics for monitoring\n   * @param circuitName The circuit to get stats for\n   * @returns Circuit statistics or null if not found\n   */\n  getCircuitStats(circuitName: string): CircuitStats | null {\n    const circuit = this.circuits.get(circuitName);\n    if (!circuit) {\n      return null;\n    }\n\n    return {\n      circuitName,\n      state: circuit.state,\n      failureCount: circuit.failureCount,\n      successCount: circuit.successCount,\n      lastFailureTime: circuit.lastFailureTime,\n      lastSuccessTime: circuit.lastSuccessTime,\n      averageResponseTime: circuit.averageResponseTime,\n      totalCalls: circuit.successCount + circuit.failureCount,\n      uptime: this.calculateUptime(circuit),\n    };\n  }\n\n  /**\n   * Manually opens a circuit (for testing or emergency)\n   * @param circuitName The circuit to open\n   */\n  openCircuit(circuitName: string): void {\n    const circuit = this.getOrCreateCircuit(circuitName);\n    circuit.state = CircuitBreakerState.OPEN;\n    circuit.lastStateChange = Date.now();\n    console.warn(`Circuit ${circuitName} manually opened`);\n  }\n\n  /**\n   * Manually closes a circuit (resets it)\n   * @param circuitName The circuit to close\n   */\n  closeCircuit(circuitName: string): void {\n    const circuit = this.getOrCreateCircuit(circuitName);\n    circuit.state = CircuitBreakerState.CLOSED;\n    circuit.failureCount = 0;\n    circuit.lastStateChange = Date.now();\n    console.info(`Circuit ${circuitName} manually closed`);\n  }\n\n  /**\n   * Gets all circuit names and their states\n   * @returns Map of circuit names to states\n   */\n  getAllCircuitStates(): Map<string, CircuitBreakerState> {\n    const states = new Map<string, CircuitBreakerState>();\n    for (const [name, circuit] of this.circuits) {\n      states.set(name, circuit.state);\n    }\n    return states;\n  }\n\n  /**\n   * Clears all circuit data (for testing)\n   */\n  clearAllCircuits(): void {\n    this.circuits.clear();\n    console.debug(\"All circuits cleared\");\n  }\n\n  private getOrCreateCircuit(\n    circuitName: string,\n    config?: Partial<CircuitConfig>,\n  ): CircuitState {\n    let circuit = this.circuits.get(circuitName);\n    \n    if (!circuit) {\n      circuit = {\n        name: circuitName,\n        state: CircuitBreakerState.CLOSED,\n        config: { ...this.defaultConfig, ...config },\n        failureCount: 0,\n        successCount: 0,\n        lastFailureTime: 0,\n        lastSuccessTime: 0,\n        lastStateChange: Date.now(),\n        averageResponseTime: 0,\n        responseTimes: [],\n      };\n      \n      this.circuits.set(circuitName, circuit);\n      console.debug(`Created new circuit: ${circuitName}`);\n    }\n    \n    return circuit;\n  }\n\n  private checkCircuitState(circuit: CircuitState): {\n    canExecute: boolean;\n    reason: string;\n  } {\n    const now = Date.now();\n\n    switch (circuit.state) {\n      case CircuitBreakerState.CLOSED:\n        return { canExecute: true, reason: \"\" };\n\n      case CircuitBreakerState.OPEN:\n        if (now - circuit.lastStateChange >= circuit.config.resetTimeout) {\n          // Transition to half-open\n          circuit.state = CircuitBreakerState.HALF_OPEN;\n          circuit.lastStateChange = now;\n          console.info(`Circuit ${circuit.name} transitioned to HALF_OPEN`);\n          return { canExecute: true, reason: \"\" };\n        }\n        return {\n          canExecute: false,\n          reason: `Circuit ${circuit.name} is OPEN. Try again in ${\n            Math.ceil((circuit.config.resetTimeout - (now - circuit.lastStateChange)) / 1000)\n          } seconds`,\n        };\n\n      case CircuitBreakerState.HALF_OPEN:\n        // Allow limited calls in half-open state\n        const recentCalls = this.getRecentCalls(circuit);\n        if (recentCalls < circuit.config.halfOpenMaxCalls) {\n          return { canExecute: true, reason: \"\" };\n        }\n        return {\n          canExecute: false,\n          reason: `Circuit ${circuit.name} is HALF_OPEN with max calls reached`,\n        };\n\n      default:\n        return { canExecute: true, reason: \"\" };\n    }\n  }\n\n  private recordSuccess(circuit: CircuitState, duration: number): void {\n    circuit.successCount++;\n    circuit.lastSuccessTime = Date.now();\n    this.updateResponseTime(circuit, duration);\n\n    if (circuit.state === CircuitBreakerState.HALF_OPEN) {\n      // Success in half-open state - close the circuit\n      circuit.state = CircuitBreakerState.CLOSED;\n      circuit.failureCount = 0;\n      circuit.lastStateChange = Date.now();\n      console.info(`Circuit ${circuit.name} closed after successful half-open test`);\n    }\n  }\n\n  private recordFailure(circuit: CircuitState, error: string, duration: number): void {\n    circuit.failureCount++;\n    circuit.lastFailureTime = Date.now();\n    this.updateResponseTime(circuit, duration);\n\n    console.warn(`Circuit ${circuit.name} failure ${circuit.failureCount}: ${error}`);\n\n    // Check if we should open the circuit\n    if (\n      circuit.state === CircuitBreakerState.CLOSED &&\n      circuit.failureCount >= circuit.config.failureThreshold\n    ) {\n      circuit.state = CircuitBreakerState.OPEN;\n      circuit.lastStateChange = Date.now();\n      console.error(`Circuit ${circuit.name} opened due to ${circuit.failureCount} failures`);\n    } else if (circuit.state === CircuitBreakerState.HALF_OPEN) {\n      // Failure in half-open state - reopen the circuit\n      circuit.state = CircuitBreakerState.OPEN;\n      circuit.lastStateChange = Date.now();\n      console.error(`Circuit ${circuit.name} reopened after half-open failure`);\n    }\n  }\n\n  private updateResponseTime(circuit: CircuitState, duration: number): void {\n    circuit.responseTimes.push(duration);\n    \n    // Keep only recent response times for average calculation\n    const maxSamples = 100;\n    if (circuit.responseTimes.length > maxSamples) {\n      circuit.responseTimes = circuit.responseTimes.slice(-maxSamples);\n    }\n    \n    // Calculate moving average\n    circuit.averageResponseTime = \n      circuit.responseTimes.reduce((sum, time) => sum + time, 0) / \n      circuit.responseTimes.length;\n  }\n\n  private getRecentCalls(circuit: CircuitState): number {\n    const now = Date.now();\n    const period = circuit.config.monitoringPeriod;\n    \n    // This is simplified - in a real implementation, you'd track actual call times\n    return Math.max(0, circuit.successCount + circuit.failureCount - \n      Math.floor((now - circuit.lastStateChange) / period));\n  }\n\n  private calculateUptime(circuit: CircuitState): number {\n    const totalTime = Date.now() - circuit.lastStateChange;\n    if (totalTime === 0) return 100;\n    \n    // Simplified calculation - in reality you'd track open/closed periods\n    const openTime = circuit.state === CircuitBreakerState.OPEN ? totalTime : 0;\n    return Math.max(0, ((totalTime - openTime) / totalTime) * 100);\n  }\n\n  private setupCleanupTimer(): void {\n    // Clean up old circuits every hour\n    if (typeof setInterval !== 'undefined') {\n      setInterval(() => {\n        const now = Date.now();\n        const maxAge = 60 * 60 * 1000; // 1 hour\n        \n        for (const [name, circuit] of this.circuits) {\n          if (now - circuit.lastStateChange > maxAge && \n              circuit.successCount === 0 && \n              circuit.failureCount === 0) {\n            this.circuits.delete(name);\n            console.debug(`Cleaned up inactive circuit: ${name}`);\n          }\n        }\n      }, 60 * 60 * 1000);\n    }\n  }\n}\n\nexport enum CircuitBreakerState {\n  CLOSED = \"CLOSED\",\n  OPEN = \"OPEN\", \n  HALF_OPEN = \"HALF_OPEN\",\n}\n\nexport interface CircuitConfig {\n  failureThreshold: number;\n  resetTimeout: number;\n  monitoringPeriod: number;\n  halfOpenMaxCalls: number;\n}\n\ninterface CircuitState {\n  name: string;\n  state: CircuitBreakerState;\n  config: CircuitConfig;\n  failureCount: number;\n  successCount: number;\n  lastFailureTime: number;\n  lastSuccessTime: number;\n  lastStateChange: number;\n  averageResponseTime: number;\n  responseTimes: number[];\n}\n\nexport interface CircuitStats {\n  circuitName: string;\n  state: CircuitBreakerState;\n  failureCount: number;\n  successCount: number;\n  lastFailureTime: number;\n  lastSuccessTime: number;\n  averageResponseTime: number;\n  totalCalls: number;\n  uptime: number;\n}"],"version":3}