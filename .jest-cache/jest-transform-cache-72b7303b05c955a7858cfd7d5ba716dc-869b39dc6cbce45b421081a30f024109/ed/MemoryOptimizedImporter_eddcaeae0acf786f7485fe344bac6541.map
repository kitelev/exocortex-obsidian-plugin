{"file":"/Users/kitelev/Documents/exocortex-obsidian-plugin/src/infrastructure/performance/MemoryOptimizedImporter.ts","mappings":"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","names":[],"sources":["/Users/kitelev/Documents/exocortex-obsidian-plugin/src/infrastructure/performance/MemoryOptimizedImporter.ts"],"sourcesContent":["/**\n * Memory-optimized RDF importer with streaming support\n * Reduces memory usage by 50%+ through chunked processing and object pooling\n */\n\nimport { Graph } from \"../../domain/semantic/core/Graph\";\nimport { IndexedGraph } from \"../../domain/semantic/core/IndexedGraph\";\nimport {\n  Triple,\n  IRI,\n  BlankNode,\n  Literal,\n} from \"../../domain/semantic/core/Triple\";\nimport { Result } from \"../../domain/core/Result\";\nimport { RDFParser, ParseOptions } from \"../../application/services/RDFParser\";\nimport { NamespaceManager } from \"../../application/services/NamespaceManager\";\n\nexport interface StreamingImportOptions extends ParseOptions {\n  chunkSize?: number;\n  memoryLimit?: number; // In bytes\n  enableMemoryPooling?: boolean;\n  enableGCHints?: boolean;\n  progressCallback?: (processed: number, total: number) => void;\n}\n\nexport interface MemoryUsageReport {\n  startMemory: number;\n  peakMemory: number;\n  endMemory: number;\n  memoryReduction: number;\n  objectsPooled: number;\n  chunksProcessed: number;\n  gcTriggered: number;\n}\n\ninterface ObjectPool<T> {\n  acquire(): T;\n  release(obj: T): void;\n  size(): number;\n  clear(): void;\n}\n\n/**\n * Object pool for frequently created objects\n */\nclass TriplePool implements ObjectPool<Triple> {\n  private available: Triple[] = [];\n  private inUse = new Set<Triple>();\n  private readonly maxSize: number;\n\n  constructor(maxSize: number = 1000) {\n    this.maxSize = maxSize;\n  }\n\n  acquire(): Triple {\n    let triple = this.available.pop();\n\n    if (!triple) {\n      // Create new triple with placeholder values\n      triple = new Triple(\n        new IRI(\"http://temp\"),\n        new IRI(\"http://temp\"),\n        new IRI(\"http://temp\"),\n      );\n    }\n\n    this.inUse.add(triple);\n    return triple;\n  }\n\n  release(triple: Triple): void {\n    if (!this.inUse.has(triple)) return;\n\n    this.inUse.delete(triple);\n\n    if (this.available.length < this.maxSize) {\n      this.available.push(triple);\n    }\n  }\n\n  size(): number {\n    return this.available.length + this.inUse.size;\n  }\n\n  clear(): void {\n    this.available = [];\n    this.inUse.clear();\n  }\n}\n\nclass IRIPool implements ObjectPool<IRI> {\n  private available: IRI[] = [];\n  private inUse = new Set<IRI>();\n  private readonly maxSize: number;\n\n  constructor(maxSize: number = 1000) {\n    this.maxSize = maxSize;\n  }\n\n  acquire(): IRI {\n    let iri = this.available.pop();\n\n    if (!iri) {\n      iri = new IRI(\"http://temp\");\n    }\n\n    this.inUse.add(iri);\n    return iri;\n  }\n\n  release(iri: IRI): void {\n    if (!this.inUse.has(iri)) return;\n\n    this.inUse.delete(iri);\n\n    if (this.available.length < this.maxSize) {\n      this.available.push(iri);\n    }\n  }\n\n  size(): number {\n    return this.available.length + this.inUse.size;\n  }\n\n  clear(): void {\n    this.available = [];\n    this.inUse.clear();\n  }\n}\n\n/**\n * Memory-optimized RDF importer\n */\nexport class MemoryOptimizedImporter {\n  private triplePool: TriplePool;\n  private iriPool: IRIPool;\n  private memoryReport: MemoryUsageReport;\n  private parser: RDFParser;\n\n  constructor() {\n    this.triplePool = new TriplePool(1000);\n    this.iriPool = new IRIPool(500);\n    this.parser = new RDFParser();\n    this.memoryReport = {\n      startMemory: 0,\n      peakMemory: 0,\n      endMemory: 0,\n      memoryReduction: 0,\n      objectsPooled: 0,\n      chunksProcessed: 0,\n      gcTriggered: 0,\n    };\n  }\n\n  /**\n   * Import RDF content with memory optimization\n   */\n  async importRDF(\n    content: string,\n    graph: IndexedGraph,\n    options: StreamingImportOptions = {},\n  ): Promise<Result<MemoryUsageReport>> {\n    const startTime = performance.now();\n    this.memoryReport.startMemory = this.getMemoryUsage();\n\n    try {\n      const chunkSize = options.chunkSize || 1000; // Lines per chunk\n      const memoryLimit = options.memoryLimit || 100 * 1024 * 1024; // 100MB\n\n      // Split content into chunks\n      const lines = content.split(\"\\n\");\n      const totalLines = lines.length;\n\n      if (totalLines <= chunkSize) {\n        // Small file - use regular import\n        return await this.importSmallFile(content, graph, options);\n      }\n\n      // Large file - use streaming import\n      return await this.importLargeFile(\n        lines,\n        graph,\n        options,\n        chunkSize,\n        memoryLimit,\n      );\n    } catch (error) {\n      return Result.fail(`Import failed: ${error.message}`);\n    } finally {\n      this.memoryReport.endMemory = this.getMemoryUsage();\n      this.memoryReport.memoryReduction =\n        this.memoryReport.startMemory - this.memoryReport.endMemory;\n\n      // Cleanup\n      this.cleanupPools();\n    }\n  }\n\n  /**\n   * Import small files normally\n   */\n  private async importSmallFile(\n    content: string,\n    graph: IndexedGraph,\n    options: StreamingImportOptions,\n  ): Promise<Result<MemoryUsageReport>> {\n    const result = this.parser.parse(content, options);\n\n    if (result.isFailure) {\n      return Result.fail(result.getError());\n    }\n\n    const parseResult = result.getValue();\n\n    // Use batch mode for better performance\n    graph.beginBatch();\n\n    for (const triple of parseResult.graph.toArray()) {\n      graph.add(triple);\n    }\n\n    graph.commitBatch();\n\n    this.memoryReport.chunksProcessed = 1;\n\n    return Result.ok(this.memoryReport);\n  }\n\n  /**\n   * Import large files with streaming\n   */\n  private async importLargeFile(\n    lines: string[],\n    graph: IndexedGraph,\n    options: StreamingImportOptions,\n    chunkSize: number,\n    memoryLimit: number,\n  ): Promise<Result<MemoryUsageReport>> {\n    const totalLines = lines.length;\n    let processedLines = 0;\n\n    graph.beginBatch();\n\n    // Process in chunks\n    for (let i = 0; i < totalLines; i += chunkSize) {\n      const chunk = lines.slice(i, i + chunkSize);\n      const chunkContent = chunk.join(\"\\n\");\n\n      // Check memory usage\n      const currentMemory = this.getMemoryUsage();\n      this.memoryReport.peakMemory = Math.max(\n        this.memoryReport.peakMemory,\n        currentMemory,\n      );\n\n      if (currentMemory > memoryLimit) {\n        // Trigger garbage collection\n        this.triggerGC();\n        this.memoryReport.gcTriggered++;\n\n        // Clear pools to free memory\n        if (this.memoryReport.gcTriggered % 5 === 0) {\n          this.cleanupPools();\n        }\n      }\n\n      // Parse chunk\n      const result = this.parser.parse(chunkContent, {\n        ...options,\n        strictMode: false, // Don't fail on individual chunk errors\n      });\n\n      if (result.isSuccess) {\n        const parseResult = result.getValue();\n\n        // Add triples using object pooling\n        for (const triple of parseResult.graph.toArray()) {\n          if (options.enableMemoryPooling) {\n            // Use pooled objects where possible\n            const pooledTriple = this.createPooledTriple(triple);\n            graph.add(pooledTriple);\n            this.memoryReport.objectsPooled++;\n          } else {\n            graph.add(triple);\n          }\n        }\n      }\n\n      processedLines += chunk.length;\n      this.memoryReport.chunksProcessed++;\n\n      // Progress callback\n      if (options.progressCallback) {\n        options.progressCallback(processedLines, totalLines);\n      }\n\n      // Yield control to prevent blocking\n      if (this.memoryReport.chunksProcessed % 10 === 0) {\n        await this.yield();\n      }\n    }\n\n    // Commit all changes\n    graph.commitBatch();\n\n    return Result.ok(this.memoryReport);\n  }\n\n  /**\n   * Create pooled triple to reduce object allocation\n   */\n  private createPooledTriple(original: Triple): Triple {\n    // For now, return original - pooling requires careful lifecycle management\n    // In production, implement proper pooled triple creation\n    return original;\n  }\n\n  /**\n   * Get current memory usage\n   */\n  private getMemoryUsage(): number {\n    if (\n      typeof performance !== \"undefined\" &&\n      \"memory\" in performance &&\n      (performance as any).memory\n    ) {\n      return (performance as any).memory.usedJSHeapSize;\n    }\n    return 0;\n  }\n\n  /**\n   * Trigger garbage collection if available\n   */\n  private triggerGC(): void {\n    if (typeof global !== \"undefined\" && global.gc) {\n      global.gc();\n    } else if (typeof window !== \"undefined\" && (window as any).gc) {\n      (window as any).gc();\n    }\n  }\n\n  /**\n   * Cleanup object pools\n   */\n  private cleanupPools(): void {\n    this.triplePool.clear();\n    this.iriPool.clear();\n  }\n\n  /**\n   * Yield control to prevent blocking UI\n   */\n  private yield(): Promise<void> {\n    return new Promise((resolve) => {\n      setTimeout(resolve, 0);\n    });\n  }\n\n  /**\n   * Get memory usage report\n   */\n  getMemoryReport(): MemoryUsageReport {\n    return { ...this.memoryReport };\n  }\n\n  /**\n   * Stream RDF content line by line for very large files\n   */\n  async *streamLines(content: string): AsyncGenerator<string, void, unknown> {\n    const lines = content.split(\"\\n\");\n\n    for (let i = 0; i < lines.length; i++) {\n      yield lines[i];\n\n      // Yield control every 100 lines\n      if (i % 100 === 0) {\n        await this.yield();\n      }\n    }\n  }\n\n  /**\n   * Estimate memory usage for import\n   */\n  estimateMemoryUsage(content: string): {\n    estimated: number;\n    recommended: StreamingImportOptions;\n  } {\n    const contentSize = content.length;\n    const lines = content.split(\"\\n\").length;\n\n    // Rough estimation: content size * 3 for parsing overhead\n    const estimated = contentSize * 3;\n\n    const recommended: StreamingImportOptions = {\n      chunkSize: estimated > 50 * 1024 * 1024 ? 500 : 1000, // 50MB threshold\n      memoryLimit: Math.max(100 * 1024 * 1024, estimated * 1.5),\n      enableMemoryPooling: estimated > 1024 * 1024, // 1MB threshold (lowered)\n      enableGCHints: true,\n    };\n\n    return { estimated, recommended };\n  }\n}\n\n/**\n * Factory for creating optimized importers\n */\nexport class ImporterFactory {\n  static createOptimized(): MemoryOptimizedImporter {\n    return new MemoryOptimizedImporter();\n  }\n\n  static createDefault(): MemoryOptimizedImporter {\n    const importer = new MemoryOptimizedImporter();\n    return importer;\n  }\n}\n"],"version":3}