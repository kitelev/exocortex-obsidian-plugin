{"file":"/Users/kitelev/Documents/exocortex-obsidian-plugin/src/shared/utils/FileOperationUtils.ts","mappings":"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","names":[],"sources":["/Users/kitelev/Documents/exocortex-obsidian-plugin/src/shared/utils/FileOperationUtils.ts"],"sourcesContent":["import { App, TFile } from \"obsidian\";\n\n/**\n * Common file operation utilities to eliminate duplication across repositories\n * Implements DRY principle for file handling, YAML processing, and frontmatter operations\n */\nexport class FileOperationUtils {\n  /**\n   * Build YAML frontmatter with consistent formatting\n   */\n  static buildYamlFrontmatter(frontmatter: Record<string, any>): string[] {\n    const yamlLines = [\"---\"];\n\n    for (const [key, value] of Object.entries(frontmatter)) {\n      if (value === undefined || value === null) continue;\n\n      if (Array.isArray(value)) {\n        yamlLines.push(`${key}:`);\n        for (const item of value) {\n          const itemStr = String(item);\n          if (this.needsQuotes(itemStr)) {\n            yamlLines.push(`  - \"${this.escapeQuotes(itemStr)}\"`);\n          } else {\n            yamlLines.push(`  - ${itemStr}`);\n          }\n        }\n      } else if (typeof value === \"object\" && value !== null) {\n        yamlLines.push(`${key}: ${JSON.stringify(value)}`);\n      } else if (typeof value === \"boolean\" || typeof value === \"number\") {\n        yamlLines.push(`${key}: ${value}`);\n      } else {\n        const valueStr = String(value);\n        if (this.needsQuotes(valueStr)) {\n          yamlLines.push(`${key}: \"${this.escapeQuotes(valueStr)}\"`);\n        } else {\n          yamlLines.push(`${key}: ${valueStr}`);\n        }\n      }\n    }\n\n    yamlLines.push(\"---\");\n    return yamlLines;\n  }\n\n  /**\n   * Check if string value needs quotes in YAML\n   */\n  private static needsQuotes(valueStr: string): boolean {\n    return (\n      (valueStr.includes(\"[[\") && valueStr.includes(\"]]\")) ||\n      valueStr.includes(\":\") ||\n      valueStr.includes(\"#\") ||\n      valueStr.includes(\"[\") ||\n      valueStr.includes(\"]\") ||\n      valueStr.includes(\"{\") ||\n      valueStr.includes(\"}\") ||\n      valueStr.includes(\"|\") ||\n      valueStr.includes(\">\") ||\n      valueStr.includes(\"@\") ||\n      valueStr.includes(\"`\") ||\n      valueStr.includes('\"') ||\n      valueStr.includes(\"'\") ||\n      valueStr.startsWith(\" \") ||\n      valueStr.endsWith(\" \")\n    );\n  }\n\n  /**\n   * Escape quotes in string values\n   */\n  private static escapeQuotes(valueStr: string): string {\n    return valueStr.replace(/\"/g, '\\\\\"');\n  }\n\n  /**\n   * Extract body content from file, preserving content after frontmatter\n   */\n  static extractBodyContent(content: string): string {\n    if (content.startsWith(\"---\\n\")) {\n      const endOfFrontmatter = content.indexOf(\"\\n---\\n\", 4);\n      if (endOfFrontmatter !== -1) {\n        return content.substring(endOfFrontmatter + 5);\n      } else {\n        // Malformed frontmatter, preserve original content\n        return content;\n      }\n    } else {\n      // No frontmatter, entire content is body\n      return content;\n    }\n  }\n\n  /**\n   * Find file by multiple criteria with fallback logic\n   */\n  static findFileWithFallback(\n    app: App,\n    criteria: {\n      uid?: string;\n      storedPath?: string;\n      filename?: string;\n    },\n  ): TFile | null {\n    // First check if asset has a stored file path\n    if (criteria.storedPath) {\n      const file = app.vault.getAbstractFileByPath(criteria.storedPath);\n      if (file instanceof TFile) {\n        return file;\n      }\n    }\n\n    // If not found by stored path, try by asset ID\n    if (criteria.uid) {\n      const files = app.vault.getMarkdownFiles();\n      for (const file of files) {\n        const cache = app.metadataCache.getFileCache(file);\n        if (cache?.frontmatter?.[\"exo__Asset_uid\"] === criteria.uid) {\n          return file;\n        }\n      }\n    }\n\n    // If not found by ID, try by filename\n    if (criteria.filename) {\n      const fileName = criteria.filename.endsWith(\".md\")\n        ? criteria.filename\n        : `${criteria.filename}.md`;\n      const file = app.vault.getAbstractFileByPath(fileName);\n      if (file instanceof TFile) {\n        return file;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Update file with new frontmatter and preserve body content\n   */\n  static async updateFileWithFrontmatter(\n    app: App,\n    file: TFile,\n    frontmatter: Record<string, any>,\n  ): Promise<void> {\n    const existingContent = await app.vault.read(file);\n    const bodyContent = this.extractBodyContent(existingContent);\n    const yamlLines = this.buildYamlFrontmatter(frontmatter);\n    const newContent = yamlLines.join(\"\\n\") + \"\\n\" + bodyContent;\n\n    await app.vault.modify(file, newContent);\n  }\n\n  /**\n   * Create new file with frontmatter\n   */\n  static async createFileWithFrontmatter(\n    app: App,\n    filename: string,\n    frontmatter: Record<string, any>,\n  ): Promise<void> {\n    const yamlLines = this.buildYamlFrontmatter(frontmatter);\n    const content = yamlLines.join(\"\\n\") + \"\\n\";\n    await app.vault.create(filename, content);\n  }\n\n  /**\n   * Get files filtered by frontmatter property\n   */\n  static getFilesWithProperty(\n    app: App,\n    propertyKey: string,\n    propertyValue?: any,\n  ): TFile[] {\n    const files = app.vault.getMarkdownFiles();\n    return files.filter((file) => {\n      const cache = app.metadataCache.getFileCache(file);\n      const frontmatter = cache?.frontmatter;\n\n      if (!frontmatter || !frontmatter[propertyKey]) {\n        return false;\n      }\n\n      if (propertyValue === undefined) {\n        return true; // Just check property exists\n      }\n\n      return frontmatter[propertyKey] === propertyValue;\n    });\n  }\n\n  /**\n   * Merge frontmatter updates with existing frontmatter\n   */\n  static mergeFrontmatter(\n    existing: Record<string, any>,\n    updates: Record<string, any>,\n  ): Record<string, any> {\n    return { ...existing, ...updates };\n  }\n\n  /**\n   * Check if reference matches current asset in various formats\n   */\n  static isReferencingAsset(referenceValue: any, assetName: string): boolean {\n    if (!referenceValue) return false;\n\n    // Handle both string and array formats\n    const refs = Array.isArray(referenceValue)\n      ? referenceValue\n      : [referenceValue];\n\n    return refs.some((ref) => {\n      const cleanRef = String(ref).replace(/\\[\\[|\\]\\]/g, \"\");\n\n      // Match against various possible reference formats\n      return (\n        cleanRef === assetName ||\n        cleanRef === `${assetName}.md` ||\n        ref.includes(`[[${assetName}]]`) ||\n        ref.includes(assetName)\n      );\n    });\n  }\n}\n"],"version":3}