{"file":"/Users/kitelev/Documents/exocortex-obsidian-plugin/src/presentation/factories/BlockRendererFactory.ts","mappings":";;;AAEA,qDAAkD;AAMlD,8FAA2F;AAE3F,iEAAiE;AACjE,MAAM,oBAAoB;IACxB,YACmB,cAAmB,EACnB,SAAoB;QADpB,mBAAc,GAAd,cAAc,CAAK;QACnB,cAAS,GAAT,SAAS,CAAW;IACpC,CAAC;IAEJ,KAAK,CAAC,MAAM,CAAC,OAA8B;QACzC,IAAI;YACF,iDAAiD;YACjD,MAAM,IAAI,CAAC,cAAc,CAAC,MAAM,CAC9B,OAAO,CAAC,SAAS,EACjB,OAAO,CAAC,MAAM,EACd,OAAO,CAAC,IAAI,EACZ,OAAO,CAAC,WAAW,EACnB,OAAO,CAAC,WAAW,CACpB,CAAC;YACF,OAAO,eAAM,CAAC,EAAE,EAAE,CAAC;SACpB;QAAC,OAAO,KAAK,EAAE;YACd,OAAO,eAAM,CAAC,IAAI,CAChB,8BAA8B,IAAI,CAAC,SAAS,KAAK,KAAK,EAAE,CACzD,CAAC;SACH;IACH,CAAC;CACF;AAED,MAAa,oBAAoB;IAG/B,YAA6B,GAAQ;QAAR,QAAG,GAAH,GAAG,CAAK;QAFpB,cAAS,GAAwB,IAAI,GAAG,EAAE,CAAC;QAG1D,6CAA6C;QAC7C,IAAI,CAAC,SAAS,CAAC,GAAG,CAChB,mBAAmB,EACnB,IAAI,6DAA6B,CAAC,GAAG,CAAC,CACvC,CAAC;IACJ,CAAC;IAED,cAAc,CAAC,SAAoB;QACjC,MAAM,cAAc,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;QAErD,IAAI,CAAC,cAAc,EAAE;YACnB,OAAO,eAAM,CAAC,IAAI,CAAC,qCAAqC,SAAS,EAAE,CAAC,CAAC;SACtE;QAED,oCAAoC;QACpC,MAAM,OAAO,GAAG,IAAI,oBAAoB,CAAC,cAAc,EAAE,SAAS,CAAC,CAAC;QACpE,OAAO,eAAM,CAAC,EAAE,CAAC,OAAO,CAAC,CAAC;IAC5B,CAAC;IAED,sBAAsB;QACpB,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC,CAAC;IAC3C,CAAC;IAED,iDAAiD;IACjD,gBAAgB,CAAC,SAAoB,EAAE,QAAa;QAClD,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;IAC1C,CAAC;IAED,uCAAuC;IACvC,kBAAkB,CAAC,SAAoB;QACrC,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;IAC1C,CAAC;CACF;AApCD,oDAoCC","names":[],"sources":["/Users/kitelev/Documents/exocortex-obsidian-plugin/src/presentation/factories/BlockRendererFactory.ts"],"sourcesContent":["import { App } from \"obsidian\";\nimport { BlockType } from \"../../domain/entities/LayoutBlock\";\nimport { Result } from \"../../domain/core/Result\";\nimport {\n  IBlockRendererFactory,\n  IBlockRenderer,\n  BlockRenderingContext,\n} from \"./IBlockRendererFactory\";\nimport { DynamicBacklinksBlockRenderer } from \"../renderers/DynamicBacklinksBlockRenderer\";\n\n// Adapter pattern to bridge old block renderers to new interface\nclass BlockRendererAdapter implements IBlockRenderer {\n  constructor(\n    private readonly legacyRenderer: any,\n    private readonly blockType: BlockType,\n  ) {}\n\n  async render(context: BlockRenderingContext): Promise<Result<void>> {\n    try {\n      // Adapt new context to legacy renderer interface\n      await this.legacyRenderer.render(\n        context.container,\n        context.config,\n        context.file,\n        context.frontmatter,\n        context.dataviewApi,\n      );\n      return Result.ok();\n    } catch (error) {\n      return Result.fail(\n        `Block rendering failed for ${this.blockType}: ${error}`,\n      );\n    }\n  }\n}\n\nexport class BlockRendererFactory implements IBlockRendererFactory {\n  private readonly renderers: Map<BlockType, any> = new Map();\n\n  constructor(private readonly app: App) {\n    // Initialize only dynamic backlinks renderer\n    this.renderers.set(\n      \"dynamic-backlinks\",\n      new DynamicBacklinksBlockRenderer(app),\n    );\n  }\n\n  createRenderer(blockType: BlockType): Result<IBlockRenderer> {\n    const legacyRenderer = this.renderers.get(blockType);\n\n    if (!legacyRenderer) {\n      return Result.fail(`No renderer found for block type: ${blockType}`);\n    }\n\n    // Wrap legacy renderer with adapter\n    const adapter = new BlockRendererAdapter(legacyRenderer, blockType);\n    return Result.ok(adapter);\n  }\n\n  getSupportedBlockTypes(): BlockType[] {\n    return Array.from(this.renderers.keys());\n  }\n\n  // Allow runtime registration of custom renderers\n  registerRenderer(blockType: BlockType, renderer: any): void {\n    this.renderers.set(blockType, renderer);\n  }\n\n  // Remove renderer (useful for testing)\n  unregisterRenderer(blockType: BlockType): boolean {\n    return this.renderers.delete(blockType);\n  }\n}\n"],"version":3}