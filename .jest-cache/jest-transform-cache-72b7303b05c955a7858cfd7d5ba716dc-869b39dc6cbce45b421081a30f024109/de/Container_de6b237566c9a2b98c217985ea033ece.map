{"file":"/Users/kitelev/Documents/exocortex-obsidian-plugin/src/application/core/Container.ts","mappings":";;;AAAA;;;GAGG;AACH,MAAa,SAAS;IAKpB;QAHQ,aAAQ,GAAqB,IAAI,GAAG,EAAE,CAAC;QACvC,cAAS,GAA2B,IAAI,GAAG,EAAE,CAAC;IAE/B,CAAC;IAEjB,MAAM,CAAC,WAAW;QACvB,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE;YACvB,SAAS,CAAC,QAAQ,GAAG,IAAI,SAAS,EAAE,CAAC;SACtC;QACD,OAAO,SAAS,CAAC,QAAQ,CAAC;IAC5B,CAAC;IAED;;OAEG;IACI,QAAQ,CAAI,KAAa,EAAE,OAAgB;QAChD,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;IACrC,CAAC;IAED;;OAEG;IACI,iBAAiB,CAAI,KAAa,EAAE,OAAU;QACnD,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;IACpC,CAAC;IAED;;OAEG;IACI,OAAO,CAAI,KAAa;QAC7B,+BAA+B;QAC/B,IAAI,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;YAC5B,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;SACjC;QAED,6BAA6B;QAC7B,IAAI,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;YAC7B,MAAM,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;YAC1C,IAAI,OAAO,EAAE;gBACX,MAAM,OAAO,GAAG,OAAO,EAAE,CAAC;gBAE1B,gCAAgC;gBAChC,qCAAqC;gBAErC,OAAO,OAAO,CAAC;aAChB;SACF;QAED,MAAM,IAAI,KAAK,CAAC,sBAAsB,KAAK,EAAE,CAAC,CAAC;IACjD,CAAC;IAED;;OAEG;IACI,GAAG,CAAC,KAAa;QACtB,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;IAC/D,CAAC;IAED;;OAEG;IACI,KAAK;QACV,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;QACtB,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC;IACzB,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,KAAK;QACjB,IAAI,SAAS,CAAC,QAAQ,EAAE;YACtB,SAAS,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;YAC3B,SAAS,CAAC,QAAQ,GAAG,IAAW,CAAC;SAClC;IACH,CAAC;CACF;AA7ED,8BA6EC","names":[],"sources":["/Users/kitelev/Documents/exocortex-obsidian-plugin/src/application/core/Container.ts"],"sourcesContent":["/**\n * Simple Dependency Injection Container\n * Following Inversion of Control principle\n */\nexport class Container {\n  private static instance: Container;\n  private services: Map<string, any> = new Map();\n  private factories: Map<string, () => any> = new Map();\n\n  private constructor() {}\n\n  public static getInstance(): Container {\n    if (!Container.instance) {\n      Container.instance = new Container();\n    }\n    return Container.instance;\n  }\n\n  /**\n   * Register a service factory\n   */\n  public register<T>(token: string, factory: () => T): void {\n    this.factories.set(token, factory);\n  }\n\n  /**\n   * Register a singleton service\n   */\n  public registerSingleton<T>(token: string, service: T): void {\n    this.services.set(token, service);\n  }\n\n  /**\n   * Resolve a service\n   */\n  public resolve<T>(token: string): T {\n    // Check if we have a singleton\n    if (this.services.has(token)) {\n      return this.services.get(token);\n    }\n\n    // Check if we have a factory\n    if (this.factories.has(token)) {\n      const factory = this.factories.get(token);\n      if (factory) {\n        const service = factory();\n\n        // Optionally cache as singleton\n        // this.services.set(token, service);\n\n        return service;\n      }\n    }\n\n    throw new Error(`Service not found: ${token}`);\n  }\n\n  /**\n   * Check if a service is registered\n   */\n  public has(token: string): boolean {\n    return this.services.has(token) || this.factories.has(token);\n  }\n\n  /**\n   * Clear all registrations\n   */\n  public clear(): void {\n    this.services.clear();\n    this.factories.clear();\n  }\n\n  /**\n   * Reset the container instance (for testing)\n   */\n  public static reset(): void {\n    if (Container.instance) {\n      Container.instance.clear();\n      Container.instance = null as any;\n    }\n  }\n}\n"],"version":3}