{"file":"/Users/kitelev/Documents/exocortex-obsidian-plugin/src/application/services/DynamicBacklinksService.ts","mappings":"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","names":[],"sources":["/Users/kitelev/Documents/exocortex-obsidian-plugin/src/application/services/DynamicBacklinksService.ts"],"sourcesContent":["import { Result } from \"../../domain/core/Result\";\nimport { IVaultAdapter } from \"../ports/IVaultAdapter\";\nimport { IUIAdapter } from \"../ports/IUIAdapter\";\n\nexport interface PropertyBasedBacklink {\n  propertyName: string;\n  referencingFiles: any[];\n}\n\nexport interface BacklinkDiscoveryOptions {\n  excludeProperties?: string[];\n  maxResultsPerProperty?: number;\n  filterByClass?: string;\n}\n\nexport class DynamicBacklinksService {\n  constructor(\n    private vaultAdapter: IVaultAdapter,\n    private uiAdapter: IUIAdapter,\n  ) {}\n\n  async discoverPropertyBasedBacklinks(\n    targetFile: any,\n    options: BacklinkDiscoveryOptions = {},\n  ): Promise<Result<PropertyBasedBacklink[]>> {\n    try {\n      const propertyBacklinks = new Map<string, any[]>();\n\n      // Scan all markdown files in the vault\n      const allFiles = await this.vaultAdapter.getFiles();\n\n      for (const file of allFiles) {\n        if (file.path === targetFile.path) continue; // Skip self-references\n\n        const metadata = await this.vaultAdapter.getFileMetadata(file);\n        if (!metadata) continue;\n\n        // Filter by class if specified\n        if (options.filterByClass) {\n          const instanceClass = this.uiAdapter.cleanClassName(\n            metadata[\"exo__Instance_class\"],\n          );\n          if (instanceClass !== options.filterByClass) continue;\n        }\n\n        // Check each frontmatter property for references to target file\n        for (const [propertyName, value] of Object.entries(metadata)) {\n          // Skip excluded properties\n          if (options.excludeProperties?.includes(propertyName)) continue;\n\n          if (await this.isReferencingTarget(value, targetFile)) {\n            if (!propertyBacklinks.has(propertyName)) {\n              propertyBacklinks.set(propertyName, []);\n            }\n            propertyBacklinks.get(propertyName)!.push(file);\n          }\n        }\n      }\n\n      // Convert to result format and apply limits\n      const results: PropertyBasedBacklink[] = [];\n      for (const [propertyName, files] of propertyBacklinks.entries()) {\n        const limitedFiles = options.maxResultsPerProperty\n          ? files.slice(0, options.maxResultsPerProperty)\n          : files;\n\n        results.push({\n          propertyName,\n          referencingFiles: limitedFiles,\n        });\n      }\n\n      // Sort by property name for consistent ordering\n      results.sort((a, b) => a.propertyName.localeCompare(b.propertyName));\n\n      return Result.ok(results);\n    } catch (error) {\n      return Result.fail(`Failed to discover backlinks: ${error}`);\n    }\n  }\n\n  private async isReferencingTarget(value: any, targetFile: any): Promise<boolean> {\n    if (!value) return false;\n\n    // Handle arrays\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        if (await this.isReferencingTarget(item, targetFile)) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    // Convert to string and check various reference formats\n    const strValue = value.toString();\n    const targetFileName =\n      targetFile.basename || targetFile.name?.replace(/\\.[^/.]+$/, \"\") || \"\";\n    const targetPath = targetFile.path || targetFile.name || \"\";\n\n    // Get target file's UUID for UUID-based matching\n    const targetMetadata = await this.vaultAdapter.getFileMetadata(targetFile);\n    const targetUuid = targetMetadata?.[\"exo__Asset_uid\"] || null;\n\n    // Direct basename match\n    if (strValue === targetFileName) return true;\n\n    // Wiki-link format exact match\n    if (strValue.includes(`[[${targetFileName}]]`)) return true;\n\n    // Wiki-link with display text\n    if (strValue.includes(`[[${targetFileName}|`)) return true;\n\n    // Path-based matching for references like [[Area - My]]\n    if (strValue.startsWith(\"[[\") && strValue.endsWith(\"]]\")) {\n      const linkText = strValue.slice(2, -2).split(\"|\")[0]; // Remove [[ ]] and display text\n\n      // Try to resolve the link to see if it points to our target file\n      if (this.vaultAdapter.resolveLinkToFile) {\n        try {\n          const resolvedFile = await this.vaultAdapter.resolveLinkToFile(linkText);\n          if (resolvedFile && resolvedFile.path === targetFile.path) {\n            return true;\n          }\n        } catch (error) {\n          // Ignore resolution errors and fall back to text matching\n        }\n      }\n\n      if (linkText === targetFileName) return true;\n\n      // Also check if the link text partially matches the target filename\n      if (\n        targetFileName.includes(linkText) ||\n        linkText.includes(targetFileName)\n      )\n        return true;\n    }\n\n    // UUID-based matching\n    if (targetUuid && strValue.includes(targetUuid)) return true;\n\n    // Partial match within string (for composite references)\n    if (strValue.includes(targetFileName)) return true;\n\n    return false;\n  }\n\n  private cleanClassName(className: any): string {\n    if (!className) return \"\";\n    const str = Array.isArray(className) ? className[0] : className;\n    return str?.toString().replace(/\\[\\[|\\]\\]/g, \"\") || \"\";\n  }\n}\n"],"version":3}