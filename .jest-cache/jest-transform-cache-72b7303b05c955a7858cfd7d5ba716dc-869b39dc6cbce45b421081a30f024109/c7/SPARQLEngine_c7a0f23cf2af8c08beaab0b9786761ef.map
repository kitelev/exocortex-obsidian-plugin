{"file":"/Users/kitelev/Documents/exocortex-obsidian-plugin/src/application/SPARQLEngine.ts","mappings":";;;AACA,2DAKwC;AACxC,sDAAqE;AAarE,MAAa,YAAY;IAGvB,YACU,KAAY,EACpB,WAAuC;QAD/B,UAAK,GAAL,KAAK,CAAO;QAGpB,IAAI,CAAC,UAAU,GAAG,IAAI,uBAAU,CAAC,WAAW,CAAC,CAAC;IAChD,CAAC;IAED;;OAEG;IACH,SAAS,CAAC,KAAa;QACrB,oBAAoB;QACpB,MAAM,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,aAAa,KAAK,EAAE,CAAC,CAAC;QACtE,MAAM,YAAY,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,CAAkB,QAAQ,CAAC,CAAC;QAEpE,IAAI,YAAY,EAAE;YAChB,OAAO,EAAE,GAAG,YAAY,EAAE,MAAM,EAAE,IAAI,EAAE,CAAC;SAC1C;QACD,wBAAwB;QACxB,MAAM,cAAc,GAAG,KAAK,CAAC,KAAK,CAChC,6CAA6C,CAC9C,CAAC;QACF,IAAI,CAAC,cAAc,EAAE;YACnB,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAC;SACnD;QAED,MAAM,QAAQ,GAAG,IAAI,CAAC,sBAAsB,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;QAChE,MAAM,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;QAEvD,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;YACzB,OAAO;gBACL,OAAO,EAAE,EAAE;gBACX,UAAU,EAAE,sBAAsB,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE,EAAE;aAC7D,CAAC;SACH;QAED,MAAM,gBAAgB,GAAa,EAAE,CAAC;QAEtC,8CAA8C;QAC9C,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;YACzB,+BAA+B;YAC/B,MAAM,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;YAE5B,8EAA8E;YAC9E,MAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC;gBAC7C,CAAC,CAAC,IAAI;gBACN,CAAC,CAAC,IAAI,YAAG,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC,CAAC;YACnD,MAAM,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC,UAAU,CAAC,GAAG,CAAC;gBACjD,CAAC,CAAC,IAAI;gBACN,CAAC,CAAC,IAAI,YAAG,CAAC,OAAO,CAAC,SAAS,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC,CAAC;YACrD,MAAM,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC;gBAC3C,CAAC,CAAC,IAAI;gBACN,CAAC,CAAC,IAAI,CAAC,sBAAsB,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;YAEhD,MAAM,cAAc,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,OAAO,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;YAEpE,KAAK,MAAM,MAAM,IAAI,cAAc,EAAE;gBACnC,MAAM,OAAO,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;gBACpD,MAAM,UAAU,GAAG,IAAI,CAAC,mBAAmB,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;gBAC/D,gBAAgB,CAAC,IAAI,CAAC,GAAG,UAAU,CAAC,CAAC;aACtC;SACF;aAAM;YACL,4CAA4C;YAC5C,MAAM,QAAQ,GAAG,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;YAEnD,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE;gBAC9B,MAAM,UAAU,GAAG,IAAI,CAAC,mBAAmB,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;gBAC/D,gBAAgB,CAAC,IAAI,CAAC,GAAG,UAAU,CAAC,CAAC;aACtC;SACF;QAED,yBAAyB;QACzB,MAAM,UAAU,GAAG,KAAK,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAC;QACjD,IAAI,MAAuB,CAAC;QAE5B,IAAI,UAAU,EAAE;YACd,MAAM,KAAK,GAAG,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;YACtC,MAAM,GAAG;gBACP,OAAO,EAAE,gBAAgB,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC;gBACzC,UAAU,EAAE,sBAAsB,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE,EAAE;gBAC5D,MAAM,EAAE,KAAK;aACd,CAAC;SACH;aAAM;YACL,MAAM,GAAG;gBACP,OAAO,EAAE,gBAAgB;gBACzB,UAAU,EAAE,sBAAsB,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE,EAAE;gBAC5D,MAAM,EAAE,KAAK;aACd,CAAC;SACH;QAED,mBAAmB;QACnB,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;QAEtC,OAAO,MAAM,CAAC;IAChB,CAAC;IAEO,sBAAsB,CAAC,cAAsB;QACnD,MAAM,SAAS,GAAU,EAAE,CAAC;QAC5B,yEAAyE;QACzE,MAAM,KAAK,GAAG,cAAc,CAAC,IAAI,EAAE,CAAC,KAAK,CAAC,kBAAkB,CAAC,CAAC;QAE9D,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;YACxB,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC;YAC5B,IAAI,CAAC,OAAO;gBAAE,SAAS;YAEvB,MAAM,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;YACnC,IAAI,KAAK,CAAC,MAAM,IAAI,CAAC,EAAE;gBACrB,+BAA+B;gBAC/B,IAAI,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;gBACtC,SAAS,CAAC,IAAI,CAAC;oBACb,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;oBACjB,SAAS,EAAE,KAAK,CAAC,CAAC,CAAC;oBACnB,MAAM,EAAE,MAAM;iBACf,CAAC,CAAC;aACJ;SACF;QAED,OAAO,SAAS,CAAC;IACnB,CAAC;IAEO,aAAa,CAAC,OAAY,EAAE,MAAc;QAChD,MAAM,OAAO,GAA2B,EAAE,CAAC;QAE3C,IAAI,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE;YACnC,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,gBAAgB,CAC3D,MAAM,CAAC,UAAU,EAAE,CACpB,CAAC;SACH;QACD,IAAI,OAAO,CAAC,SAAS,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE;YACrC,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,gBAAgB,CAC7D,MAAM,CAAC,YAAY,EAAE,CACtB,CAAC;SACH;QACD,IAAI,OAAO,CAAC,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE;YAClC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,gBAAgB,CAC1D,MAAM,CAAC,SAAS,EAAE,CACnB,CAAC;SACH;QAED,OAAO,OAAO,CAAC;IACjB,CAAC;IAEO,gBAAgB,CAAC,IAAS;QAChC,6DAA6D;QAC7D,OAAO,IAAI,CAAC,QAAQ,EAAE,CAAC;IACzB,CAAC;IAEO,mBAAmB,CACzB,QAAe,EACf,OAA+B;QAE/B,MAAM,OAAO,GAAa,EAAE,CAAC;QAE7B,KAAK,MAAM,CAAC,IAAI,QAAQ,EAAE;YACxB,MAAM,UAAU,GAAG,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;YACzD,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;YAC7D,MAAM,SAAS,GAAG,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;YAEvD,IAAI,UAAU,IAAI,YAAY,IAAI,SAAS,EAAE;gBAC3C,+BAA+B;gBAC/B,MAAM,OAAO,GAAG,UAAU,CAAC,UAAU,CAAC,IAAI,CAAC;oBACzC,CAAC,CAAC,IAAI,kBAAS,CAAC,UAAU,CAAC;oBAC3B,CAAC,CAAC,IAAI,YAAG,CAAC,UAAU,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC,CAAC;gBAC9C,MAAM,SAAS,GAAG,IAAI,YAAG,CAAC,YAAY,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC,CAAC;gBAE9D,gCAAgC;gBAChC,IAAI,MAAiC,CAAC;gBACtC,IAAI,SAAS,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE;oBAC7B,6DAA6D;oBAC7D,MAAM,GAAG,gBAAO,CAAC,MAAM,CAAC,SAAS,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC,CAAC;iBAC1D;qBAAM,IAAI,SAAS,KAAK,MAAM,IAAI,SAAS,KAAK,OAAO,EAAE;oBACxD,kBAAkB;oBAClB,MAAM,GAAG,gBAAO,CAAC,OAAO,CAAC,SAAS,KAAK,MAAM,CAAC,CAAC;iBAChD;qBAAM,IAAI,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE;oBACrC,aAAa;oBACb,MAAM,GAAG,IAAI,kBAAS,CAAC,SAAS,CAAC,CAAC;iBACnC;qBAAM,IAAI,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE;oBAClC,kBAAkB;oBAClB,MAAM,GAAG,gBAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC;iBAC/C;qBAAM,IAAI,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE;oBACvC,iBAAiB;oBACjB,MAAM,GAAG,gBAAO,CAAC,MAAM,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,CAAC;iBAChD;qBAAM;oBACL,MAAM;oBACN,MAAM,GAAG,IAAI,YAAG,CAAC,SAAS,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC,CAAC;iBACnD;gBAED,OAAO,CAAC,IAAI,CAAC,IAAI,eAAM,CAAC,OAAO,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC,CAAC;aACtD;SACF;QAED,OAAO,OAAO,CAAC;IACjB,CAAC;IAEO,YAAY,CAClB,KAAa,EACb,OAA+B;QAE/B,IAAI,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE;YACzB,MAAM,OAAO,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;YACnC,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,IAAI,CAAC;SACjC;QACD,OAAO,KAAK,CAAC;IACf,CAAC;IAEO,kBAAkB,CAAC,QAAe;QACxC,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC;YAAE,OAAO,EAAE,CAAC;QAErC,2BAA2B;QAC3B,MAAM,YAAY,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;QACjC,MAAM,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CACnC,YAAY,CAAC,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC;YAClC,CAAC,CAAC,IAAI;YACN,CAAC,CAAC,IAAI,YAAG,CAAC,YAAY,CAAC,OAAO,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC,EACvD,YAAY,CAAC,SAAS,CAAC,UAAU,CAAC,GAAG,CAAC;YACpC,CAAC,CAAC,IAAI;YACN,CAAC,CAAC,IAAI,YAAG,CAAC,YAAY,CAAC,SAAS,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC,EACzD,YAAY,CAAC,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC;YACjC,CAAC,CAAC,IAAI;YACN,CAAC,CAAC,YAAY,CAAC,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC;gBACnC,CAAC,CAAC,IAAI,gBAAO,CAAC,YAAY,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;gBACxD,CAAC,CAAC,IAAI,YAAG,CAAC,YAAY,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC,CACzD,CAAC;QAEF,IAAI,QAAQ,GAA6B,EAAE,CAAC;QAC5C,KAAK,MAAM,MAAM,IAAI,YAAY,EAAE;YACjC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,YAAY,EAAE,MAAM,CAAC,CAAC,CAAC;SACzD;QAED,gCAAgC;QAChC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACxC,MAAM,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;YAC5B,MAAM,WAAW,GAA6B,EAAE,CAAC;YAEjD,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE;gBAC9B,uCAAuC;gBACvC,MAAM,UAAU,GAAG,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC;oBAChD,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI;oBAC/C,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC;gBACpB,MAAM,YAAY,GAAG,OAAO,CAAC,SAAS,CAAC,UAAU,CAAC,GAAG,CAAC;oBACpD,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI;oBACjD,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC;gBACtB,MAAM,SAAS,GAAG,OAAO,CAAC,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC;oBAC9C,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI;oBAC9C,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC;gBAEnB,4CAA4C;gBAC5C,MAAM,OAAO,GAAG,UAAU;oBACxB,CAAC,CAAC,IAAI,YAAG,CAAC,UAAU,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;oBAC3C,CAAC,CAAC,IAAI,CAAC;gBACT,MAAM,SAAS,GAAG,YAAY;oBAC5B,CAAC,CAAC,IAAI,YAAG,CAAC,YAAY,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;oBAC7C,CAAC,CAAC,IAAI,CAAC;gBACT,MAAM,MAAM,GAAG,SAAS;oBACtB,CAAC,CAAC,IAAI,CAAC,sBAAsB,CAAC,SAAS,CAAC;oBACxC,CAAC,CAAC,IAAI,CAAC;gBAET,wBAAwB;gBACxB,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,OAAO,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;gBAE7D,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;oBAC5B,MAAM,eAAe,GAAG,EAAE,GAAG,OAAO,EAAE,CAAC;oBAEvC,4BAA4B;oBAC5B,IAAI,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,EAAE;wBAClD,eAAe,CAAC,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;4BAC3C,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,UAAU,EAAE,CAAC,CAAC;qBAC9C;oBACD,IAAI,OAAO,CAAC,SAAS,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,YAAY,EAAE;wBACtD,eAAe,CAAC,OAAO,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;4BAC7C,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,YAAY,EAAE,CAAC,CAAC;qBAChD;oBACD,IAAI,OAAO,CAAC,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,EAAE;wBAChD,eAAe,CAAC,OAAO,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;4BAC1C,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,SAAS,EAAE,CAAC,CAAC;qBAC7C;oBAED,WAAW,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;iBACnC;aACF;YAED,QAAQ,GAAG,WAAW,CAAC;SACxB;QAED,OAAO,QAAQ,CAAC;IAClB,CAAC;IAED,MAAM,CAAC,KAAa;QAClB,oBAAoB;QACpB,MAAM,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,UAAU,KAAK,EAAE,CAAC,CAAC;QACnE,MAAM,YAAY,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,CAAe,QAAQ,CAAC,CAAC;QAEjE,IAAI,YAAY,EAAE;YAChB,OAAO,EAAE,GAAG,YAAY,EAAE,MAAM,EAAE,IAAI,EAAE,CAAC;SAC1C;QAED,qDAAqD;QACrD,MAAM,WAAW,GAAG,KAAK,CAAC,KAAK,CAAC,sCAAsC,CAAC,CAAC;QACxE,IAAI,CAAC,WAAW,EAAE;YAChB,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;SAChD;QAED,MAAM,SAAS,GAAG,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;QACtD,MAAM,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;QAEpD,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;YACzB,MAAM,WAAW,GAAiB,EAAE,OAAO,EAAE,EAAE,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC;YACjE,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;YAC3C,OAAO,WAAW,CAAC;SACpB;QAED,IAAI,OAAO,GAAU,EAAE,CAAC;QAExB,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;YACzB,+BAA+B;YAC/B,MAAM,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;YAE5B,oDAAoD;YACpD,MAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC;gBAC7C,CAAC,CAAC,IAAI;gBACN,CAAC,CAAC,IAAI,YAAG,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC,CAAC;YACnD,MAAM,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC,UAAU,CAAC,GAAG,CAAC;gBACjD,CAAC,CAAC,IAAI;gBACN,CAAC,CAAC,IAAI,YAAG,CAAC,OAAO,CAAC,SAAS,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC,CAAC;YACrD,MAAM,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC;gBAC3C,CAAC,CAAC,IAAI;gBACN,CAAC,CAAC,IAAI,CAAC,sBAAsB,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;YAEhD,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,OAAO,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;YAE7D,iBAAiB;YACjB,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;gBAC5B,MAAM,OAAO,GAAQ,EAAE,CAAC;gBAExB,IAAI,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE;oBACnC,MAAM,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;oBAC7C,IAAI,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,SAAS,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE;wBAC1D,OAAO,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,UAAU,EAAE,CAAC,CAAC;qBAC/D;iBACF;gBAED,IAAI,OAAO,CAAC,SAAS,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE;oBACrC,MAAM,OAAO,GAAG,OAAO,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;oBAC/C,IAAI,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,SAAS,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE;wBAC1D,OAAO,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,YAAY,EAAE,CAAC,CAAC;qBACjE;iBACF;gBAED,IAAI,OAAO,CAAC,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE;oBAClC,MAAM,OAAO,GAAG,OAAO,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;oBAC5C,IAAI,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,SAAS,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE;wBAC1D,OAAO,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,SAAS,EAAE,CAAC,CAAC;qBAC9D;iBACF;gBAED,IAAI,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,MAAM,GAAG,CAAC,EAAE;oBACnC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;iBACvB;aACF;SACF;aAAM;YACL,4CAA4C;YAC5C,MAAM,QAAQ,GAAG,IAAI,CAAC,2BAA2B,CAAC,QAAQ,CAAC,CAAC;YAE5D,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE;gBAC9B,MAAM,eAAe,GAAQ,EAAE,CAAC;gBAEhC,mCAAmC;gBACnC,KAAK,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;oBAClD,IAAI,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;wBACtD,eAAe,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;qBAC9B;iBACF;gBAED,IAAI,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,MAAM,GAAG,CAAC,EAAE;oBAC3C,OAAO,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;iBAC/B;aACF;SACF;QAED,yBAAyB;QACzB,MAAM,UAAU,GAAG,KAAK,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAC;QACjD,IAAI,MAAoB,CAAC;QAEzB,IAAI,UAAU,EAAE;YACd,MAAM,KAAK,GAAG,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;YACtC,MAAM,GAAG,EAAE,OAAO,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC;SAC9D;aAAM;YACL,MAAM,GAAG,EAAE,OAAO,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC;SACrC;QAED,mBAAmB;QACnB,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;QAEtC,OAAO,MAAM,CAAC;IAChB,CAAC;IAEO,cAAc,CAAC,YAAoB;QACzC,MAAM,OAAO,GAAG,YAAY,CAAC,IAAI,EAAE,CAAC;QACpC,IAAI,OAAO,KAAK,GAAG,EAAE;YACnB,OAAO,CAAC,GAAG,CAAC,CAAC;SACd;QAED,MAAM,SAAS,GAAa,EAAE,CAAC;QAC/B,MAAM,UAAU,GAAG,UAAU,CAAC;QAC9B,IAAI,KAAK,CAAC;QACV,OAAO,CAAC,KAAK,GAAG,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,KAAK,IAAI,EAAE;YAClD,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;SAC1B;QACD,OAAO,SAAS,CAAC;IACnB,CAAC;IAEO,sBAAsB,CAAC,SAAiB;QAC9C,IAAI,SAAS,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE;YAC7B,6DAA6D;YAC7D,MAAM,OAAO,GAAG,SAAS,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;YAChD,OAAO,gBAAO,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;SAChC;aAAM;YACL,cAAc;YACd,OAAO,IAAI,YAAG,CAAC,SAAS,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC,CAAC;SACjD;IACH,CAAC;IAEO,2BAA2B,CACjC,QAAe;QAEf,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC;YAAE,OAAO,EAAE,CAAC;QAErC,2BAA2B;QAC3B,MAAM,YAAY,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;QACjC,MAAM,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CACnC,YAAY,CAAC,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC;YAClC,CAAC,CAAC,IAAI;YACN,CAAC,CAAC,IAAI,YAAG,CAAC,YAAY,CAAC,OAAO,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC,EACvD,YAAY,CAAC,SAAS,CAAC,UAAU,CAAC,GAAG,CAAC;YACpC,CAAC,CAAC,IAAI;YACN,CAAC,CAAC,IAAI,YAAG,CAAC,YAAY,CAAC,SAAS,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC,EACzD,YAAY,CAAC,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC;YACjC,CAAC,CAAC,IAAI;YACN,CAAC,CAAC,IAAI,CAAC,sBAAsB,CAAC,YAAY,CAAC,MAAM,CAAC,CACrD,CAAC;QAEF,IAAI,QAAQ,GAA6B,EAAE,CAAC;QAC5C,KAAK,MAAM,MAAM,IAAI,YAAY,EAAE;YACjC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,YAAY,EAAE,MAAM,CAAC,CAAC,CAAC;SACzD;QAED,gCAAgC;QAChC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACxC,MAAM,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;YAC5B,MAAM,WAAW,GAA6B,EAAE,CAAC;YAEjD,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE;gBAC9B,uCAAuC;gBACvC,MAAM,UAAU,GAAG,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC;oBAChD,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI;oBAC/C,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC;gBACpB,MAAM,YAAY,GAAG,OAAO,CAAC,SAAS,CAAC,UAAU,CAAC,GAAG,CAAC;oBACpD,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI;oBACjD,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC;gBACtB,MAAM,SAAS,GAAG,OAAO,CAAC,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC;oBAC9C,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI;oBAC9C,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC;gBAEnB,4CAA4C;gBAC5C,MAAM,OAAO,GAAG,UAAU;oBACxB,CAAC,CAAC,IAAI,YAAG,CAAC,UAAU,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;oBAC3C,CAAC,CAAC,IAAI,CAAC;gBACT,MAAM,SAAS,GAAG,YAAY;oBAC5B,CAAC,CAAC,IAAI,YAAG,CAAC,YAAY,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;oBAC7C,CAAC,CAAC,IAAI,CAAC;gBACT,MAAM,MAAM,GAAG,SAAS;oBACtB,CAAC,CAAC,IAAI,CAAC,sBAAsB,CAAC,SAAS,CAAC;oBACxC,CAAC,CAAC,IAAI,CAAC;gBAET,wBAAwB;gBACxB,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,OAAO,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC;gBAE7D,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;oBAC5B,MAAM,eAAe,GAAG,EAAE,GAAG,OAAO,EAAE,CAAC;oBAEvC,4BAA4B;oBAC5B,IAAI,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,EAAE;wBAClD,eAAe,CAAC,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;4BAC3C,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,UAAU,EAAE,CAAC,CAAC;qBAC9C;oBACD,IAAI,OAAO,CAAC,SAAS,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,YAAY,EAAE;wBACtD,eAAe,CAAC,OAAO,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;4BAC7C,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,YAAY,EAAE,CAAC,CAAC;qBAChD;oBACD,IAAI,OAAO,CAAC,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,EAAE;wBAChD,eAAe,CAAC,OAAO,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;4BAC1C,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,SAAS,EAAE,CAAC,CAAC;qBAC7C;oBAED,WAAW,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;iBACnC;aACF;YAED,QAAQ,GAAG,WAAW,CAAC;SACxB;QAED,OAAO,QAAQ,CAAC;IAClB,CAAC;IAEO,aAAa,CAAC,WAAmB;QACvC,MAAM,QAAQ,GAAU,EAAE,CAAC;QAE3B,mDAAmD;QACnD,yEAAyE;QACzE,MAAM,KAAK,GAAG,WAAW,CAAC,IAAI,EAAE,CAAC,KAAK,CAAC,kBAAkB,CAAC,CAAC;QAE3D,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;YACxB,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,EAAE,CAAC;YAC5B,IAAI,CAAC,OAAO;gBAAE,SAAS;YAEvB,oCAAoC;YACpC,MAAM,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;YACnC,IAAI,KAAK,CAAC,MAAM,IAAI,CAAC,EAAE;gBACrB,QAAQ,CAAC,IAAI,CAAC;oBACZ,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;oBACjB,SAAS,EAAE,KAAK,CAAC,CAAC,CAAC;oBACnB,MAAM,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,kCAAkC;iBACrE,CAAC,CAAC;aACJ;SACF;QAED,OAAO,QAAQ,CAAC;IAClB,CAAC;IAED;;OAEG;IACH,kBAAkB;QAChB,OAAO,IAAI,CAAC,UAAU,CAAC,aAAa,EAAE,CAAC;IACzC,CAAC;IAED;;OAEG;IACH,eAAe;QACb,IAAI,CAAC,UAAU,CAAC,aAAa,EAAE,CAAC;IAClC,CAAC;IAED;;OAEG;IACH,iBAAiB,CAAC,MAAiC;QACjD,IAAI,CAAC,UAAU,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;IACvC,CAAC;IAED;;OAEG;IACH,cAAc;QACZ,OAAO,IAAI,CAAC,UAAU,CAAC,SAAS,EAAE,CAAC;IACrC,CAAC;IAED;;OAEG;IACH,YAAY;QACV,OAAO,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE,CAAC;IACnC,CAAC;IAED;;OAEG;IACH,OAAO;QACL,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE,CAAC;IAC5B,CAAC;CACF;AA7jBD,oCA6jBC","names":[],"sources":["/Users/kitelev/Documents/exocortex-obsidian-plugin/src/application/SPARQLEngine.ts"],"sourcesContent":["import { Graph } from \"../domain/semantic/core/Graph\";\nimport {\n  Triple,\n  IRI,\n  Literal,\n  BlankNode,\n} from \"../domain/semantic/core/Triple\";\nimport { QueryCache, QueryCacheConfig } from \"./services/QueryCache\";\n\nexport interface ConstructResult {\n  triples: Triple[];\n  provenance: string;\n  cached?: boolean;\n}\n\nexport interface SelectResult {\n  results: any[];\n  cached?: boolean;\n}\n\nexport class SPARQLEngine {\n  private queryCache: QueryCache;\n\n  constructor(\n    private graph: Graph,\n    cacheConfig?: Partial<QueryCacheConfig>,\n  ) {\n    this.queryCache = new QueryCache(cacheConfig);\n  }\n\n  /**\n   * Execute CONSTRUCT query to generate new triples\n   */\n  construct(query: string): ConstructResult {\n    // Check cache first\n    const cacheKey = this.queryCache.createCacheKey(`CONSTRUCT:${query}`);\n    const cachedResult = this.queryCache.get<ConstructResult>(cacheKey);\n\n    if (cachedResult) {\n      return { ...cachedResult, cached: true };\n    }\n    // Parse CONSTRUCT query\n    const constructMatch = query.match(\n      /CONSTRUCT\\s*\\{(.*?)\\}\\s*WHERE\\s*\\{(.*?)\\}/is,\n    );\n    if (!constructMatch) {\n      throw new Error(\"Invalid CONSTRUCT query format\");\n    }\n\n    const template = this.parseConstructTemplate(constructMatch[1]);\n    const patterns = this.parsePatterns(constructMatch[2]);\n\n    if (patterns.length === 0) {\n      return {\n        triples: [],\n        provenance: `CONSTRUCT query at ${new Date().toISOString()}`,\n      };\n    }\n\n    const generatedTriples: Triple[] = [];\n\n    // Handle multiple patterns by joining results\n    if (patterns.length === 1) {\n      // Single pattern - simple case\n      const pattern = patterns[0];\n\n      // Convert pattern strings to proper types, stripping angle brackets from IRIs\n      const subject = pattern.subject.startsWith(\"?\")\n        ? null\n        : new IRI(pattern.subject.replace(/^<|>$/g, \"\"));\n      const predicate = pattern.predicate.startsWith(\"?\")\n        ? null\n        : new IRI(pattern.predicate.replace(/^<|>$/g, \"\"));\n      const object = pattern.object.startsWith(\"?\")\n        ? null\n        : this.parseObjectForMatching(pattern.object);\n\n      const matchedTriples = this.graph.match(subject, predicate, object);\n\n      for (const triple of matchedTriples) {\n        const binding = this.createBinding(pattern, triple);\n        const newTriples = this.instantiateTemplate(template, binding);\n        generatedTriples.push(...newTriples);\n      }\n    } else {\n      // Multiple patterns - need to join bindings\n      const bindings = this.executeWhereClause(patterns);\n\n      for (const binding of bindings) {\n        const newTriples = this.instantiateTemplate(template, binding);\n        generatedTriples.push(...newTriples);\n      }\n    }\n\n    // Apply LIMIT if present\n    const limitMatch = query.match(/LIMIT\\s+(\\d+)/i);\n    let result: ConstructResult;\n\n    if (limitMatch) {\n      const limit = parseInt(limitMatch[1]);\n      result = {\n        triples: generatedTriples.slice(0, limit),\n        provenance: `CONSTRUCT query at ${new Date().toISOString()}`,\n        cached: false,\n      };\n    } else {\n      result = {\n        triples: generatedTriples,\n        provenance: `CONSTRUCT query at ${new Date().toISOString()}`,\n        cached: false,\n      };\n    }\n\n    // Cache the result\n    this.queryCache.set(cacheKey, result);\n\n    return result;\n  }\n\n  private parseConstructTemplate(templateClause: string): any[] {\n    const templates: any[] = [];\n    // Split by period followed by whitespace or newline, not just any period\n    const lines = templateClause.trim().split(/\\.\\s*(?:\\n|\\s|$)/);\n\n    for (const line of lines) {\n      const trimmed = line.trim();\n      if (!trimmed) continue;\n\n      const parts = trimmed.split(/\\s+/);\n      if (parts.length >= 3) {\n        // Preserve quotes for literals\n        let object = parts.slice(2).join(\" \");\n        templates.push({\n          subject: parts[0],\n          predicate: parts[1],\n          object: object,\n        });\n      }\n    }\n\n    return templates;\n  }\n\n  private createBinding(pattern: any, triple: Triple): Record<string, string> {\n    const binding: Record<string, string> = {};\n\n    if (pattern.subject.startsWith(\"?\")) {\n      binding[pattern.subject.substring(1)] = this.formatForBinding(\n        triple.getSubject(),\n      );\n    }\n    if (pattern.predicate.startsWith(\"?\")) {\n      binding[pattern.predicate.substring(1)] = this.formatForBinding(\n        triple.getPredicate(),\n      );\n    }\n    if (pattern.object.startsWith(\"?\")) {\n      binding[pattern.object.substring(1)] = this.formatForBinding(\n        triple.getObject(),\n      );\n    }\n\n    return binding;\n  }\n\n  private formatForBinding(node: any): string {\n    // For SELECT query results, return full typed representation\n    return node.toString();\n  }\n\n  private instantiateTemplate(\n    template: any[],\n    binding: Record<string, string>,\n  ): Triple[] {\n    const triples: Triple[] = [];\n\n    for (const t of template) {\n      const subjectStr = this.resolveValue(t.subject, binding);\n      const predicateStr = this.resolveValue(t.predicate, binding);\n      const objectStr = this.resolveValue(t.object, binding);\n\n      if (subjectStr && predicateStr && objectStr) {\n        // Create proper Triple objects\n        const subject = subjectStr.startsWith(\"_:\")\n          ? new BlankNode(subjectStr)\n          : new IRI(subjectStr.replace(/^<|>$/g, \"\"));\n        const predicate = new IRI(predicateStr.replace(/^<|>$/g, \"\"));\n\n        // Handle different object types\n        let object: IRI | BlankNode | Literal;\n        if (objectStr.startsWith('\"')) {\n          // It's a string literal - create typed literal with datatype\n          object = Literal.string(objectStr.replace(/^\"|\"$/g, \"\"));\n        } else if (objectStr === \"true\" || objectStr === \"false\") {\n          // Boolean literal\n          object = Literal.boolean(objectStr === \"true\");\n        } else if (objectStr.startsWith(\"_:\")) {\n          // Blank node\n          object = new BlankNode(objectStr);\n        } else if (/^\\d+$/.test(objectStr)) {\n          // Integer literal\n          object = Literal.integer(parseInt(objectStr));\n        } else if (/^\\d+\\.\\d+$/.test(objectStr)) {\n          // Double literal\n          object = Literal.double(parseFloat(objectStr));\n        } else {\n          // IRI\n          object = new IRI(objectStr.replace(/^<|>$/g, \"\"));\n        }\n\n        triples.push(new Triple(subject, predicate, object));\n      }\n    }\n\n    return triples;\n  }\n\n  private resolveValue(\n    value: string,\n    binding: Record<string, string>,\n  ): string | null {\n    if (value.startsWith(\"?\")) {\n      const varName = value.substring(1);\n      return binding[varName] || null;\n    }\n    return value;\n  }\n\n  private executeWhereClause(patterns: any[]): Record<string, string>[] {\n    if (patterns.length === 0) return [];\n\n    // Start with first pattern\n    const firstPattern = patterns[0];\n    const firstTriples = this.graph.match(\n      firstPattern.subject.startsWith(\"?\")\n        ? null\n        : new IRI(firstPattern.subject.replace(/^<|>$/g, \"\")),\n      firstPattern.predicate.startsWith(\"?\")\n        ? null\n        : new IRI(firstPattern.predicate.replace(/^<|>$/g, \"\")),\n      firstPattern.object.startsWith(\"?\")\n        ? null\n        : firstPattern.object.startsWith('\"')\n          ? new Literal(firstPattern.object.replace(/^\"|\"$/g, \"\"))\n          : new IRI(firstPattern.object.replace(/^<|>$/g, \"\")),\n    );\n\n    let bindings: Record<string, string>[] = [];\n    for (const triple of firstTriples) {\n      bindings.push(this.createBinding(firstPattern, triple));\n    }\n\n    // Join with subsequent patterns\n    for (let i = 1; i < patterns.length; i++) {\n      const pattern = patterns[i];\n      const newBindings: Record<string, string>[] = [];\n\n      for (const binding of bindings) {\n        // Resolve pattern with current binding\n        const subjectStr = pattern.subject.startsWith(\"?\")\n          ? binding[pattern.subject.substring(1)] || null\n          : pattern.subject;\n        const predicateStr = pattern.predicate.startsWith(\"?\")\n          ? binding[pattern.predicate.substring(1)] || null\n          : pattern.predicate;\n        const objectStr = pattern.object.startsWith(\"?\")\n          ? binding[pattern.object.substring(1)] || null\n          : pattern.object;\n\n        // Convert strings to proper types for match\n        const subject = subjectStr\n          ? new IRI(subjectStr.replace(/^<|>$/g, \"\"))\n          : null;\n        const predicate = predicateStr\n          ? new IRI(predicateStr.replace(/^<|>$/g, \"\"))\n          : null;\n        const object = objectStr\n          ? this.parseObjectForMatching(objectStr)\n          : null;\n\n        // Find matching triples\n        const matches = this.graph.match(subject, predicate, object);\n\n        for (const triple of matches) {\n          const extendedBinding = { ...binding };\n\n          // Add new variable bindings\n          if (pattern.subject.startsWith(\"?\") && !subjectStr) {\n            extendedBinding[pattern.subject.substring(1)] =\n              this.formatForBinding(triple.getSubject());\n          }\n          if (pattern.predicate.startsWith(\"?\") && !predicateStr) {\n            extendedBinding[pattern.predicate.substring(1)] =\n              this.formatForBinding(triple.getPredicate());\n          }\n          if (pattern.object.startsWith(\"?\") && !objectStr) {\n            extendedBinding[pattern.object.substring(1)] =\n              this.formatForBinding(triple.getObject());\n          }\n\n          newBindings.push(extendedBinding);\n        }\n      }\n\n      bindings = newBindings;\n    }\n\n    return bindings;\n  }\n\n  select(query: string): SelectResult {\n    // Check cache first\n    const cacheKey = this.queryCache.createCacheKey(`SELECT:${query}`);\n    const cachedResult = this.queryCache.get<SelectResult>(cacheKey);\n\n    if (cachedResult) {\n      return { ...cachedResult, cached: true };\n    }\n\n    // Parse basic SELECT ?var WHERE { ?s ?p ?o } pattern\n    const selectMatch = query.match(/SELECT\\s+(.*?)\\s+WHERE\\s*\\{(.*?)\\}/is);\n    if (!selectMatch) {\n      throw new Error(\"Invalid SPARQL query format\");\n    }\n\n    const variables = this.parseVariables(selectMatch[1]);\n    const patterns = this.parsePatterns(selectMatch[2]);\n\n    if (patterns.length === 0) {\n      const emptyResult: SelectResult = { results: [], cached: false };\n      this.queryCache.set(cacheKey, emptyResult);\n      return emptyResult;\n    }\n\n    let results: any[] = [];\n\n    if (patterns.length === 1) {\n      // Single pattern - simple case\n      const pattern = patterns[0];\n\n      // Convert string patterns to proper types for match\n      const subject = pattern.subject.startsWith(\"?\")\n        ? null\n        : new IRI(pattern.subject.replace(/^<|>$/g, \"\"));\n      const predicate = pattern.predicate.startsWith(\"?\")\n        ? null\n        : new IRI(pattern.predicate.replace(/^<|>$/g, \"\"));\n      const object = pattern.object.startsWith(\"?\")\n        ? null\n        : this.parseObjectForMatching(pattern.object);\n\n      const triples = this.graph.match(subject, predicate, object);\n\n      // Bind variables\n      for (const triple of triples) {\n        const binding: any = {};\n\n        if (pattern.subject.startsWith(\"?\")) {\n          const varName = pattern.subject.substring(1);\n          if (variables.includes(\"*\") || variables.includes(varName)) {\n            binding[varName] = this.formatForBinding(triple.getSubject());\n          }\n        }\n\n        if (pattern.predicate.startsWith(\"?\")) {\n          const varName = pattern.predicate.substring(1);\n          if (variables.includes(\"*\") || variables.includes(varName)) {\n            binding[varName] = this.formatForBinding(triple.getPredicate());\n          }\n        }\n\n        if (pattern.object.startsWith(\"?\")) {\n          const varName = pattern.object.substring(1);\n          if (variables.includes(\"*\") || variables.includes(varName)) {\n            binding[varName] = this.formatForBinding(triple.getObject());\n          }\n        }\n\n        if (Object.keys(binding).length > 0) {\n          results.push(binding);\n        }\n      }\n    } else {\n      // Multiple patterns - need to join bindings\n      const bindings = this.executeWhereClauseForSelect(patterns);\n\n      for (const binding of bindings) {\n        const filteredBinding: any = {};\n\n        // Only include requested variables\n        for (const [key, value] of Object.entries(binding)) {\n          if (variables.includes(\"*\") || variables.includes(key)) {\n            filteredBinding[key] = value;\n          }\n        }\n\n        if (Object.keys(filteredBinding).length > 0) {\n          results.push(filteredBinding);\n        }\n      }\n    }\n\n    // Apply LIMIT if present\n    const limitMatch = query.match(/LIMIT\\s+(\\d+)/i);\n    let result: SelectResult;\n\n    if (limitMatch) {\n      const limit = parseInt(limitMatch[1]);\n      result = { results: results.slice(0, limit), cached: false };\n    } else {\n      result = { results, cached: false };\n    }\n\n    // Cache the result\n    this.queryCache.set(cacheKey, result);\n\n    return result;\n  }\n\n  private parseVariables(selectClause: string): string[] {\n    const trimmed = selectClause.trim();\n    if (trimmed === \"*\") {\n      return [\"*\"];\n    }\n\n    const variables: string[] = [];\n    const varPattern = /\\?(\\w+)/g;\n    let match;\n    while ((match = varPattern.exec(trimmed)) !== null) {\n      variables.push(match[1]);\n    }\n    return variables;\n  }\n\n  private parseObjectForMatching(objectStr: string): IRI | Literal | null {\n    if (objectStr.startsWith('\"')) {\n      // It's a string literal - create proper Literal for matching\n      const content = objectStr.replace(/^\"|\"$/g, \"\");\n      return Literal.string(content);\n    } else {\n      // It's an IRI\n      return new IRI(objectStr.replace(/^<|>$/g, \"\"));\n    }\n  }\n\n  private executeWhereClauseForSelect(\n    patterns: any[],\n  ): Record<string, string>[] {\n    if (patterns.length === 0) return [];\n\n    // Start with first pattern\n    const firstPattern = patterns[0];\n    const firstTriples = this.graph.match(\n      firstPattern.subject.startsWith(\"?\")\n        ? null\n        : new IRI(firstPattern.subject.replace(/^<|>$/g, \"\")),\n      firstPattern.predicate.startsWith(\"?\")\n        ? null\n        : new IRI(firstPattern.predicate.replace(/^<|>$/g, \"\")),\n      firstPattern.object.startsWith(\"?\")\n        ? null\n        : this.parseObjectForMatching(firstPattern.object),\n    );\n\n    let bindings: Record<string, string>[] = [];\n    for (const triple of firstTriples) {\n      bindings.push(this.createBinding(firstPattern, triple));\n    }\n\n    // Join with subsequent patterns\n    for (let i = 1; i < patterns.length; i++) {\n      const pattern = patterns[i];\n      const newBindings: Record<string, string>[] = [];\n\n      for (const binding of bindings) {\n        // Resolve pattern with current binding\n        const subjectStr = pattern.subject.startsWith(\"?\")\n          ? binding[pattern.subject.substring(1)] || null\n          : pattern.subject;\n        const predicateStr = pattern.predicate.startsWith(\"?\")\n          ? binding[pattern.predicate.substring(1)] || null\n          : pattern.predicate;\n        const objectStr = pattern.object.startsWith(\"?\")\n          ? binding[pattern.object.substring(1)] || null\n          : pattern.object;\n\n        // Convert strings to proper types for match\n        const subject = subjectStr\n          ? new IRI(subjectStr.replace(/^<|>$/g, \"\"))\n          : null;\n        const predicate = predicateStr\n          ? new IRI(predicateStr.replace(/^<|>$/g, \"\"))\n          : null;\n        const object = objectStr\n          ? this.parseObjectForMatching(objectStr)\n          : null;\n\n        // Find matching triples\n        const matches = this.graph.match(subject, predicate, object);\n\n        for (const triple of matches) {\n          const extendedBinding = { ...binding };\n\n          // Add new variable bindings\n          if (pattern.subject.startsWith(\"?\") && !subjectStr) {\n            extendedBinding[pattern.subject.substring(1)] =\n              this.formatForBinding(triple.getSubject());\n          }\n          if (pattern.predicate.startsWith(\"?\") && !predicateStr) {\n            extendedBinding[pattern.predicate.substring(1)] =\n              this.formatForBinding(triple.getPredicate());\n          }\n          if (pattern.object.startsWith(\"?\") && !objectStr) {\n            extendedBinding[pattern.object.substring(1)] =\n              this.formatForBinding(triple.getObject());\n          }\n\n          newBindings.push(extendedBinding);\n        }\n      }\n\n      bindings = newBindings;\n    }\n\n    return bindings;\n  }\n\n  private parsePatterns(whereClause: string): any[] {\n    const patterns: any[] = [];\n\n    // Simple triple pattern: ?s ?p ?o or with literals\n    // Split by period followed by whitespace/newline, not dots inside quotes\n    const lines = whereClause.trim().split(/\\.\\s*(?:\\n|\\s|$)/);\n\n    for (const line of lines) {\n      const trimmed = line.trim();\n      if (!trimmed) continue;\n\n      // Match triple pattern (very basic)\n      const parts = trimmed.split(/\\s+/);\n      if (parts.length >= 3) {\n        patterns.push({\n          subject: parts[0],\n          predicate: parts[1],\n          object: parts.slice(2).join(\" \"), // Keep quotes for proper matching\n        });\n      }\n    }\n\n    return patterns;\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getCacheStatistics() {\n    return this.queryCache.getStatistics();\n  }\n\n  /**\n   * Invalidate all cached queries\n   */\n  invalidateCache(): void {\n    this.queryCache.invalidateAll();\n  }\n\n  /**\n   * Update cache configuration\n   */\n  updateCacheConfig(config: Partial<QueryCacheConfig>): void {\n    this.queryCache.updateConfig(config);\n  }\n\n  /**\n   * Get current cache configuration\n   */\n  getCacheConfig(): QueryCacheConfig {\n    return this.queryCache.getConfig();\n  }\n\n  /**\n   * Cleanup expired cache entries\n   */\n  cleanupCache(): number {\n    return this.queryCache.cleanup();\n  }\n\n  /**\n   * Destroy cache and cleanup resources\n   */\n  destroy(): void {\n    this.queryCache.destroy();\n  }\n}\n"],"version":3}