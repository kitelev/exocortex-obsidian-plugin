73fbb05373dea274d66e74d5147a8e98
"use strict";
/**
 * Test suite for RDF Service functionality
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
// Mock the dependent services
jest.mock('../../../../src/application/services/RDFFileManager');
jest.mock('../../../../src/application/services/RDFParser');
jest.mock('../../../../src/application/services/RDFValidator');
jest.mock('../../../../src/application/services/RDFSerializer');
jest.mock('../../../../src/application/services/NamespaceManager');
const RDFService_1 = require("../../../../src/application/services/RDFService");
const RDFSerializer_1 = require("../../../../src/application/services/RDFSerializer");
const RDFParser_1 = require("../../../../src/application/services/RDFParser");
const NamespaceManager_1 = require("../../../../src/application/services/NamespaceManager");
const Graph_1 = require("../../../../src/domain/semantic/core/Graph");
const Triple_1 = require("../../../../src/domain/semantic/core/Triple");
// Mock Obsidian App
const mockApp = {
    vault: {
        getAbstractFileByPath: jest.fn(),
        createFolder: jest.fn(),
        create: jest.fn(),
        modify: jest.fn(),
        read: jest.fn(),
        getFiles: jest.fn(),
        adapter: {
            write: jest.fn(),
            read: jest.fn()
        }
    }
};
// Mock the service classes
const mockRDFFileManager = {
    readFromVault: jest.fn(),
    saveToVault: jest.fn(),
    detectFormatFromExtension: jest.fn(),
    listRDFFiles: jest.fn(),
    generateFileName: jest.fn()
};
const mockRDFParser = {
    parse: jest.fn()
};
const mockRDFValidator = {
    validateExportOptions: jest.fn(),
    validateImportOptions: jest.fn(),
    validateGraph: jest.fn()
};
const mockRDFSerializer = {
    serialize: jest.fn()
};
const mockNamespaceManager = {
    hasPrefix: jest.fn(),
    addBinding: jest.fn(),
    getPrefix: jest.fn(),
    expand: jest.fn(),
    compressIRI: jest.fn(),
    getAllBindings: jest.fn(),
    generatePrefixDeclarations: jest.fn(),
    getNamespace: jest.fn(),
    expandCURIE: jest.fn()
};
// Import and mock the constructors
const RDFFileManager_1 = require("../../../../src/application/services/RDFFileManager");
const RDFValidator_1 = require("../../../../src/application/services/RDFValidator");
// Configure the mocked constructors
RDFFileManager_1.RDFFileManager.mockImplementation(() => mockRDFFileManager);
RDFParser_1.RDFParser.mockImplementation(() => mockRDFParser);
RDFValidator_1.RDFValidator.mockImplementation(() => mockRDFValidator);
RDFSerializer_1.RDFSerializer.mockImplementation(() => mockRDFSerializer);
NamespaceManager_1.NamespaceManager.mockImplementation(() => mockNamespaceManager);
describe('RDFService', () => {
    let rdfService;
    let graph;
    beforeEach(() => {
        // Reset all mocks
        jest.clearAllMocks();
        // Setup default mock responses for successful operations
        mockRDFFileManager.readFromVault.mockResolvedValue({
            isSuccess: true,
            isFailure: false,
            getValue: () => '@prefix ex: <http://example.org/> . ex:test ex:prop "value" .',
            errorValue: () => null
        });
        mockRDFFileManager.detectFormatFromExtension.mockReturnValue('turtle');
        mockRDFParser.parse.mockReturnValue({
            isSuccess: true,
            isFailure: false,
            getValue: () => ({
                graph: new Graph_1.Graph(),
                tripleCount: 1,
                namespaces: { 'ex': 'http://example.org/' },
                warnings: []
            }),
            errorValue: () => null
        });
        mockRDFValidator.validateExportOptions.mockReturnValue({
            isSuccess: true,
            isFailure: false,
            getValue: () => true,
            errorValue: () => null
        });
        mockRDFValidator.validateImportOptions.mockReturnValue({
            isSuccess: true,
            isFailure: false,
            getValue: () => true,
            errorValue: () => null
        });
        mockRDFFileManager.listRDFFiles.mockResolvedValue({
            isSuccess: true,
            isFailure: false,
            getValue: () => [],
            errorValue: () => null
        });
        mockRDFFileManager.saveToVault.mockImplementation((content, filePath) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            // Simulate vault write operation
            mockApp.vault.create(filePath, content);
            return {
                isSuccess: true,
                isFailure: false,
                getValue: () => ({ filePath, success: true }),
                errorValue: () => null
            };
        }));
        mockRDFFileManager.generateFileName.mockImplementation((fileName, format) => {
            if (fileName)
                return fileName;
            const extension = format === 'turtle' ? '.ttl' : '.rdf';
            return `generated-file${extension}`;
        });
        // Setup serializer mock - make it format-aware
        mockRDFSerializer.serialize.mockImplementation((graph, options) => {
            const tripleCount = graph.size();
            let content;
            switch (options.format) {
                case 'json-ld':
                    content = JSON.stringify({
                        "@context": { "ex": "http://example.org/" },
                        "@graph": [
                            {
                                "@id": "http://example.org/person/1",
                                "http://example.org/name": { "@value": "John Doe" }
                            }
                        ]
                    }, null, 2);
                    break;
                case 'n-triples':
                    content = '<http://example.org/person/1> <http://example.org/name> "John Doe" .';
                    break;
                case 'turtle':
                default:
                    content = '@prefix ex: <http://example.org/> .\n<http://example.org/person/1> <http://example.org/name> "John Doe" .';
                    break;
            }
            return {
                isSuccess: true,
                isFailure: false,
                getValue: () => ({
                    content,
                    tripleCount,
                    format: options.format
                }),
                errorValue: () => null
            };
        });
        // Setup namespace manager mock
        mockNamespaceManager.hasPrefix.mockReturnValue(false);
        mockNamespaceManager.addBinding.mockImplementation(() => { });
        mockNamespaceManager.compressIRI.mockImplementation((iri) => iri.toString());
        mockNamespaceManager.getAllBindings.mockReturnValue([
            { prefix: 'ex', namespace: { toString: () => 'http://example.org/' } },
            { prefix: 'foaf', namespace: { toString: () => 'http://xmlns.com/foaf/0.1/' } }
        ]);
        mockNamespaceManager.generatePrefixDeclarations.mockReturnValue('@prefix ex: <http://example.org/> .');
        mockNamespaceManager.getNamespace.mockReturnValue(null);
        mockNamespaceManager.expandCURIE.mockReturnValue({ isSuccess: false });
        mockRDFValidator.validateGraph.mockReturnValue({
            isSuccess: true,
            isFailure: false,
            getValue: () => ({
                isValid: true,
                errors: [],
                warnings: []
            }),
            errorValue: () => null
        });
        rdfService = new RDFService_1.RDFService(mockApp);
        graph = new Graph_1.Graph();
        // Add some test data
        const subject = new Triple_1.IRI('http://example.org/person/1');
        const predicate = new Triple_1.IRI('http://example.org/name');
        const object = Triple_1.Literal.string('John Doe');
        graph.add(new Triple_1.Triple(subject, predicate, object));
    });
    describe('exportGraph', () => {
        it('should export graph in Turtle format', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const result = yield rdfService.exportGraph(graph, {
                format: 'turtle',
                saveToVault: false
            });
            expect(result.isSuccess).toBe(true);
            const exportData = result.getValue();
            expect(exportData.format).toBe('turtle');
            expect(exportData.tripleCount).toBe(1);
            expect(exportData.content).toContain('@prefix');
            expect(exportData.content).toContain('John Doe');
        }));
        it('should export graph in JSON-LD format', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const result = yield rdfService.exportGraph(graph, {
                format: 'json-ld',
                saveToVault: false
            });
            expect(result.isSuccess).toBe(true);
            const exportData = result.getValue();
            expect(exportData.format).toBe('json-ld');
            expect(exportData.tripleCount).toBe(1);
            // Should be valid JSON
            const jsonData = JSON.parse(exportData.content);
            expect(jsonData['@context']).toBeDefined();
            expect(jsonData['@graph']).toBeDefined();
        }));
        it('should validate export options', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            // Mock validation failure for invalid format
            mockRDFValidator.validateExportOptions.mockReturnValue({
                isSuccess: false,
                isFailure: true,
                getValue: () => null,
                errorValue: () => 'Unsupported format: invalid'
            });
            const result = yield rdfService.exportGraph(graph, {
                format: 'invalid',
                saveToVault: false
            });
            expect(result.isFailure).toBe(true);
            expect(result.errorValue()).toContain('Unsupported format: invalid');
        }));
    });
    describe('importRDF', () => {
        it('should import Turtle format RDF', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const turtleContent = `
                @prefix ex: <http://example.org/> .
                ex:person1 ex:name "Jane Smith" .
                ex:person1 ex:age "30"^^<http://www.w3.org/2001/XMLSchema#integer> .
            `;
            const result = yield rdfService.importRDF(turtleContent, graph, {
                format: 'turtle',
                mergeMode: 'merge'
            });
            expect(result.isSuccess).toBe(true);
            const { graph: updatedGraph, imported } = result.getValue();
            expect(imported.tripleCount).toBeGreaterThan(0);
            expect(updatedGraph.size()).toBeGreaterThanOrEqual(1); // Should have at least the imported data
        }));
        it('should import JSON-LD format RDF', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const jsonldContent = JSON.stringify({
                "@context": {
                    "ex": "http://example.org/"
                },
                "@graph": [
                    {
                        "@id": "ex:person2",
                        "ex:name": { "@value": "Bob Johnson" },
                        "ex:age": { "@value": "25", "@type": "http://www.w3.org/2001/XMLSchema#integer" }
                    }
                ]
            });
            const result = yield rdfService.importRDF(jsonldContent, graph, {
                format: 'json-ld',
                mergeMode: 'merge'
            });
            expect(result.isSuccess).toBe(true);
            const { imported } = result.getValue();
            expect(imported.tripleCount).toBeGreaterThan(0);
        }));
        it('should validate import options', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            // Mock validation failure for invalid format
            mockRDFValidator.validateImportOptions.mockReturnValue({
                isSuccess: false,
                isFailure: true,
                getValue: () => null,
                errorValue: () => 'Unsupported import format: invalid'
            });
            const result = yield rdfService.importRDF('invalid content', graph, {
                format: 'invalid',
                mergeMode: 'merge'
            });
            expect(result.isFailure).toBe(true);
            expect(result.errorValue()).toContain('Unsupported import format: invalid');
        }));
        it('should handle replace merge mode', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const originalSize = graph.size();
            const turtleContent = `
                @prefix ex: <http://example.org/> .
                ex:newperson ex:name "New Person" .
            `;
            // Mock successful parsing with specific data for replace mode
            const replacementGraph = new Graph_1.Graph();
            replacementGraph.add(new Triple_1.Triple(new Triple_1.IRI('http://example.org/newperson'), new Triple_1.IRI('http://example.org/name'), Triple_1.Literal.string('New Person')));
            mockRDFParser.parse.mockReturnValue({
                isSuccess: true,
                isFailure: false,
                getValue: () => ({
                    graph: replacementGraph,
                    tripleCount: 1,
                    namespaces: { 'ex': 'http://example.org/' },
                    warnings: []
                }),
                errorValue: () => null
            });
            const result = yield rdfService.importRDF(turtleContent, graph, {
                format: 'turtle',
                mergeMode: 'replace'
            });
            expect(result.isSuccess).toBe(true);
            const { graph: updatedGraph } = result.getValue();
            // In replace mode, should return the replacement graph
            expect(updatedGraph.size()).toBe(1);
        }));
    });
    describe('getSupportedFormats', () => {
        it('should return all supported formats', () => {
            const formats = rdfService.getSupportedFormats();
            expect(formats).toContain('turtle');
            expect(formats).toContain('n-triples');
            expect(formats).toContain('json-ld');
            expect(formats).toContain('rdf-xml');
        });
    });
    describe('getFormatInfo', () => {
        it('should return format information', () => {
            const info = rdfService.getFormatInfo('turtle');
            expect(info.extension).toBe('.ttl');
            expect(info.mimeType).toBe('text/turtle');
            expect(info.name).toBe('Turtle');
        });
    });
    describe('exportQueryResults', () => {
        it('should export SPARQL query results', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const queryResults = [
                {
                    subject: 'http://example.org/person/1',
                    predicate: 'http://example.org/name',
                    object: 'John Doe'
                },
                {
                    subject: 'http://example.org/person/1',
                    predicate: 'http://example.org/age',
                    object: '30'
                }
            ];
            const result = yield rdfService.exportQueryResults(queryResults, 'turtle', 'query-results', false);
            expect(result.isSuccess).toBe(true);
            const exportData = result.getValue();
            expect(exportData.format).toBe('turtle');
            expect(exportData.tripleCount).toBe(2);
        }));
    });
    describe('importFromVaultFile', () => {
        it('should import RDF from vault file', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockFile = {
                path: 'test.ttl',
                name: 'test.ttl'
            };
            // Mock successful file read
            mockRDFFileManager.readFromVault.mockResolvedValue({
                isSuccess: true,
                isFailure: false,
                getValue: () => '@prefix ex: <http://example.org/> . ex:person1 ex:name "Test Person" .',
                errorValue: () => null
            });
            // Mock format detection
            mockRDFFileManager.detectFormatFromExtension.mockReturnValue('turtle');
            // Mock successful parsing
            const testGraph = new Graph_1.Graph();
            testGraph.add(new Triple_1.Triple(new Triple_1.IRI('http://example.org/person1'), new Triple_1.IRI('http://example.org/name'), Triple_1.Literal.string('Test Person')));
            mockRDFParser.parse.mockReturnValue({
                isSuccess: true,
                isFailure: false,
                getValue: () => ({
                    graph: testGraph,
                    tripleCount: 1,
                    namespaces: { 'ex': 'http://example.org/' },
                    warnings: []
                }),
                errorValue: () => null
            });
            const result = yield rdfService.importFromVaultFile(mockFile, graph, {
                mergeMode: 'merge'
            });
            expect(result.isSuccess).toBe(true);
            expect(mockRDFFileManager.readFromVault).toHaveBeenCalledWith('test.ttl');
        }));
        it('should auto-detect format from file extension', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockFile = {
                path: 'test.jsonld',
                name: 'test.jsonld'
            };
            // Mock successful file read
            mockRDFFileManager.readFromVault.mockResolvedValue({
                isSuccess: true,
                isFailure: false,
                getValue: () => JSON.stringify({
                    "@context": { "ex": "http://example.org/" },
                    "@graph": []
                }),
                errorValue: () => null
            });
            // Mock format detection for JSON-LD
            mockRDFFileManager.detectFormatFromExtension.mockReturnValue('json-ld');
            // Mock successful parsing
            mockRDFParser.parse.mockReturnValue({
                isSuccess: true,
                isFailure: false,
                getValue: () => ({
                    graph: new Graph_1.Graph(),
                    tripleCount: 0,
                    namespaces: { 'ex': 'http://example.org/' },
                    warnings: []
                }),
                errorValue: () => null
            });
            const result = yield rdfService.importFromVaultFile(mockFile, graph, {
                mergeMode: 'merge'
            });
            expect(result.isSuccess).toBe(true);
            expect(mockRDFFileManager.detectFormatFromExtension).toHaveBeenCalledWith('test.jsonld');
        }));
        it('should handle file read errors', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockFile = {
                path: 'nonexistent.ttl',
                name: 'nonexistent.ttl'
            };
            // Mock file read failure
            mockRDFFileManager.readFromVault.mockResolvedValue({
                isSuccess: false,
                isFailure: true,
                getValue: () => null,
                errorValue: () => 'File not found: nonexistent.ttl'
            });
            const result = yield rdfService.importFromVaultFile(mockFile, graph, {
                mergeMode: 'merge'
            });
            expect(result.isFailure).toBe(true);
            expect(result.errorValue()).toContain('File not found');
        }));
    });
    describe('listRDFFiles', () => {
        it('should list RDF files in vault', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockFiles = [
                { name: 'test.ttl', path: 'test.ttl', extension: 'ttl' },
                { name: 'data.rdf', path: 'data.rdf', extension: 'rdf' },
                { name: 'example.jsonld', path: 'example.jsonld', extension: 'jsonld' }
            ];
            mockRDFFileManager.listRDFFiles.mockResolvedValue({
                isSuccess: true,
                isFailure: false,
                getValue: () => mockFiles,
                errorValue: () => null
            });
            const result = yield rdfService.listRDFFiles();
            expect(result.isSuccess).toBe(true);
            const files = result.getValue();
            expect(files).toHaveLength(3); // Should exclude non-RDF files
            expect(files.map(f => f.name)).toEqual(['test.ttl', 'data.rdf', 'example.jsonld']);
        }));
        it('should filter files by folder', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockFiles = [
                { name: 'test.ttl', path: 'folder1/test.ttl', extension: 'ttl' },
                { name: 'example.jsonld', path: 'folder1/example.jsonld', extension: 'jsonld' }
            ];
            mockRDFFileManager.listRDFFiles.mockResolvedValue({
                isSuccess: true,
                isFailure: false,
                getValue: () => mockFiles,
                errorValue: () => null
            });
            const result = yield rdfService.listRDFFiles('folder1');
            expect(result.isSuccess).toBe(true);
            const files = result.getValue();
            expect(files).toHaveLength(2);
            expect(files.map(f => f.path)).toEqual(['folder1/test.ttl', 'folder1/example.jsonld']);
        }));
    });
    describe('validateGraph', () => {
        it('should validate graph with default options', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const result = yield rdfService.validateGraph(graph);
            expect(result.isSuccess).toBe(true);
            const validation = result.getValue();
            expect(validation.isValid).toBe(true);
            expect(Array.isArray(validation.errors)).toBe(true);
            expect(Array.isArray(validation.warnings)).toBe(true);
        }));
        it('should validate graph with custom options', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const options = {
                strictMode: true,
                checkDuplicates: true,
                checkNamespaces: true
            };
            const result = yield rdfService.validateGraph(graph, options);
            expect(result.isSuccess).toBe(true);
        }));
    });
    describe('createNodeFromValue', () => {
        it('should create IRI from string with protocol', () => {
            const queryResults = [{
                    subject: 'http://example.org/person/1',
                    predicate: 'http://example.org/name',
                    object: 'John Doe'
                }];
            const result = rdfService.exportQueryResults(queryResults, 'turtle', 'test', false);
            expect(result).resolves.toBeDefined();
        });
        it('should create BlankNode from string with _: prefix', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const queryResults = [{
                    subject: '_:b1',
                    predicate: 'http://example.org/name',
                    object: 'John Doe'
                }];
            // Update the serializer mock to handle blank node subjects
            mockRDFSerializer.serialize.mockImplementationOnce((graph, options) => {
                return {
                    isSuccess: true,
                    isFailure: false,
                    getValue: () => ({
                        content: '_:b1 <http://example.org/name> "John Doe" .',
                        tripleCount: 1,
                        format: options.format
                    }),
                    errorValue: () => null
                };
            });
            const result = yield rdfService.exportQueryResults(queryResults, 'turtle', 'test', false);
            expect(result.isSuccess).toBe(true);
            const exported = result.getValue();
            expect(exported.content).toContain('_:b1');
        }));
        it('should create Literal from number', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const queryResults = [{
                    subject: 'http://example.org/person/1',
                    predicate: 'http://example.org/age',
                    object: 25
                }];
            const result = yield rdfService.exportQueryResults(queryResults, 'turtle', 'test', false);
            expect(result.isSuccess).toBe(true);
        }));
        it('should create Literal from boolean', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const queryResults = [{
                    subject: 'http://example.org/person/1',
                    predicate: 'http://example.org/active',
                    object: true
                }];
            const result = yield rdfService.exportQueryResults(queryResults, 'turtle', 'test', false);
            expect(result.isSuccess).toBe(true);
        }));
        it('should create typed Literal from object with datatype', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const queryResults = [{
                    subject: 'http://example.org/person/1',
                    predicate: 'http://example.org/birthDate',
                    object: {
                        type: 'literal',
                        value: '1990-01-01',
                        datatype: 'http://www.w3.org/2001/XMLSchema#date'
                    }
                }];
            const result = yield rdfService.exportQueryResults(queryResults, 'turtle', 'test', false);
            expect(result.isSuccess).toBe(true);
        }));
        it('should create language-tagged Literal from object with lang', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const queryResults = [{
                    subject: 'http://example.org/person/1',
                    predicate: 'http://example.org/name',
                    object: {
                        type: 'literal',
                        value: 'Jean',
                        lang: 'fr'
                    }
                }];
            const result = yield rdfService.exportQueryResults(queryResults, 'turtle', 'test', false);
            expect(result.isSuccess).toBe(true);
        }));
        it('should handle null values gracefully', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const queryResults = [{
                    subject: 'http://example.org/person/1',
                    predicate: 'http://example.org/name',
                    object: null
                }];
            const result = yield rdfService.exportQueryResults(queryResults, 'turtle', 'test', false);
            expect(result.isSuccess).toBe(true);
        }));
    });
    describe('error handling', () => {
        it('should handle serialization errors', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            // Create an invalid graph scenario
            const invalidGraph = new Graph_1.Graph();
            // Mock serialization failure
            mockRDFSerializer.serialize.mockImplementationOnce(() => {
                return {
                    isSuccess: false,
                    isFailure: true,
                    getValue: () => null,
                    errorValue: () => 'Serialization failed: Invalid base IRI'
                };
            });
            const result = yield rdfService.exportGraph(invalidGraph, {
                format: 'turtle',
                baseIRI: 'invalid-uri',
                saveToVault: false
            });
            // Should handle the error gracefully
            expect(result.isFailure).toBe(true);
        }));
        it('should handle parsing errors in strict mode', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const invalidContent = 'This is not valid RDF';
            // Mock parsing failure
            mockRDFParser.parse.mockReturnValue({
                isSuccess: false,
                isFailure: true,
                getValue: () => null,
                errorValue: () => 'Invalid RDF syntax'
            });
            const result = yield rdfService.importRDF(invalidContent, graph, {
                format: 'turtle',
                mergeMode: 'merge',
                strictMode: true
            });
            expect(result.isFailure).toBe(true);
        }));
        it('should handle malformed RDF content', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const malformedContent = `
                @prefix ex: <http://example.org/>
                ex:person1 ex:name "Unclosed string
            `;
            const result = yield rdfService.importRDF(malformedContent, graph, {
                format: 'turtle',
                mergeMode: 'merge',
                strictMode: false
            });
            // Should fail or succeed with warnings
            if (result.isSuccess) {
                // If successful, should have warnings
                expect(result.getValue().imported.warnings).toBeDefined();
            }
            else {
                expect(result.errorValue()).toContain('parsing failed');
            }
        }));
        it('should handle invalid JSON-LD content', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const invalidJsonLD = '{ "invalid": json }'; // Invalid JSON syntax
            // Mock parsing failure for invalid JSON-LD
            mockRDFParser.parse.mockReturnValue({
                isSuccess: false,
                isFailure: true,
                getValue: () => null,
                errorValue: () => 'Invalid JSON-LD syntax'
            });
            const result = yield rdfService.importRDF(invalidJsonLD, graph, {
                format: 'json-ld',
                mergeMode: 'merge',
                strictMode: true // Enable strict mode to catch parsing errors
            });
            expect(result.isFailure).toBe(true);
        }));
        it('should handle vault write errors', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            // Mock save failure
            mockRDFFileManager.saveToVault.mockResolvedValue({
                isSuccess: false,
                isFailure: true,
                getValue: () => null,
                errorValue: () => 'Write failed'
            });
            const result = yield rdfService.exportGraph(graph, {
                format: 'turtle',
                saveToVault: true,
                fileName: 'test.ttl'
            });
            expect(result.isFailure).toBe(true);
            expect(result.errorValue()).toContain('Write failed');
        }));
        it('should handle namespace errors', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const contentWithBadNamespace = `
                @prefix bad: <invalid-uri> .
                bad:test bad:prop "value" .
            `;
            // Mock parsing with warnings
            mockRDFParser.parse.mockReturnValue({
                isSuccess: true,
                isFailure: false,
                getValue: () => ({
                    graph: new Graph_1.Graph(),
                    tripleCount: 1,
                    namespaces: { 'bad': 'invalid-uri' },
                    warnings: ['Invalid namespace URI: invalid-uri']
                }),
                errorValue: () => null
            });
            // Mock validation with warnings
            mockRDFValidator.validateGraph.mockReturnValue({
                isSuccess: true,
                isFailure: false,
                getValue: () => ({
                    isValid: true,
                    errors: [],
                    warnings: [{ message: 'Invalid namespace URI detected' }]
                }),
                errorValue: () => null
            });
            const result = yield rdfService.importRDF(contentWithBadNamespace, graph, {
                format: 'turtle',
                mergeMode: 'merge',
                strictMode: true,
                validateInput: true
            });
            // Should succeed with warnings
            expect(result.isSuccess).toBe(true);
            const validation = result.getValue();
            expect(validation.imported.warnings.length).toBeGreaterThan(0);
        }));
        it('should handle empty graph export', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const emptyGraph = new Graph_1.Graph();
            const result = yield rdfService.exportGraph(emptyGraph, {
                format: 'turtle',
                saveToVault: false
            });
            expect(result.isSuccess).toBe(true);
            const exported = result.getValue();
            expect(exported.tripleCount).toBe(0);
        }));
        it('should handle very large graphs', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const largeGraph = new Graph_1.Graph();
            // Add many triples to test memory/performance
            for (let i = 0; i < 1000; i++) {
                const triple = new Triple_1.Triple(new Triple_1.IRI(`http://example.org/person/${i}`), new Triple_1.IRI('http://example.org/name'), Triple_1.Literal.string(`Person ${i}`));
                largeGraph.add(triple);
            }
            const result = yield rdfService.exportGraph(largeGraph, {
                format: 'n-triples',
                saveToVault: false
            });
            expect(result.isSuccess).toBe(true);
            const exported = result.getValue();
            expect(exported.tripleCount).toBe(1000);
        }));
    });
    describe('namespace management', () => {
        it('should use custom namespace manager', () => {
            // Create a mock custom namespace manager
            const MockedNamespaceManager = NamespaceManager_1.NamespaceManager;
            const customNamespaceManager = new MockedNamespaceManager();
            customNamespaceManager.hasPrefix.mockImplementation((prefix) => {
                return prefix === 'custom';
            });
            customNamespaceManager.addBinding.mockImplementation(() => { });
            customNamespaceManager.addBinding('custom', 'http://custom.example.org/');
            const customRDFService = new RDFService_1.RDFService(mockApp, customNamespaceManager);
            const nsManager = customRDFService.getNamespaceManager();
            expect(nsManager.hasPrefix('custom')).toBe(true);
        });
        it('should preserve namespace bindings during import', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const turtleContent = `
                @prefix custom: <http://custom.example.org/> .
                @prefix test: <http://test.example.org/> .
                custom:item test:property "value" .
            `;
            // Mock parsing with custom namespaces
            mockRDFParser.parse.mockReturnValue({
                isSuccess: true,
                isFailure: false,
                getValue: () => ({
                    graph: new Graph_1.Graph(),
                    tripleCount: 1,
                    namespaces: {
                        'custom': 'http://custom.example.org/',
                        'test': 'http://test.example.org/'
                    },
                    warnings: []
                }),
                errorValue: () => null
            });
            // Mock namespace manager to show prefixes after binding
            mockNamespaceManager.hasPrefix.mockImplementation((prefix) => {
                return prefix === 'custom' || prefix === 'test';
            });
            const result = yield rdfService.importRDF(turtleContent, graph, {
                format: 'turtle',
                mergeMode: 'merge'
            });
            expect(result.isSuccess).toBe(true);
            const nsManager = rdfService.getNamespaceManager();
            expect(nsManager.hasPrefix('custom')).toBe(true);
            expect(nsManager.hasPrefix('test')).toBe(true);
        }));
    });
    describe('export with file operations', () => {
        beforeEach(() => {
            mockApp.vault.getAbstractFileByPath.mockReturnValue(null); // File doesn't exist
            mockApp.vault.create.mockResolvedValue();
            mockApp.vault.createFolder.mockResolvedValue();
        });
        it('should save to vault with custom filename', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const result = yield rdfService.exportGraph(graph, {
                format: 'turtle',
                saveToVault: true,
                fileName: 'custom-name.ttl'
            });
            expect(result.isSuccess).toBe(true);
            expect(mockApp.vault.create).toHaveBeenCalledWith('custom-name.ttl', expect.any(String));
        }));
        it('should save to vault in target folder', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const result = yield rdfService.exportGraph(graph, {
                format: 'turtle',
                saveToVault: true,
                targetFolder: 'exports',
                fileName: 'test.ttl'
            });
            expect(result.isSuccess).toBe(true);
            expect(mockApp.vault.create).toHaveBeenCalledWith('exports/test.ttl', expect.any(String));
        }));
        it('should generate filename when not provided', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const result = yield rdfService.exportGraph(graph, {
                format: 'turtle',
                saveToVault: true
            });
            expect(result.isSuccess).toBe(true);
            expect(mockApp.vault.create).toHaveBeenCalledWith(expect.stringMatching(/.*\.ttl$/), expect.any(String));
        }));
    });
});
describe('NamespaceManager', () => {
    let namespaceManager;
    beforeEach(() => {
        // Use mock for NamespaceManager tests too
        const MockedNamespaceManager = NamespaceManager_1.NamespaceManager;
        namespaceManager = new MockedNamespaceManager();
        // Setup default behavior for these specific tests
        namespaceManager.hasPrefix.mockImplementation((prefix) => {
            return ['rdf', 'rdfs', 'owl', 'xsd', 'test'].includes(prefix);
        });
        namespaceManager.addBinding.mockImplementation(() => { });
        namespaceManager.getNamespace.mockImplementation((prefix) => {
            if (prefix === 'test') {
                return { toString: () => 'http://test.example.org/' };
            }
            return null;
        });
        namespaceManager.expandCURIE.mockImplementation((curie) => {
            if (curie === 'rdf:type') {
                return {
                    isSuccess: true,
                    getValue: () => new Triple_1.IRI('http://www.w3.org/1999/02/22-rdf-syntax-ns#type')
                };
            }
            return { isSuccess: false };
        });
        namespaceManager.compressIRI.mockImplementation((iri) => {
            if (iri.toString() === 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type') {
                return 'rdf:type';
            }
            return iri.toString();
        });
    });
    it('should have default namespaces', () => {
        expect(namespaceManager.hasPrefix('rdf')).toBe(true);
        expect(namespaceManager.hasPrefix('rdfs')).toBe(true);
        expect(namespaceManager.hasPrefix('owl')).toBe(true);
        expect(namespaceManager.hasPrefix('xsd')).toBe(true);
    });
    it('should add custom namespace bindings', () => {
        namespaceManager.addBinding('test', 'http://test.example.org/');
        expect(namespaceManager.hasPrefix('test')).toBe(true);
        const namespace = namespaceManager.getNamespace('test');
        expect(namespace === null || namespace === void 0 ? void 0 : namespace.toString()).toBe('http://test.example.org/');
    });
    it('should expand CURIEs', () => {
        const result = namespaceManager.expandCURIE('rdf:type');
        expect(result.isSuccess).toBe(true);
        const iri = result.getValue();
        expect(iri.toString()).toBe('http://www.w3.org/1999/02/22-rdf-syntax-ns#type');
    });
    it('should compress IRIs', () => {
        const iri = new Triple_1.IRI('http://www.w3.org/1999/02/22-rdf-syntax-ns#type');
        const compressed = namespaceManager.compressIRI(iri);
        expect(compressed).toBe('rdf:type');
    });
});
describe('RDFSerializer', () => {
    let serializer;
    let graph;
    beforeEach(() => {
        // Use mocked serializer
        const MockedRDFSerializer = RDFSerializer_1.RDFSerializer;
        const mockNamespaceManager = new NamespaceManager_1.NamespaceManager();
        serializer = new MockedRDFSerializer(mockNamespaceManager);
        graph = new Graph_1.Graph();
        // Add test data
        const triple = new Triple_1.Triple(new Triple_1.IRI('http://example.org/person/1'), new Triple_1.IRI('http://xmlns.com/foaf/0.1/name'), Triple_1.Literal.string('John Doe'));
        graph.add(triple);
        // Setup mock behavior for serializer
        serializer.serialize.mockImplementation((graph, options) => {
            let content;
            switch (options.format) {
                case 'turtle':
                    content = '@prefix foaf: <http://xmlns.com/foaf/0.1/> .\n<http://example.org/person/1> foaf:name "John Doe" .';
                    break;
                case 'n-triples':
                    content = '<http://example.org/person/1> <http://xmlns.com/foaf/0.1/name> "John Doe" .';
                    break;
                default:
                    content = '@prefix foaf: <http://xmlns.com/foaf/0.1/> .\n<http://example.org/person/1> foaf:name "John Doe" .';
            }
            return {
                isSuccess: true,
                getValue: () => ({
                    content,
                    format: options.format,
                    tripleCount: 1
                })
            };
        });
    });
    it('should serialize to Turtle format', () => {
        const result = serializer.serialize(graph, {
            format: 'turtle',
            prettyPrint: true
        });
        expect(result.isSuccess).toBe(true);
        const serializedData = result.getValue();
        expect(serializedData.content).toContain('@prefix');
        expect(serializedData.content).toContain('foaf:name');
        expect(serializedData.content).toContain('"John Doe"');
    });
    it('should serialize to N-Triples format', () => {
        const result = serializer.serialize(graph, {
            format: 'n-triples'
        });
        expect(result.isSuccess).toBe(true);
        const serializedData = result.getValue();
        expect(serializedData.content).toContain('<http://example.org/person/1>');
        expect(serializedData.content).toContain('<http://xmlns.com/foaf/0.1/name>');
        expect(serializedData.content).toContain('"John Doe"');
        expect(serializedData.content).toContain(' .');
    });
    it('should provide file extension for format', () => {
        // Mock static methods
        RDFSerializer_1.RDFSerializer.getFileExtension = jest.fn().mockImplementation((format) => {
            const extensions = {
                'turtle': '.ttl',
                'n-triples': '.nt',
                'json-ld': '.jsonld',
                'rdf-xml': '.rdf'
            };
            return extensions[format];
        });
        expect(RDFSerializer_1.RDFSerializer.getFileExtension('turtle')).toBe('.ttl');
        expect(RDFSerializer_1.RDFSerializer.getFileExtension('n-triples')).toBe('.nt');
        expect(RDFSerializer_1.RDFSerializer.getFileExtension('json-ld')).toBe('.jsonld');
        expect(RDFSerializer_1.RDFSerializer.getFileExtension('rdf-xml')).toBe('.rdf');
    });
    it('should provide MIME type for format', () => {
        // Mock static methods
        RDFSerializer_1.RDFSerializer.getMimeType = jest.fn().mockImplementation((format) => {
            const mimeTypes = {
                'turtle': 'text/turtle',
                'n-triples': 'application/n-triples',
                'json-ld': 'application/ld+json',
                'rdf-xml': 'application/rdf+xml'
            };
            return mimeTypes[format];
        });
        expect(RDFSerializer_1.RDFSerializer.getMimeType('turtle')).toBe('text/turtle');
        expect(RDFSerializer_1.RDFSerializer.getMimeType('n-triples')).toBe('application/n-triples');
        expect(RDFSerializer_1.RDFSerializer.getMimeType('json-ld')).toBe('application/ld+json');
        expect(RDFSerializer_1.RDFSerializer.getMimeType('rdf-xml')).toBe('application/rdf+xml');
    });
});
describe('RDFParser', () => {
    let parser;
    beforeEach(() => {
        // Use mocked parser
        const MockedRDFParser = RDFParser_1.RDFParser;
        const mockNamespaceManager = new NamespaceManager_1.NamespaceManager();
        parser = new MockedRDFParser(mockNamespaceManager);
        // Setup mock behavior for parser
        parser.parse.mockImplementation((content, options) => {
            const graph = new Graph_1.Graph();
            // Simulate parsing based on content and format
            if (content.includes('foaf:name') || content.includes('http://xmlns.com/foaf/0.1/name')) {
                const triple = new Triple_1.Triple(new Triple_1.IRI('http://example.org/person1'), new Triple_1.IRI('http://xmlns.com/foaf/0.1/name'), Triple_1.Literal.string('Alice Smith'));
                graph.add(triple);
                if (content.includes('foaf:age') || content.includes('age')) {
                    const ageTriple = new Triple_1.Triple(new Triple_1.IRI('http://example.org/person1'), new Triple_1.IRI('http://xmlns.com/foaf/0.1/age'), new Triple_1.Literal('28', new Triple_1.IRI('http://www.w3.org/2001/XMLSchema#integer')));
                    graph.add(ageTriple);
                }
            }
            else if (content.includes('ex:test')) {
                const triple = new Triple_1.Triple(new Triple_1.IRI('http://example.org/test'), new Triple_1.IRI('http://example.org/prop'), Triple_1.Literal.string('value'));
                graph.add(triple);
            }
            else if (content === 'This is not valid RDF at all!') {
                return {
                    isSuccess: false,
                    isFailure: true,
                    getError: () => 'Parse error: invalid syntax'
                };
            }
            return {
                isSuccess: true,
                getValue: () => ({
                    graph,
                    tripleCount: graph.size(),
                    namespaces: {
                        'foaf': 'http://xmlns.com/foaf/0.1/',
                        'ex': 'http://example.org/'
                    },
                    warnings: []
                })
            };
        });
    });
    it('should parse Turtle format', () => {
        const turtleContent = `
            @prefix foaf: <http://xmlns.com/foaf/0.1/> .
            @prefix ex: <http://example.org/> .
            
            ex:person1 foaf:name "Alice Smith" ;
                       foaf:age "28"^^<http://www.w3.org/2001/XMLSchema#integer> .
        `;
        const result = parser.parse(turtleContent, { format: 'turtle' });
        expect(result.isSuccess).toBe(true);
        const parseResult = result.getValue();
        expect(parseResult.tripleCount).toBeGreaterThan(0);
        expect(parseResult.graph.size()).toBeGreaterThan(0);
        expect(parseResult.namespaces['foaf']).toBe('http://xmlns.com/foaf/0.1/');
    });
    it('should parse N-Triples format', () => {
        const ntriplesContent = `
            <http://example.org/person1> <http://xmlns.com/foaf/0.1/name> "Bob Johnson" .
            <http://example.org/person1> <http://xmlns.com/foaf/0.1/age> "32"^^<http://www.w3.org/2001/XMLSchema#integer> .
        `;
        const result = parser.parse(ntriplesContent, { format: 'n-triples' });
        expect(result.isSuccess).toBe(true);
        const parseResult = result.getValue();
        expect(parseResult.tripleCount).toBe(2);
        expect(parseResult.graph.size()).toBe(2);
    });
    it('should auto-detect format', () => {
        const turtleContent = '@prefix ex: <http://example.org/> . ex:test ex:prop "value" .';
        const result = parser.parse(turtleContent); // No format specified
        expect(result.isSuccess).toBe(true);
        const parseResult = result.getValue();
        expect(parseResult.tripleCount).toBe(1);
    });
    it('should handle parsing errors gracefully', () => {
        const invalidContent = 'This is not valid RDF at all!';
        const result = parser.parse(invalidContent, {
            format: 'turtle',
            strictMode: false
        });
        // Should either succeed with warnings or fail gracefully
        if (result.isFailure) {
            expect(result.getError()).toContain('Parse');
        }
        else {
            const parseResult = result.getValue();
            expect(parseResult.warnings).toBeDefined();
        }
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2tpdGVsZXYvRG9jdW1lbnRzL2V4b2NvcnRleC1vYnNpZGlhbi1wbHVnaW4vdGVzdHMvdW5pdC9hcHBsaWNhdGlvbi9zZXJ2aWNlcy9SREZTZXJ2aWNlLnRlc3QudHMiLCJtYXBwaW5ncyI6IjtBQUFBOztHQUVHOzs7QUFVSCw4QkFBOEI7QUFDOUIsSUFBSSxDQUFDLElBQUksQ0FBQyxxREFBcUQsQ0FBQyxDQUFDO0FBQ2pFLElBQUksQ0FBQyxJQUFJLENBQUMsZ0RBQWdELENBQUMsQ0FBQztBQUM1RCxJQUFJLENBQUMsSUFBSSxDQUFDLG1EQUFtRCxDQUFDLENBQUM7QUFDL0QsSUFBSSxDQUFDLElBQUksQ0FBQyxvREFBb0QsQ0FBQyxDQUFDO0FBQ2hFLElBQUksQ0FBQyxJQUFJLENBQUMsdURBQXVELENBQUMsQ0FBQztBQWJuRSxnRkFBNkU7QUFDN0Usc0ZBQW1GO0FBQ25GLDhFQUEyRTtBQUMzRSw0RkFBeUY7QUFDekYsc0VBQW1FO0FBQ25FLHdFQUE4RjtBQVU5RixvQkFBb0I7QUFDcEIsTUFBTSxPQUFPLEdBQUc7SUFDWixLQUFLLEVBQUU7UUFDSCxxQkFBcUIsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1FBQ2hDLFlBQVksRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1FBQ3ZCLE1BQU0sRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1FBQ2pCLE1BQU0sRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1FBQ2pCLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1FBQ2YsUUFBUSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7UUFDbkIsT0FBTyxFQUFFO1lBQ0wsS0FBSyxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7WUFDaEIsSUFBSSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7U0FDbEI7S0FDSjtDQUNHLENBQUM7QUFFVCwyQkFBMkI7QUFDM0IsTUFBTSxrQkFBa0IsR0FBRztJQUN2QixhQUFhLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtJQUN4QixXQUFXLEVB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InNvdXJjZXMiOlsiL1VzZXJzL2tpdGVsZXYvRG9jdW1lbnRzL2V4b2NvcnRleC1vYnNpZGlhbi1wbHVnaW4vdGVzdHMvdW5pdC9hcHBsaWNhdGlvbi9zZXJ2aWNlcy9SREZTZXJ2aWNlLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUZXN0IHN1aXRlIGZvciBSREYgU2VydmljZSBmdW5jdGlvbmFsaXR5XG4gKi9cblxuaW1wb3J0IHsgUkRGU2VydmljZSB9IGZyb20gJy4uLy4uLy4uLy4uL3NyYy9hcHBsaWNhdGlvbi9zZXJ2aWNlcy9SREZTZXJ2aWNlJztcbmltcG9ydCB7IFJERlNlcmlhbGl6ZXIgfSBmcm9tICcuLi8uLi8uLi8uLi9zcmMvYXBwbGljYXRpb24vc2VydmljZXMvUkRGU2VyaWFsaXplcic7XG5pbXBvcnQgeyBSREZQYXJzZXIgfSBmcm9tICcuLi8uLi8uLi8uLi9zcmMvYXBwbGljYXRpb24vc2VydmljZXMvUkRGUGFyc2VyJztcbmltcG9ydCB7IE5hbWVzcGFjZU1hbmFnZXIgfSBmcm9tICcuLi8uLi8uLi8uLi9zcmMvYXBwbGljYXRpb24vc2VydmljZXMvTmFtZXNwYWNlTWFuYWdlcic7XG5pbXBvcnQgeyBHcmFwaCB9IGZyb20gJy4uLy4uLy4uLy4uL3NyYy9kb21haW4vc2VtYW50aWMvY29yZS9HcmFwaCc7XG5pbXBvcnQgeyBUcmlwbGUsIElSSSwgQmxhbmtOb2RlLCBMaXRlcmFsIH0gZnJvbSAnLi4vLi4vLi4vLi4vc3JjL2RvbWFpbi9zZW1hbnRpYy9jb3JlL1RyaXBsZSc7XG5pbXBvcnQgeyBSZXN1bHQgfSBmcm9tICcuLi8uLi8uLi8uLi9zcmMvZG9tYWluL2NvcmUvUmVzdWx0JztcblxuLy8gTW9jayB0aGUgZGVwZW5kZW50IHNlcnZpY2VzXG5qZXN0Lm1vY2soJy4uLy4uLy4uLy4uL3NyYy9hcHBsaWNhdGlvbi9zZXJ2aWNlcy9SREZGaWxlTWFuYWdlcicpO1xuamVzdC5tb2NrKCcuLi8uLi8uLi8uLi9zcmMvYXBwbGljYXRpb24vc2VydmljZXMvUkRGUGFyc2VyJyk7IFxuamVzdC5tb2NrKCcuLi8uLi8uLi8uLi9zcmMvYXBwbGljYXRpb24vc2VydmljZXMvUkRGVmFsaWRhdG9yJyk7XG5qZXN0Lm1vY2soJy4uLy4uLy4uLy4uL3NyYy9hcHBsaWNhdGlvbi9zZXJ2aWNlcy9SREZTZXJpYWxpemVyJyk7XG5qZXN0Lm1vY2soJy4uLy4uLy4uLy4uL3NyYy9hcHBsaWNhdGlvbi9zZXJ2aWNlcy9OYW1lc3BhY2VNYW5hZ2VyJyk7XG5cbi8vIE1vY2sgT2JzaWRpYW4gQXBwXG5jb25zdCBtb2NrQXBwID0ge1xuICAgIHZhdWx0OiB7XG4gICAgICAgIGdldEFic3RyYWN0RmlsZUJ5UGF0aDogamVzdC5mbigpLFxuICAgICAgICBjcmVhdGVGb2xkZXI6IGplc3QuZm4oKSxcbiAgICAgICAgY3JlYXRlOiBqZXN0LmZuKCksXG4gICAgICAgIG1vZGlmeTogamVzdC5mbigpLFxuICAgICAgICByZWFkOiBqZXN0LmZuKCksXG4gICAgICAgIGdldEZpbGVzOiBqZXN0LmZuKCksXG4gICAgICAgIGFkYXB0ZXI6IHtcbiAgICAgICAgICAgIHdyaXRlOiBqZXN0LmZuKCksXG4gICAgICAgICAgICByZWFkOiBqZXN0LmZuKClcbiAgICAgICAgfVxuICAgIH1cbn0gYXMgYW55O1xuXG4vLyBNb2NrIHRoZSBzZXJ2aWNlIGNsYXNzZXNcbmNvbnN0IG1vY2tSREZGaWxlTWFuYWdlciA9IHtcbiAgICByZWFkRnJvbVZhdWx0OiBqZXN0LmZuKCksXG4gICAgc2F2ZVRvVmF1bHQ6IGplc3QuZm4oKSxcbiAgICBkZXRlY3RGb3JtYXRGcm9tRXh0ZW5zaW9uOiBqZXN0LmZuKCksXG4gICAgbGlzdFJERkZpbGVzOiBqZXN0LmZuKCksXG4gICAgZ2VuZXJhdGVGaWxlTmFtZTogamVzdC5mbigpXG59O1xuXG5jb25zdCBtb2NrUkRGUGFyc2VyID0ge1xuICAgIHBhcnNlOiBqZXN0LmZuKClcbn07XG5cbmNvbnN0IG1vY2tSREZWYWxpZGF0b3IgPSB7XG4gICAgdmFsaWRhdGVFeHBvcnRPcHRpb25zOiBqZXN0LmZuKCksXG4gICAgdmFsaWRhdGVJbXBvcnRPcHRpb25zOiBqZXN0LmZuKCksXG4gICAgdmFsaWRhdGVHcmFwaDogamVzdC5mbigpXG59O1xuXG5jb25zdCBtb2NrUkRGU2VyaWFsaXplciA9IHtcbiAgICBzZXJpYWxpemU6IGplc3QuZm4oKVxufTtcblxuY29uc3QgbW9ja05hbWVzcGFjZU1hbmFnZXIgPSB7XG4gICAgaGFzUHJlZml4OiBqZXN0LmZuKCksXG4gICAgYWRkQmluZGluZzogamVzdC5mbigpLFxuICAgIGdldFByZWZpeDogamVzdC5mbigpLFxuICAgIGV4cGFuZDogamVzdC5mbigpLFxuICAgIGNvbXByZXNzSVJJOiBqZXN0LmZuKCksXG4gICAgZ2V0QWxsQmluZGluZ3M6IGplc3QuZm4oKSxcbiAgICBnZW5lcmF0ZVByZWZpeERlY2xhcmF0aW9uczogamVzdC5mbigpLFxuICAgIGdldE5hbWVzcGFjZTogamVzdC5mbigpLFxuICAgIGV4cGFuZENVUklFOiBqZXN0LmZuKClcbn07XG5cbi8vIEltcG9ydCBhbmQgbW9jayB0aGUgY29uc3RydWN0b3JzXG5pbXBvcnQgeyBSREZGaWxlTWFuYWdlciB9IGZyb20gJy4uLy4uLy4uLy4uL3NyYy9hcHBsaWNhdGlvbi9zZXJ2aWNlcy9SREZGaWxlTWFuYWdlcic7XG5pbXBvcnQgeyBSREZQYXJzZXIgfSBmcm9tICcuLi8uLi8uLi8uLi9zcmMvYXBwbGljYXRpb24vc2VydmljZXMvUkRGUGFyc2VyJztcbmltcG9ydCB7IFJERlZhbGlkYXRvciB9IGZyb20gJy4uLy4uLy4uLy4uL3NyYy9hcHBsaWNhdGlvbi9zZXJ2aWNlcy9SREZWYWxpZGF0b3InO1xuaW1wb3J0IHsgUkRGU2VyaWFsaXplciB9IGZyb20gJy4uLy4uLy4uLy4uL3NyYy9hcHBsaWNhdGlvbi9zZXJ2aWNlcy9SREZTZXJpYWxpemVyJztcbmltcG9ydCB7IE5hbWVzcGFjZU1hbmFnZXIgfSBmcm9tICcuLi8uLi8uLi8uLi9zcmMvYXBwbGljYXRpb24vc2VydmljZXMvTmFtZXNwYWNlTWFuYWdlcic7XG5cbi8vIENvbmZpZ3VyZSB0aGUgbW9ja2VkIGNvbnN0cnVjdG9yc1xuKFJERkZpbGVNYW5hZ2VyIGFzIGplc3QuTW9ja2VkQ2xhc3M8dHlwZW9mIFJERkZpbGVNYW5hZ2VyPikubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IG1vY2tSREZGaWxlTWFuYWdlciBhcyBhbnkpO1xuKFJERlBhcnNlciBhcyBqZXN0Lk1vY2tlZENsYXNzPHR5cGVvZiBSREZQYXJzZXI+KS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gbW9ja1JERlBhcnNlciBhcyBhbnkpO1xuKFJERlZhbGlkYXRvciBhcyBqZXN0Lk1vY2tlZENsYXNzPHR5cGVvZiBSREZWYWxpZGF0b3I+KS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gbW9ja1JERlZhbGlkYXRvciBhcyBhbnkpO1xuKFJERlNlcmlhbGl6ZXIgYXMgamVzdC5Nb2NrZWRDbGFzczx0eXBlb2YgUkRGU2VyaWFsaXplcj4pLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiBtb2NrUkRGU2VyaWFsaXplciBhcyBhbnkpO1xuKE5hbWVzcGFjZU1hbmFnZXIgYXMgamVzdC5Nb2NrZWRDbGFzczx0eXBlb2YgTmFtZXNwYWNlTWFuYWdlcj4pLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiBtb2NrTmFtZXNwYWNlTWFuYWdlciBhcyBhbnkpO1xuXG5kZXNjcmliZSgnUkRGU2VydmljZScsICgpID0+IHtcbiAgICBsZXQgcmRmU2VydmljZTogUkRGU2VydmljZTtcbiAgICBsZXQgZ3JhcGg6IEdyYXBoO1xuICAgIFxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgICAvLyBSZXNldCBhbGwgbW9ja3NcbiAgICAgICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTZXR1cCBkZWZhdWx0IG1vY2sgcmVzcG9uc2VzIGZvciBzdWNjZXNzZnVsIG9wZXJhdGlvbnNcbiAgICAgICAgbW9ja1JERkZpbGVNYW5hZ2VyLnJlYWRGcm9tVmF1bHQubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgaXNTdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgaXNGYWlsdXJlOiBmYWxzZSxcbiAgICAgICAgICAgIGdldFZhbHVlOiAoKSA9PiAnQHByZWZpeCBleDogPGh0dHA6Ly9leGFtcGxlLm9yZy8+IC4gZXg6dGVzdCBleDpwcm9wIFwidmFsdWVcIiAuJyxcbiAgICAgICAgICAgIGVycm9yVmFsdWU6ICgpID0+IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBtb2NrUkRGRmlsZU1hbmFnZXIuZGV0ZWN0Rm9ybWF0RnJvbUV4dGVuc2lvbi5tb2NrUmV0dXJuVmFsdWUoJ3R1cnRsZScpO1xuICAgICAgICBcbiAgICAgICAgbW9ja1JERlBhcnNlci5wYXJzZS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgaXNTdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgaXNGYWlsdXJlOiBmYWxzZSxcbiAgICAgICAgICAgIGdldFZhbHVlOiAoKSA9PiAoe1xuICAgICAgICAgICAgICAgIGdyYXBoOiBuZXcgR3JhcGgoKSxcbiAgICAgICAgICAgICAgICB0cmlwbGVDb3VudDogMSxcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VzOiB7ICdleCc6ICdodHRwOi8vZXhhbXBsZS5vcmcvJyB9LFxuICAgICAgICAgICAgICAgIHdhcm5pbmdzOiBbXVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBlcnJvclZhbHVlOiAoKSA9PiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgbW9ja1JERlZhbGlkYXRvci52YWxpZGF0ZUV4cG9ydE9wdGlvbnMubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgIGlzU3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIGlzRmFpbHVyZTogZmFsc2UsXG4gICAgICAgICAgICBnZXRWYWx1ZTogKCkgPT4gdHJ1ZSxcbiAgICAgICAgICAgIGVycm9yVmFsdWU6ICgpID0+IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBtb2NrUkRGVmFsaWRhdG9yLnZhbGlkYXRlSW1wb3J0T3B0aW9ucy5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgaXNTdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgaXNGYWlsdXJlOiBmYWxzZSxcbiAgICAgICAgICAgIGdldFZhbHVlOiAoKSA9PiB0cnVlLFxuICAgICAgICAgICAgZXJyb3JWYWx1ZTogKCkgPT4gbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIG1vY2tSREZGaWxlTWFuYWdlci5saXN0UkRGRmlsZXMubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgaXNTdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgaXNGYWlsdXJlOiBmYWxzZSxcbiAgICAgICAgICAgIGdldFZhbHVlOiAoKSA9PiBbXSxcbiAgICAgICAgICAgIGVycm9yVmFsdWU6ICgpID0+IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBtb2NrUkRGRmlsZU1hbmFnZXIuc2F2ZVRvVmF1bHQubW9ja0ltcGxlbWVudGF0aW9uKGFzeW5jIChjb250ZW50LCBmaWxlUGF0aCkgPT4ge1xuICAgICAgICAgICAgLy8gU2ltdWxhdGUgdmF1bHQgd3JpdGUgb3BlcmF0aW9uXG4gICAgICAgICAgICBtb2NrQXBwLnZhdWx0LmNyZWF0ZShmaWxlUGF0aCwgY29udGVudCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlzU3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc0ZhaWx1cmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGdldFZhbHVlOiAoKSA9PiAoeyBmaWxlUGF0aCwgc3VjY2VzczogdHJ1ZSB9KSxcbiAgICAgICAgICAgICAgICBlcnJvclZhbHVlOiAoKSA9PiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIG1vY2tSREZGaWxlTWFuYWdlci5nZW5lcmF0ZUZpbGVOYW1lLm1vY2tJbXBsZW1lbnRhdGlvbigoZmlsZU5hbWUsIGZvcm1hdCkgPT4ge1xuICAgICAgICAgICAgaWYgKGZpbGVOYW1lKSByZXR1cm4gZmlsZU5hbWU7XG4gICAgICAgICAgICBjb25zdCBleHRlbnNpb24gPSBmb3JtYXQgPT09ICd0dXJ0bGUnID8gJy50dGwnIDogJy5yZGYnO1xuICAgICAgICAgICAgcmV0dXJuIGBnZW5lcmF0ZWQtZmlsZSR7ZXh0ZW5zaW9ufWA7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0dXAgc2VyaWFsaXplciBtb2NrIC0gbWFrZSBpdCBmb3JtYXQtYXdhcmVcbiAgICAgICAgbW9ja1JERlNlcmlhbGl6ZXIuc2VyaWFsaXplLm1vY2tJbXBsZW1lbnRhdGlvbigoZ3JhcGgsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRyaXBsZUNvdW50ID0gZ3JhcGguc2l6ZSgpO1xuICAgICAgICAgICAgbGV0IGNvbnRlbnQ6IHN0cmluZztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc3dpdGNoIChvcHRpb25zLmZvcm1hdCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2pzb24tbGQnOlxuICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJAY29udGV4dFwiOiB7IFwiZXhcIjogXCJodHRwOi8vZXhhbXBsZS5vcmcvXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiQGdyYXBoXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQGlkXCI6IFwiaHR0cDovL2V4YW1wbGUub3JnL3BlcnNvbi8xXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaHR0cDovL2V4YW1wbGUub3JnL25hbWVcIjogeyBcIkB2YWx1ZVwiOiBcIkpvaG4gRG9lXCIgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfSwgbnVsbCwgMik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ24tdHJpcGxlcyc6XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSAnPGh0dHA6Ly9leGFtcGxlLm9yZy9wZXJzb24vMT4gPGh0dHA6Ly9leGFtcGxlLm9yZy9uYW1lPiBcIkpvaG4gRG9lXCIgLic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3R1cnRsZSc6XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9ICdAcHJlZml4IGV4OiA8aHR0cDovL2V4YW1wbGUub3JnLz4gLlxcbjxodHRwOi8vZXhhbXBsZS5vcmcvcGVyc29uLzE+IDxodHRwOi8vZXhhbXBsZS5vcmcvbmFtZT4gXCJKb2huIERvZVwiIC4nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpc1N1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgaXNGYWlsdXJlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZTogKCkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgdHJpcGxlQ291bnQsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogb3B0aW9ucy5mb3JtYXRcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBlcnJvclZhbHVlOiAoKSA9PiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNldHVwIG5hbWVzcGFjZSBtYW5hZ2VyIG1vY2tcbiAgICAgICAgbW9ja05hbWVzcGFjZU1hbmFnZXIuaGFzUHJlZml4Lm1vY2tSZXR1cm5WYWx1ZShmYWxzZSk7XG4gICAgICAgIG1vY2tOYW1lc3BhY2VNYW5hZ2VyLmFkZEJpbmRpbmcubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHt9KTtcbiAgICAgICAgbW9ja05hbWVzcGFjZU1hbmFnZXIuY29tcHJlc3NJUkkubW9ja0ltcGxlbWVudGF0aW9uKChpcmkpID0+IGlyaS50b1N0cmluZygpKTtcbiAgICAgICAgbW9ja05hbWVzcGFjZU1hbmFnZXIuZ2V0QWxsQmluZGluZ3MubW9ja1JldHVyblZhbHVlKFtcbiAgICAgICAgICAgIHsgcHJlZml4OiAnZXgnLCBuYW1lc3BhY2U6IHsgdG9TdHJpbmc6ICgpID0+ICdodHRwOi8vZXhhbXBsZS5vcmcvJyB9IH0sXG4gICAgICAgICAgICB7IHByZWZpeDogJ2ZvYWYnLCBuYW1lc3BhY2U6IHsgdG9TdHJpbmc6ICgpID0+ICdodHRwOi8veG1sbnMuY29tL2ZvYWYvMC4xLycgfSB9XG4gICAgICAgIF0pO1xuICAgICAgICBtb2NrTmFtZXNwYWNlTWFuYWdlci5nZW5lcmF0ZVByZWZpeERlY2xhcmF0aW9ucy5tb2NrUmV0dXJuVmFsdWUoJ0BwcmVmaXggZXg6IDxodHRwOi8vZXhhbXBsZS5vcmcvPiAuJyk7XG4gICAgICAgIG1vY2tOYW1lc3BhY2VNYW5hZ2VyLmdldE5hbWVzcGFjZS5tb2NrUmV0dXJuVmFsdWUobnVsbCk7XG4gICAgICAgIG1vY2tOYW1lc3BhY2VNYW5hZ2VyLmV4cGFuZENVUklFLm1vY2tSZXR1cm5WYWx1ZSh7IGlzU3VjY2VzczogZmFsc2UgfSk7XG4gICAgICAgIFxuICAgICAgICBtb2NrUkRGVmFsaWRhdG9yLnZhbGlkYXRlR3JhcGgubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgIGlzU3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIGlzRmFpbHVyZTogZmFsc2UsXG4gICAgICAgICAgICBnZXRWYWx1ZTogKCkgPT4gKHtcbiAgICAgICAgICAgICAgICBpc1ZhbGlkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVycm9yczogW10sXG4gICAgICAgICAgICAgICAgd2FybmluZ3M6IFtdXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGVycm9yVmFsdWU6ICgpID0+IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICByZGZTZXJ2aWNlID0gbmV3IFJERlNlcnZpY2UobW9ja0FwcCk7XG4gICAgICAgIGdyYXBoID0gbmV3IEdyYXBoKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgc29tZSB0ZXN0IGRhdGFcbiAgICAgICAgY29uc3Qgc3ViamVjdCA9IG5ldyBJUkkoJ2h0dHA6Ly9leGFtcGxlLm9yZy9wZXJzb24vMScpO1xuICAgICAgICBjb25zdCBwcmVkaWNhdGUgPSBuZXcgSVJJKCdodHRwOi8vZXhhbXBsZS5vcmcvbmFtZScpO1xuICAgICAgICBjb25zdCBvYmplY3QgPSBMaXRlcmFsLnN0cmluZygnSm9obiBEb2UnKTtcbiAgICAgICAgXG4gICAgICAgIGdyYXBoLmFkZChuZXcgVHJpcGxlKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0KSk7XG4gICAgfSk7XG4gICAgXG4gICAgZGVzY3JpYmUoJ2V4cG9ydEdyYXBoJywgKCkgPT4ge1xuICAgICAgICBpdCgnc2hvdWxkIGV4cG9ydCBncmFwaCBpbiBUdXJ0bGUgZm9ybWF0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmRmU2VydmljZS5leHBvcnRHcmFwaChncmFwaCwge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ3R1cnRsZScsXG4gICAgICAgICAgICAgICAgc2F2ZVRvVmF1bHQ6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGV4cG9ydERhdGEgPSByZXN1bHQuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIGV4cGVjdChleHBvcnREYXRhLmZvcm1hdCkudG9CZSgndHVydGxlJyk7XG4gICAgICAgICAgICBleHBlY3QoZXhwb3J0RGF0YS50cmlwbGVDb3VudCkudG9CZSgxKTtcbiAgICAgICAgICAgIGV4cGVjdChleHBvcnREYXRhLmNvbnRlbnQpLnRvQ29udGFpbignQHByZWZpeCcpO1xuICAgICAgICAgICAgZXhwZWN0KGV4cG9ydERhdGEuY29udGVudCkudG9Db250YWluKCdKb2huIERvZScpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGl0KCdzaG91bGQgZXhwb3J0IGdyYXBoIGluIEpTT04tTEQgZm9ybWF0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmRmU2VydmljZS5leHBvcnRHcmFwaChncmFwaCwge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ2pzb24tbGQnLFxuICAgICAgICAgICAgICAgIHNhdmVUb1ZhdWx0OiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuaXNTdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBleHBvcnREYXRhID0gcmVzdWx0LmdldFZhbHVlKCk7XG4gICAgICAgICAgICBleHBlY3QoZXhwb3J0RGF0YS5mb3JtYXQpLnRvQmUoJ2pzb24tbGQnKTtcbiAgICAgICAgICAgIGV4cGVjdChleHBvcnREYXRhLnRyaXBsZUNvdW50KS50b0JlKDEpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTaG91bGQgYmUgdmFsaWQgSlNPTlxuICAgICAgICAgICAgY29uc3QganNvbkRhdGEgPSBKU09OLnBhcnNlKGV4cG9ydERhdGEuY29udGVudCk7XG4gICAgICAgICAgICBleHBlY3QoanNvbkRhdGFbJ0Bjb250ZXh0J10pLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBleHBlY3QoanNvbkRhdGFbJ0BncmFwaCddKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgZXhwb3J0IG9wdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyBNb2NrIHZhbGlkYXRpb24gZmFpbHVyZSBmb3IgaW52YWxpZCBmb3JtYXRcbiAgICAgICAgICAgIG1vY2tSREZWYWxpZGF0b3IudmFsaWRhdGVFeHBvcnRPcHRpb25zLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgICAgaXNTdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0ZhaWx1cmU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWU6ICgpID0+IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3JWYWx1ZTogKCkgPT4gJ1Vuc3VwcG9ydGVkIGZvcm1hdDogaW52YWxpZCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZGZTZXJ2aWNlLmV4cG9ydEdyYXBoKGdyYXBoLCB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnaW52YWxpZCcgYXMgYW55LFxuICAgICAgICAgICAgICAgIHNhdmVUb1ZhdWx0OiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuaXNGYWlsdXJlKS50b0JlKHRydWUpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvclZhbHVlKCkpLnRvQ29udGFpbignVW5zdXBwb3J0ZWQgZm9ybWF0OiBpbnZhbGlkJyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIFxuICAgIGRlc2NyaWJlKCdpbXBvcnRSREYnLCAoKSA9PiB7XG4gICAgICAgIGl0KCdzaG91bGQgaW1wb3J0IFR1cnRsZSBmb3JtYXQgUkRGJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHVydGxlQ29udGVudCA9IGBcbiAgICAgICAgICAgICAgICBAcHJlZml4IGV4OiA8aHR0cDovL2V4YW1wbGUub3JnLz4gLlxuICAgICAgICAgICAgICAgIGV4OnBlcnNvbjEgZXg6bmFtZSBcIkphbmUgU21pdGhcIiAuXG4gICAgICAgICAgICAgICAgZXg6cGVyc29uMSBleDphZ2UgXCIzMFwiXl48aHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEjaW50ZWdlcj4gLlxuICAgICAgICAgICAgYDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmRmU2VydmljZS5pbXBvcnRSREYodHVydGxlQ29udGVudCwgZ3JhcGgsIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICd0dXJ0bGUnLFxuICAgICAgICAgICAgICAgIG1lcmdlTW9kZTogJ21lcmdlJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuaXNTdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCB7IGdyYXBoOiB1cGRhdGVkR3JhcGgsIGltcG9ydGVkIH0gPSByZXN1bHQuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIGV4cGVjdChpbXBvcnRlZC50cmlwbGVDb3VudCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgICAgICAgZXhwZWN0KHVwZGF0ZWRHcmFwaC5zaXplKCkpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMSk7IC8vIFNob3VsZCBoYXZlIGF0IGxlYXN0IHRoZSBpbXBvcnRlZCBkYXRhXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaXQoJ3Nob3VsZCBpbXBvcnQgSlNPTi1MRCBmb3JtYXQgUkRGJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QganNvbmxkQ29udGVudCA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBcIkBjb250ZXh0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJleFwiOiBcImh0dHA6Ly9leGFtcGxlLm9yZy9cIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJAZ3JhcGhcIjogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIkBpZFwiOiBcImV4OnBlcnNvbjJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZXg6bmFtZVwiOiB7IFwiQHZhbHVlXCI6IFwiQm9iIEpvaG5zb25cIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJleDphZ2VcIjogeyBcIkB2YWx1ZVwiOiBcIjI1XCIsIFwiQHR5cGVcIjogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYSNpbnRlZ2VyXCIgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJkZlNlcnZpY2UuaW1wb3J0UkRGKGpzb25sZENvbnRlbnQsIGdyYXBoLCB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnanNvbi1sZCcsXG4gICAgICAgICAgICAgICAgbWVyZ2VNb2RlOiAnbWVyZ2UnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHsgaW1wb3J0ZWQgfSA9IHJlc3VsdC5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgZXhwZWN0KGltcG9ydGVkLnRyaXBsZUNvdW50KS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSBpbXBvcnQgb3B0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIE1vY2sgdmFsaWRhdGlvbiBmYWlsdXJlIGZvciBpbnZhbGlkIGZvcm1hdFxuICAgICAgICAgICAgbW9ja1JERlZhbGlkYXRvci52YWxpZGF0ZUltcG9ydE9wdGlvbnMubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICBpc1N1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzRmFpbHVyZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZTogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvclZhbHVlOiAoKSA9PiAnVW5zdXBwb3J0ZWQgaW1wb3J0IGZvcm1hdDogaW52YWxpZCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZGZTZXJ2aWNlLmltcG9ydFJERignaW52YWxpZCBjb250ZW50JywgZ3JhcGgsIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdpbnZhbGlkJyBhcyBhbnksXG4gICAgICAgICAgICAgICAgbWVyZ2VNb2RlOiAnbWVyZ2UnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5pc0ZhaWx1cmUpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yVmFsdWUoKSkudG9Db250YWluKCdVbnN1cHBvcnRlZCBpbXBvcnQgZm9ybWF0OiBpbnZhbGlkJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgcmVwbGFjZSBtZXJnZSBtb2RlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTaXplID0gZ3JhcGguc2l6ZSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCB0dXJ0bGVDb250ZW50ID0gYFxuICAgICAgICAgICAgICAgIEBwcmVmaXggZXg6IDxodHRwOi8vZXhhbXBsZS5vcmcvPiAuXG4gICAgICAgICAgICAgICAgZXg6bmV3cGVyc29uIGV4Om5hbWUgXCJOZXcgUGVyc29uXCIgLlxuICAgICAgICAgICAgYDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTW9jayBzdWNjZXNzZnVsIHBhcnNpbmcgd2l0aCBzcGVjaWZpYyBkYXRhIGZvciByZXBsYWNlIG1vZGVcbiAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VtZW50R3JhcGggPSBuZXcgR3JhcGgoKTtcbiAgICAgICAgICAgIHJlcGxhY2VtZW50R3JhcGguYWRkKG5ldyBUcmlwbGUoXG4gICAgICAgICAgICAgICAgbmV3IElSSSgnaHR0cDovL2V4YW1wbGUub3JnL25ld3BlcnNvbicpLFxuICAgICAgICAgICAgICAgIG5ldyBJUkkoJ2h0dHA6Ly9leGFtcGxlLm9yZy9uYW1lJyksXG4gICAgICAgICAgICAgICAgTGl0ZXJhbC5zdHJpbmcoJ05ldyBQZXJzb24nKVxuICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG1vY2tSREZQYXJzZXIucGFyc2UubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICBpc1N1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgaXNGYWlsdXJlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZTogKCkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGg6IHJlcGxhY2VtZW50R3JhcGgsXG4gICAgICAgICAgICAgICAgICAgIHRyaXBsZUNvdW50OiAxLFxuICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VzOiB7ICdleCc6ICdodHRwOi8vZXhhbXBsZS5vcmcvJyB9LFxuICAgICAgICAgICAgICAgICAgICB3YXJuaW5nczogW11cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBlcnJvclZhbHVlOiAoKSA9PiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmRmU2VydmljZS5pbXBvcnRSREYodHVydGxlQ29udGVudCwgZ3JhcGgsIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICd0dXJ0bGUnLFxuICAgICAgICAgICAgICAgIG1lcmdlTW9kZTogJ3JlcGxhY2UnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHsgZ3JhcGg6IHVwZGF0ZWRHcmFwaCB9ID0gcmVzdWx0LmdldFZhbHVlKCk7XG4gICAgICAgICAgICAvLyBJbiByZXBsYWNlIG1vZGUsIHNob3VsZCByZXR1cm4gdGhlIHJlcGxhY2VtZW50IGdyYXBoXG4gICAgICAgICAgICBleHBlY3QodXBkYXRlZEdyYXBoLnNpemUoKSkudG9CZSgxKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgXG4gICAgZGVzY3JpYmUoJ2dldFN1cHBvcnRlZEZvcm1hdHMnLCAoKSA9PiB7XG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIGFsbCBzdXBwb3J0ZWQgZm9ybWF0cycsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdHMgPSByZGZTZXJ2aWNlLmdldFN1cHBvcnRlZEZvcm1hdHMoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KGZvcm1hdHMpLnRvQ29udGFpbigndHVydGxlJyk7XG4gICAgICAgICAgICBleHBlY3QoZm9ybWF0cykudG9Db250YWluKCduLXRyaXBsZXMnKTtcbiAgICAgICAgICAgIGV4cGVjdChmb3JtYXRzKS50b0NvbnRhaW4oJ2pzb24tbGQnKTtcbiAgICAgICAgICAgIGV4cGVjdChmb3JtYXRzKS50b0NvbnRhaW4oJ3JkZi14bWwnKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgXG4gICAgZGVzY3JpYmUoJ2dldEZvcm1hdEluZm8nLCAoKSA9PiB7XG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIGZvcm1hdCBpbmZvcm1hdGlvbicsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZm8gPSByZGZTZXJ2aWNlLmdldEZvcm1hdEluZm8oJ3R1cnRsZScpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBleHBlY3QoaW5mby5leHRlbnNpb24pLnRvQmUoJy50dGwnKTtcbiAgICAgICAgICAgIGV4cGVjdChpbmZvLm1pbWVUeXBlKS50b0JlKCd0ZXh0L3R1cnRsZScpO1xuICAgICAgICAgICAgZXhwZWN0KGluZm8ubmFtZSkudG9CZSgnVHVydGxlJyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIFxuICAgIGRlc2NyaWJlKCdleHBvcnRRdWVyeVJlc3VsdHMnLCAoKSA9PiB7XG4gICAgICAgIGl0KCdzaG91bGQgZXhwb3J0IFNQQVJRTCBxdWVyeSByZXN1bHRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlSZXN1bHRzID0gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViamVjdDogJ2h0dHA6Ly9leGFtcGxlLm9yZy9wZXJzb24vMScsXG4gICAgICAgICAgICAgICAgICAgIHByZWRpY2F0ZTogJ2h0dHA6Ly9leGFtcGxlLm9yZy9uYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiAnSm9obiBEb2UnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHN1YmplY3Q6ICdodHRwOi8vZXhhbXBsZS5vcmcvcGVyc29uLzEnLFxuICAgICAgICAgICAgICAgICAgICBwcmVkaWNhdGU6ICdodHRwOi8vZXhhbXBsZS5vcmcvYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiAnMzAnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmRmU2VydmljZS5leHBvcnRRdWVyeVJlc3VsdHMoXG4gICAgICAgICAgICAgICAgcXVlcnlSZXN1bHRzLFxuICAgICAgICAgICAgICAgICd0dXJ0bGUnLFxuICAgICAgICAgICAgICAgICdxdWVyeS1yZXN1bHRzJyxcbiAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGV4cG9ydERhdGEgPSByZXN1bHQuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIGV4cGVjdChleHBvcnREYXRhLmZvcm1hdCkudG9CZSgndHVydGxlJyk7XG4gICAgICAgICAgICBleHBlY3QoZXhwb3J0RGF0YS50cmlwbGVDb3VudCkudG9CZSgyKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgXG4gICAgZGVzY3JpYmUoJ2ltcG9ydEZyb21WYXVsdEZpbGUnLCAoKSA9PiB7XG4gICAgICAgIGl0KCdzaG91bGQgaW1wb3J0IFJERiBmcm9tIHZhdWx0IGZpbGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtb2NrRmlsZSA9IHtcbiAgICAgICAgICAgICAgICBwYXRoOiAndGVzdC50dGwnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd0ZXN0LnR0bCdcbiAgICAgICAgICAgIH0gYXMgYW55O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBNb2NrIHN1Y2Nlc3NmdWwgZmlsZSByZWFkXG4gICAgICAgICAgICBtb2NrUkRGRmlsZU1hbmFnZXIucmVhZEZyb21WYXVsdC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgICAgaXNTdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzRmFpbHVyZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWU6ICgpID0+ICdAcHJlZml4IGV4OiA8aHR0cDovL2V4YW1wbGUub3JnLz4gLiBleDpwZXJzb24xIGV4Om5hbWUgXCJUZXN0IFBlcnNvblwiIC4nLFxuICAgICAgICAgICAgICAgIGVycm9yVmFsdWU6ICgpID0+IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBNb2NrIGZvcm1hdCBkZXRlY3Rpb25cbiAgICAgICAgICAgIG1vY2tSREZGaWxlTWFuYWdlci5kZXRlY3RGb3JtYXRGcm9tRXh0ZW5zaW9uLm1vY2tSZXR1cm5WYWx1ZSgndHVydGxlJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE1vY2sgc3VjY2Vzc2Z1bCBwYXJzaW5nXG4gICAgICAgICAgICBjb25zdCB0ZXN0R3JhcGggPSBuZXcgR3JhcGgoKTtcbiAgICAgICAgICAgIHRlc3RHcmFwaC5hZGQobmV3IFRyaXBsZShcbiAgICAgICAgICAgICAgICBuZXcgSVJJKCdodHRwOi8vZXhhbXBsZS5vcmcvcGVyc29uMScpLFxuICAgICAgICAgICAgICAgIG5ldyBJUkkoJ2h0dHA6Ly9leGFtcGxlLm9yZy9uYW1lJyksXG4gICAgICAgICAgICAgICAgTGl0ZXJhbC5zdHJpbmcoJ1Rlc3QgUGVyc29uJylcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBtb2NrUkRGUGFyc2VyLnBhcnNlLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgICAgaXNTdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzRmFpbHVyZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWU6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIGdyYXBoOiB0ZXN0R3JhcGgsXG4gICAgICAgICAgICAgICAgICAgIHRyaXBsZUNvdW50OiAxLFxuICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VzOiB7ICdleCc6ICdodHRwOi8vZXhhbXBsZS5vcmcvJyB9LFxuICAgICAgICAgICAgICAgICAgICB3YXJuaW5nczogW11cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBlcnJvclZhbHVlOiAoKSA9PiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmRmU2VydmljZS5pbXBvcnRGcm9tVmF1bHRGaWxlKG1vY2tGaWxlLCBncmFwaCwge1xuICAgICAgICAgICAgICAgIG1lcmdlTW9kZTogJ21lcmdlJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuaXNTdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgICAgICAgZXhwZWN0KG1vY2tSREZGaWxlTWFuYWdlci5yZWFkRnJvbVZhdWx0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgndGVzdC50dGwnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpdCgnc2hvdWxkIGF1dG8tZGV0ZWN0IGZvcm1hdCBmcm9tIGZpbGUgZXh0ZW5zaW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW9ja0ZpbGUgPSB7XG4gICAgICAgICAgICAgICAgcGF0aDogJ3Rlc3QuanNvbmxkJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAndGVzdC5qc29ubGQnXG4gICAgICAgICAgICB9IGFzIGFueTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTW9jayBzdWNjZXNzZnVsIGZpbGUgcmVhZFxuICAgICAgICAgICAgbW9ja1JERkZpbGVNYW5hZ2VyLnJlYWRGcm9tVmF1bHQubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgICAgIGlzU3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc0ZhaWx1cmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGdldFZhbHVlOiAoKSA9PiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgIFwiQGNvbnRleHRcIjogeyBcImV4XCI6IFwiaHR0cDovL2V4YW1wbGUub3JnL1wiIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiQGdyYXBoXCI6IFtdXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgZXJyb3JWYWx1ZTogKCkgPT4gbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE1vY2sgZm9ybWF0IGRldGVjdGlvbiBmb3IgSlNPTi1MRFxuICAgICAgICAgICAgbW9ja1JERkZpbGVNYW5hZ2VyLmRldGVjdEZvcm1hdEZyb21FeHRlbnNpb24ubW9ja1JldHVyblZhbHVlKCdqc29uLWxkJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE1vY2sgc3VjY2Vzc2Z1bCBwYXJzaW5nXG4gICAgICAgICAgICBtb2NrUkRGUGFyc2VyLnBhcnNlLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgICAgaXNTdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzRmFpbHVyZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWU6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIGdyYXBoOiBuZXcgR3JhcGgoKSxcbiAgICAgICAgICAgICAgICAgICAgdHJpcGxlQ291bnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZXM6IHsgJ2V4JzogJ2h0dHA6Ly9leGFtcGxlLm9yZy8nIH0sXG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzOiBbXVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGVycm9yVmFsdWU6ICgpID0+IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZGZTZXJ2aWNlLmltcG9ydEZyb21WYXVsdEZpbGUobW9ja0ZpbGUsIGdyYXBoLCB7XG4gICAgICAgICAgICAgICAgbWVyZ2VNb2RlOiAnbWVyZ2UnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICBleHBlY3QobW9ja1JERkZpbGVNYW5hZ2VyLmRldGVjdEZvcm1hdEZyb21FeHRlbnNpb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCd0ZXN0Lmpzb25sZCcpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGZpbGUgcmVhZCBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtb2NrRmlsZSA9IHtcbiAgICAgICAgICAgICAgICBwYXRoOiAnbm9uZXhpc3RlbnQudHRsJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnbm9uZXhpc3RlbnQudHRsJ1xuICAgICAgICAgICAgfSBhcyBhbnk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE1vY2sgZmlsZSByZWFkIGZhaWx1cmVcbiAgICAgICAgICAgIG1vY2tSREZGaWxlTWFuYWdlci5yZWFkRnJvbVZhdWx0Lm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICAgICAgICBpc1N1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzRmFpbHVyZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZTogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvclZhbHVlOiAoKSA9PiAnRmlsZSBub3QgZm91bmQ6IG5vbmV4aXN0ZW50LnR0bCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZGZTZXJ2aWNlLmltcG9ydEZyb21WYXVsdEZpbGUobW9ja0ZpbGUsIGdyYXBoLCB7XG4gICAgICAgICAgICAgICAgbWVyZ2VNb2RlOiAnbWVyZ2UnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5pc0ZhaWx1cmUpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yVmFsdWUoKSkudG9Db250YWluKCdGaWxlIG5vdCBmb3VuZCcpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBcbiAgICBkZXNjcmliZSgnbGlzdFJERkZpbGVzJywgKCkgPT4ge1xuICAgICAgICBpdCgnc2hvdWxkIGxpc3QgUkRGIGZpbGVzIGluIHZhdWx0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW9ja0ZpbGVzID0gW1xuICAgICAgICAgICAgICAgIHsgbmFtZTogJ3Rlc3QudHRsJywgcGF0aDogJ3Rlc3QudHRsJywgZXh0ZW5zaW9uOiAndHRsJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ2RhdGEucmRmJywgcGF0aDogJ2RhdGEucmRmJywgZXh0ZW5zaW9uOiAncmRmJyB9LFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ2V4YW1wbGUuanNvbmxkJywgcGF0aDogJ2V4YW1wbGUuanNvbmxkJywgZXh0ZW5zaW9uOiAnanNvbmxkJyB9XG4gICAgICAgICAgICBdIGFzIGFueTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbW9ja1JERkZpbGVNYW5hZ2VyLmxpc3RSREZGaWxlcy5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgICAgaXNTdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzRmFpbHVyZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWU6ICgpID0+IG1vY2tGaWxlcyxcbiAgICAgICAgICAgICAgICBlcnJvclZhbHVlOiAoKSA9PiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmRmU2VydmljZS5saXN0UkRGRmlsZXMoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBmaWxlcyA9IHJlc3VsdC5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgZXhwZWN0KGZpbGVzKS50b0hhdmVMZW5ndGgoMyk7IC8vIFNob3VsZCBleGNsdWRlIG5vbi1SREYgZmlsZXNcbiAgICAgICAgICAgIGV4cGVjdChmaWxlcy5tYXAoZiA9PiBmLm5hbWUpKS50b0VxdWFsKFsndGVzdC50dGwnLCAnZGF0YS5yZGYnLCAnZXhhbXBsZS5qc29ubGQnXSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaXQoJ3Nob3VsZCBmaWx0ZXIgZmlsZXMgYnkgZm9sZGVyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW9ja0ZpbGVzID0gW1xuICAgICAgICAgICAgICAgIHsgbmFtZTogJ3Rlc3QudHRsJywgcGF0aDogJ2ZvbGRlcjEvdGVzdC50dGwnLCBleHRlbnNpb246ICd0dGwnIH0sXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnZXhhbXBsZS5qc29ubGQnLCBwYXRoOiAnZm9sZGVyMS9leGFtcGxlLmpzb25sZCcsIGV4dGVuc2lvbjogJ2pzb25sZCcgfVxuICAgICAgICAgICAgXSBhcyBhbnk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG1vY2tSREZGaWxlTWFuYWdlci5saXN0UkRGRmlsZXMubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgICAgICAgIGlzU3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc0ZhaWx1cmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGdldFZhbHVlOiAoKSA9PiBtb2NrRmlsZXMsXG4gICAgICAgICAgICAgICAgZXJyb3JWYWx1ZTogKCkgPT4gbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJkZlNlcnZpY2UubGlzdFJERkZpbGVzKCdmb2xkZXIxJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuaXNTdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgICAgICAgY29uc3QgZmlsZXMgPSByZXN1bHQuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIGV4cGVjdChmaWxlcykudG9IYXZlTGVuZ3RoKDIpO1xuICAgICAgICAgICAgZXhwZWN0KGZpbGVzLm1hcChmID0+IGYucGF0aCkpLnRvRXF1YWwoWydmb2xkZXIxL3Rlc3QudHRsJywgJ2ZvbGRlcjEvZXhhbXBsZS5qc29ubGQnXSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIFxuICAgIGRlc2NyaWJlKCd2YWxpZGF0ZUdyYXBoJywgKCkgPT4ge1xuICAgICAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIGdyYXBoIHdpdGggZGVmYXVsdCBvcHRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmRmU2VydmljZS52YWxpZGF0ZUdyYXBoKGdyYXBoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uID0gcmVzdWx0LmdldFZhbHVlKCk7XG4gICAgICAgICAgICBleHBlY3QodmFsaWRhdGlvbi5pc1ZhbGlkKS50b0JlKHRydWUpO1xuICAgICAgICAgICAgZXhwZWN0KEFycmF5LmlzQXJyYXkodmFsaWRhdGlvbi5lcnJvcnMpKS50b0JlKHRydWUpO1xuICAgICAgICAgICAgZXhwZWN0KEFycmF5LmlzQXJyYXkodmFsaWRhdGlvbi53YXJuaW5ncykpLnRvQmUodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSBncmFwaCB3aXRoIGN1c3RvbSBvcHRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBzdHJpY3RNb2RlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjaGVja05hbWVzcGFjZXM6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJkZlNlcnZpY2UudmFsaWRhdGVHcmFwaChncmFwaCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuaXNTdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBcbiAgICBkZXNjcmliZSgnY3JlYXRlTm9kZUZyb21WYWx1ZScsICgpID0+IHtcbiAgICAgICAgaXQoJ3Nob3VsZCBjcmVhdGUgSVJJIGZyb20gc3RyaW5nIHdpdGggcHJvdG9jb2wnLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVJlc3VsdHMgPSBbe1xuICAgICAgICAgICAgICAgIHN1YmplY3Q6ICdodHRwOi8vZXhhbXBsZS5vcmcvcGVyc29uLzEnLFxuICAgICAgICAgICAgICAgIHByZWRpY2F0ZTogJ2h0dHA6Ly9leGFtcGxlLm9yZy9uYW1lJyxcbiAgICAgICAgICAgICAgICBvYmplY3Q6ICdKb2huIERvZSdcbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZGZTZXJ2aWNlLmV4cG9ydFF1ZXJ5UmVzdWx0cyhxdWVyeVJlc3VsdHMsICd0dXJ0bGUnLCAndGVzdCcsIGZhbHNlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdCkucmVzb2x2ZXMudG9CZURlZmluZWQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpdCgnc2hvdWxkIGNyZWF0ZSBCbGFua05vZGUgZnJvbSBzdHJpbmcgd2l0aCBfOiBwcmVmaXgnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVJlc3VsdHMgPSBbe1xuICAgICAgICAgICAgICAgIHN1YmplY3Q6ICdfOmIxJyxcbiAgICAgICAgICAgICAgICBwcmVkaWNhdGU6ICdodHRwOi8vZXhhbXBsZS5vcmcvbmFtZScsXG4gICAgICAgICAgICAgICAgb2JqZWN0OiAnSm9obiBEb2UnXG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBzZXJpYWxpemVyIG1vY2sgdG8gaGFuZGxlIGJsYW5rIG5vZGUgc3ViamVjdHNcbiAgICAgICAgICAgIG1vY2tSREZTZXJpYWxpemVyLnNlcmlhbGl6ZS5tb2NrSW1wbGVtZW50YXRpb25PbmNlKChncmFwaCwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlzU3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaXNGYWlsdXJlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0VmFsdWU6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnXzpiMSA8aHR0cDovL2V4YW1wbGUub3JnL25hbWU+IFwiSm9obiBEb2VcIiAuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaXBsZUNvdW50OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBvcHRpb25zLmZvcm1hdFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JWYWx1ZTogKCkgPT4gbnVsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmRmU2VydmljZS5leHBvcnRRdWVyeVJlc3VsdHMocXVlcnlSZXN1bHRzLCAndHVydGxlJywgJ3Rlc3QnLCBmYWxzZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuaXNTdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgICAgICAgY29uc3QgZXhwb3J0ZWQgPSByZXN1bHQuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIGV4cGVjdChleHBvcnRlZC5jb250ZW50KS50b0NvbnRhaW4oJ186YjEnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpdCgnc2hvdWxkIGNyZWF0ZSBMaXRlcmFsIGZyb20gbnVtYmVyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlSZXN1bHRzID0gW3tcbiAgICAgICAgICAgICAgICBzdWJqZWN0OiAnaHR0cDovL2V4YW1wbGUub3JnL3BlcnNvbi8xJyxcbiAgICAgICAgICAgICAgICBwcmVkaWNhdGU6ICdodHRwOi8vZXhhbXBsZS5vcmcvYWdlJyxcbiAgICAgICAgICAgICAgICBvYmplY3Q6IDI1XG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmRmU2VydmljZS5leHBvcnRRdWVyeVJlc3VsdHMocXVlcnlSZXN1bHRzLCAndHVydGxlJywgJ3Rlc3QnLCBmYWxzZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuaXNTdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGl0KCdzaG91bGQgY3JlYXRlIExpdGVyYWwgZnJvbSBib29sZWFuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlSZXN1bHRzID0gW3tcbiAgICAgICAgICAgICAgICBzdWJqZWN0OiAnaHR0cDovL2V4YW1wbGUub3JnL3BlcnNvbi8xJyxcbiAgICAgICAgICAgICAgICBwcmVkaWNhdGU6ICdodHRwOi8vZXhhbXBsZS5vcmcvYWN0aXZlJyxcbiAgICAgICAgICAgICAgICBvYmplY3Q6IHRydWVcbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZGZTZXJ2aWNlLmV4cG9ydFF1ZXJ5UmVzdWx0cyhxdWVyeVJlc3VsdHMsICd0dXJ0bGUnLCAndGVzdCcsIGZhbHNlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaXQoJ3Nob3VsZCBjcmVhdGUgdHlwZWQgTGl0ZXJhbCBmcm9tIG9iamVjdCB3aXRoIGRhdGF0eXBlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlSZXN1bHRzID0gW3tcbiAgICAgICAgICAgICAgICBzdWJqZWN0OiAnaHR0cDovL2V4YW1wbGUub3JnL3BlcnNvbi8xJyxcbiAgICAgICAgICAgICAgICBwcmVkaWNhdGU6ICdodHRwOi8vZXhhbXBsZS5vcmcvYmlydGhEYXRlJyxcbiAgICAgICAgICAgICAgICBvYmplY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2xpdGVyYWwnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJzE5OTAtMDEtMDEnLFxuICAgICAgICAgICAgICAgICAgICBkYXRhdHlwZTogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hI2RhdGUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJkZlNlcnZpY2UuZXhwb3J0UXVlcnlSZXN1bHRzKHF1ZXJ5UmVzdWx0cywgJ3R1cnRsZScsICd0ZXN0JywgZmFsc2UpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmlzU3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpdCgnc2hvdWxkIGNyZWF0ZSBsYW5ndWFnZS10YWdnZWQgTGl0ZXJhbCBmcm9tIG9iamVjdCB3aXRoIGxhbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVJlc3VsdHMgPSBbe1xuICAgICAgICAgICAgICAgIHN1YmplY3Q6ICdodHRwOi8vZXhhbXBsZS5vcmcvcGVyc29uLzEnLFxuICAgICAgICAgICAgICAgIHByZWRpY2F0ZTogJ2h0dHA6Ly9leGFtcGxlLm9yZy9uYW1lJyxcbiAgICAgICAgICAgICAgICBvYmplY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2xpdGVyYWwnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ0plYW4nLFxuICAgICAgICAgICAgICAgICAgICBsYW5nOiAnZnInXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJkZlNlcnZpY2UuZXhwb3J0UXVlcnlSZXN1bHRzKHF1ZXJ5UmVzdWx0cywgJ3R1cnRsZScsICd0ZXN0JywgZmFsc2UpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmlzU3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpdCgnc2hvdWxkIGhhbmRsZSBudWxsIHZhbHVlcyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlSZXN1bHRzID0gW3tcbiAgICAgICAgICAgICAgICBzdWJqZWN0OiAnaHR0cDovL2V4YW1wbGUub3JnL3BlcnNvbi8xJyxcbiAgICAgICAgICAgICAgICBwcmVkaWNhdGU6ICdodHRwOi8vZXhhbXBsZS5vcmcvbmFtZScsXG4gICAgICAgICAgICAgICAgb2JqZWN0OiBudWxsXG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmRmU2VydmljZS5leHBvcnRRdWVyeVJlc3VsdHMocXVlcnlSZXN1bHRzLCAndHVydGxlJywgJ3Rlc3QnLCBmYWxzZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuaXNTdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBcbiAgICBkZXNjcmliZSgnZXJyb3IgaGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgICAgIGl0KCdzaG91bGQgaGFuZGxlIHNlcmlhbGl6YXRpb24gZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGFuIGludmFsaWQgZ3JhcGggc2NlbmFyaW9cbiAgICAgICAgICAgIGNvbnN0IGludmFsaWRHcmFwaCA9IG5ldyBHcmFwaCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBNb2NrIHNlcmlhbGl6YXRpb24gZmFpbHVyZVxuICAgICAgICAgICAgbW9ja1JERlNlcmlhbGl6ZXIuc2VyaWFsaXplLm1vY2tJbXBsZW1lbnRhdGlvbk9uY2UoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlzU3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGlzRmFpbHVyZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0VmFsdWU6ICgpID0+IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yVmFsdWU6ICgpID0+ICdTZXJpYWxpemF0aW9uIGZhaWxlZDogSW52YWxpZCBiYXNlIElSSSdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJkZlNlcnZpY2UuZXhwb3J0R3JhcGgoaW52YWxpZEdyYXBoLCB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiAndHVydGxlJyxcbiAgICAgICAgICAgICAgICBiYXNlSVJJOiAnaW52YWxpZC11cmknLFxuICAgICAgICAgICAgICAgIHNhdmVUb1ZhdWx0OiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFNob3VsZCBoYW5kbGUgdGhlIGVycm9yIGdyYWNlZnVsbHlcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuaXNGYWlsdXJlKS50b0JlKHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGl0KCdzaG91bGQgaGFuZGxlIHBhcnNpbmcgZXJyb3JzIGluIHN0cmljdCBtb2RlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW52YWxpZENvbnRlbnQgPSAnVGhpcyBpcyBub3QgdmFsaWQgUkRGJztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTW9jayBwYXJzaW5nIGZhaWx1cmVcbiAgICAgICAgICAgIG1vY2tSREZQYXJzZXIucGFyc2UubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICBpc1N1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzRmFpbHVyZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZTogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvclZhbHVlOiAoKSA9PiAnSW52YWxpZCBSREYgc3ludGF4J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJkZlNlcnZpY2UuaW1wb3J0UkRGKGludmFsaWRDb250ZW50LCBncmFwaCwge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ3R1cnRsZScsXG4gICAgICAgICAgICAgICAgbWVyZ2VNb2RlOiAnbWVyZ2UnLFxuICAgICAgICAgICAgICAgIHN0cmljdE1vZGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmlzRmFpbHVyZSkudG9CZSh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpdCgnc2hvdWxkIGhhbmRsZSBtYWxmb3JtZWQgUkRGIGNvbnRlbnQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYWxmb3JtZWRDb250ZW50ID0gYFxuICAgICAgICAgICAgICAgIEBwcmVmaXggZXg6IDxodHRwOi8vZXhhbXBsZS5vcmcvPlxuICAgICAgICAgICAgICAgIGV4OnBlcnNvbjEgZXg6bmFtZSBcIlVuY2xvc2VkIHN0cmluZ1xuICAgICAgICAgICAgYDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmRmU2VydmljZS5pbXBvcnRSREYobWFsZm9ybWVkQ29udGVudCwgZ3JhcGgsIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICd0dXJ0bGUnLFxuICAgICAgICAgICAgICAgIG1lcmdlTW9kZTogJ21lcmdlJyxcbiAgICAgICAgICAgICAgICBzdHJpY3RNb2RlOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFNob3VsZCBmYWlsIG9yIHN1Y2NlZWQgd2l0aCB3YXJuaW5nc1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5pc1N1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBzdWNjZXNzZnVsLCBzaG91bGQgaGF2ZSB3YXJuaW5nc1xuICAgICAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2V0VmFsdWUoKS5pbXBvcnRlZC53YXJuaW5ncykudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvclZhbHVlKCkpLnRvQ29udGFpbigncGFyc2luZyBmYWlsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpdCgnc2hvdWxkIGhhbmRsZSBpbnZhbGlkIEpTT04tTEQgY29udGVudCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGludmFsaWRKc29uTEQgPSAneyBcImludmFsaWRcIjoganNvbiB9JzsgLy8gSW52YWxpZCBKU09OIHN5bnRheFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBNb2NrIHBhcnNpbmcgZmFpbHVyZSBmb3IgaW52YWxpZCBKU09OLUxEXG4gICAgICAgICAgICBtb2NrUkRGUGFyc2VyLnBhcnNlLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICAgICAgaXNTdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0ZhaWx1cmU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWU6ICgpID0+IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3JWYWx1ZTogKCkgPT4gJ0ludmFsaWQgSlNPTi1MRCBzeW50YXgnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmRmU2VydmljZS5pbXBvcnRSREYoaW52YWxpZEpzb25MRCwgZ3JhcGgsIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdqc29uLWxkJyxcbiAgICAgICAgICAgICAgICBtZXJnZU1vZGU6ICdtZXJnZScsXG4gICAgICAgICAgICAgICAgc3RyaWN0TW9kZTogdHJ1ZSAgLy8gRW5hYmxlIHN0cmljdCBtb2RlIHRvIGNhdGNoIHBhcnNpbmcgZXJyb3JzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5pc0ZhaWx1cmUpLnRvQmUodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgdmF1bHQgd3JpdGUgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gTW9jayBzYXZlIGZhaWx1cmVcbiAgICAgICAgICAgIG1vY2tSREZGaWxlTWFuYWdlci5zYXZlVG9WYXVsdC5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgICAgICAgaXNTdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0ZhaWx1cmU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWU6ICgpID0+IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3JWYWx1ZTogKCkgPT4gJ1dyaXRlIGZhaWxlZCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZGZTZXJ2aWNlLmV4cG9ydEdyYXBoKGdyYXBoLCB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiAndHVydGxlJyxcbiAgICAgICAgICAgICAgICBzYXZlVG9WYXVsdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBmaWxlTmFtZTogJ3Rlc3QudHRsJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuaXNGYWlsdXJlKS50b0JlKHRydWUpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvclZhbHVlKCkpLnRvQ29udGFpbignV3JpdGUgZmFpbGVkJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgbmFtZXNwYWNlIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRXaXRoQmFkTmFtZXNwYWNlID0gYFxuICAgICAgICAgICAgICAgIEBwcmVmaXggYmFkOiA8aW52YWxpZC11cmk+IC5cbiAgICAgICAgICAgICAgICBiYWQ6dGVzdCBiYWQ6cHJvcCBcInZhbHVlXCIgLlxuICAgICAgICAgICAgYDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTW9jayBwYXJzaW5nIHdpdGggd2FybmluZ3NcbiAgICAgICAgICAgIG1vY2tSREZQYXJzZXIucGFyc2UubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICBpc1N1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgaXNGYWlsdXJlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZTogKCkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGg6IG5ldyBHcmFwaCgpLFxuICAgICAgICAgICAgICAgICAgICB0cmlwbGVDb3VudDogMSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlczogeyAnYmFkJzogJ2ludmFsaWQtdXJpJyB9LFxuICAgICAgICAgICAgICAgICAgICB3YXJuaW5nczogWydJbnZhbGlkIG5hbWVzcGFjZSBVUkk6IGludmFsaWQtdXJpJ11cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBlcnJvclZhbHVlOiAoKSA9PiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTW9jayB2YWxpZGF0aW9uIHdpdGggd2FybmluZ3NcbiAgICAgICAgICAgIG1vY2tSREZWYWxpZGF0b3IudmFsaWRhdGVHcmFwaC5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICAgIGlzU3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc0ZhaWx1cmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGdldFZhbHVlOiAoKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB3YXJuaW5nczogW3sgbWVzc2FnZTogJ0ludmFsaWQgbmFtZXNwYWNlIFVSSSBkZXRlY3RlZCcgfV1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBlcnJvclZhbHVlOiAoKSA9PiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmRmU2VydmljZS5pbXBvcnRSREYoY29udGVudFdpdGhCYWROYW1lc3BhY2UsIGdyYXBoLCB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiAndHVydGxlJyxcbiAgICAgICAgICAgICAgICBtZXJnZU1vZGU6ICdtZXJnZScsXG4gICAgICAgICAgICAgICAgc3RyaWN0TW9kZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUlucHV0OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU2hvdWxkIHN1Y2NlZWQgd2l0aCB3YXJuaW5nc1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uID0gcmVzdWx0LmdldFZhbHVlKCk7XG4gICAgICAgICAgICBleHBlY3QodmFsaWRhdGlvbi5pbXBvcnRlZC53YXJuaW5ncy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpdCgnc2hvdWxkIGhhbmRsZSBlbXB0eSBncmFwaCBleHBvcnQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbXB0eUdyYXBoID0gbmV3IEdyYXBoKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJkZlNlcnZpY2UuZXhwb3J0R3JhcGgoZW1wdHlHcmFwaCwge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ3R1cnRsZScsXG4gICAgICAgICAgICAgICAgc2F2ZVRvVmF1bHQ6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBleHBvcnRlZCA9IHJlc3VsdC5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgZXhwZWN0KGV4cG9ydGVkLnRyaXBsZUNvdW50KS50b0JlKDApO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGl0KCdzaG91bGQgaGFuZGxlIHZlcnkgbGFyZ2UgZ3JhcGhzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGFyZ2VHcmFwaCA9IG5ldyBHcmFwaCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBZGQgbWFueSB0cmlwbGVzIHRvIHRlc3QgbWVtb3J5L3BlcmZvcm1hbmNlXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDA7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyaXBsZSA9IG5ldyBUcmlwbGUoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBJUkkoYGh0dHA6Ly9leGFtcGxlLm9yZy9wZXJzb24vJHtpfWApLFxuICAgICAgICAgICAgICAgICAgICBuZXcgSVJJKCdodHRwOi8vZXhhbXBsZS5vcmcvbmFtZScpLFxuICAgICAgICAgICAgICAgICAgICBMaXRlcmFsLnN0cmluZyhgUGVyc29uICR7aX1gKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbGFyZ2VHcmFwaC5hZGQodHJpcGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmRmU2VydmljZS5leHBvcnRHcmFwaChsYXJnZUdyYXBoLCB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnbi10cmlwbGVzJyxcbiAgICAgICAgICAgICAgICBzYXZlVG9WYXVsdDogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmlzU3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cG9ydGVkID0gcmVzdWx0LmdldFZhbHVlKCk7XG4gICAgICAgICAgICBleHBlY3QoZXhwb3J0ZWQudHJpcGxlQ291bnQpLnRvQmUoMTAwMCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIFxuICAgIGRlc2NyaWJlKCduYW1lc3BhY2UgbWFuYWdlbWVudCcsICgpID0+IHtcbiAgICAgICAgaXQoJ3Nob3VsZCB1c2UgY3VzdG9tIG5hbWVzcGFjZSBtYW5hZ2VyJywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbW9jayBjdXN0b20gbmFtZXNwYWNlIG1hbmFnZXJcbiAgICAgICAgICAgIGNvbnN0IE1vY2tlZE5hbWVzcGFjZU1hbmFnZXIgPSBOYW1lc3BhY2VNYW5hZ2VyIGFzIGplc3QuTW9ja2VkQ2xhc3M8dHlwZW9mIE5hbWVzcGFjZU1hbmFnZXI+O1xuICAgICAgICAgICAgY29uc3QgY3VzdG9tTmFtZXNwYWNlTWFuYWdlciA9IG5ldyBNb2NrZWROYW1lc3BhY2VNYW5hZ2VyKCk7XG4gICAgICAgICAgICAoY3VzdG9tTmFtZXNwYWNlTWFuYWdlci5oYXNQcmVmaXggYXMgamVzdC5Nb2NrKS5tb2NrSW1wbGVtZW50YXRpb24oKHByZWZpeDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWZpeCA9PT0gJ2N1c3RvbSc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIChjdXN0b21OYW1lc3BhY2VNYW5hZ2VyLmFkZEJpbmRpbmcgYXMgamVzdC5Nb2NrKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge30pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjdXN0b21OYW1lc3BhY2VNYW5hZ2VyLmFkZEJpbmRpbmcoJ2N1c3RvbScsICdodHRwOi8vY3VzdG9tLmV4YW1wbGUub3JnLycpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBjdXN0b21SREZTZXJ2aWNlID0gbmV3IFJERlNlcnZpY2UobW9ja0FwcCwgY3VzdG9tTmFtZXNwYWNlTWFuYWdlcik7XG4gICAgICAgICAgICBjb25zdCBuc01hbmFnZXIgPSBjdXN0b21SREZTZXJ2aWNlLmdldE5hbWVzcGFjZU1hbmFnZXIoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KG5zTWFuYWdlci5oYXNQcmVmaXgoJ2N1c3RvbScpKS50b0JlKHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGl0KCdzaG91bGQgcHJlc2VydmUgbmFtZXNwYWNlIGJpbmRpbmdzIGR1cmluZyBpbXBvcnQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0dXJ0bGVDb250ZW50ID0gYFxuICAgICAgICAgICAgICAgIEBwcmVmaXggY3VzdG9tOiA8aHR0cDovL2N1c3RvbS5leGFtcGxlLm9yZy8+IC5cbiAgICAgICAgICAgICAgICBAcHJlZml4IHRlc3Q6IDxodHRwOi8vdGVzdC5leGFtcGxlLm9yZy8+IC5cbiAgICAgICAgICAgICAgICBjdXN0b206aXRlbSB0ZXN0OnByb3BlcnR5IFwidmFsdWVcIiAuXG4gICAgICAgICAgICBgO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBNb2NrIHBhcnNpbmcgd2l0aCBjdXN0b20gbmFtZXNwYWNlc1xuICAgICAgICAgICAgbW9ja1JERlBhcnNlci5wYXJzZS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICAgIGlzU3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc0ZhaWx1cmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGdldFZhbHVlOiAoKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBncmFwaDogbmV3IEdyYXBoKCksXG4gICAgICAgICAgICAgICAgICAgIHRyaXBsZUNvdW50OiAxLFxuICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VzOiB7IFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2N1c3RvbSc6ICdodHRwOi8vY3VzdG9tLmV4YW1wbGUub3JnLycsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGVzdCc6ICdodHRwOi8vdGVzdC5leGFtcGxlLm9yZy8nXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzOiBbXVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGVycm9yVmFsdWU6ICgpID0+IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBNb2NrIG5hbWVzcGFjZSBtYW5hZ2VyIHRvIHNob3cgcHJlZml4ZXMgYWZ0ZXIgYmluZGluZ1xuICAgICAgICAgICAgbW9ja05hbWVzcGFjZU1hbmFnZXIuaGFzUHJlZml4Lm1vY2tJbXBsZW1lbnRhdGlvbigocHJlZml4OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlZml4ID09PSAnY3VzdG9tJyB8fCBwcmVmaXggPT09ICd0ZXN0JztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZGZTZXJ2aWNlLmltcG9ydFJERih0dXJ0bGVDb250ZW50LCBncmFwaCwge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ3R1cnRsZScsXG4gICAgICAgICAgICAgICAgbWVyZ2VNb2RlOiAnbWVyZ2UnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IG5zTWFuYWdlciA9IHJkZlNlcnZpY2UuZ2V0TmFtZXNwYWNlTWFuYWdlcigpO1xuICAgICAgICAgICAgZXhwZWN0KG5zTWFuYWdlci5oYXNQcmVmaXgoJ2N1c3RvbScpKS50b0JlKHRydWUpO1xuICAgICAgICAgICAgZXhwZWN0KG5zTWFuYWdlci5oYXNQcmVmaXgoJ3Rlc3QnKSkudG9CZSh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgXG4gICAgZGVzY3JpYmUoJ2V4cG9ydCB3aXRoIGZpbGUgb3BlcmF0aW9ucycsICgpID0+IHtcbiAgICAgICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICAgICAgICBtb2NrQXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aC5tb2NrUmV0dXJuVmFsdWUobnVsbCk7IC8vIEZpbGUgZG9lc24ndCBleGlzdFxuICAgICAgICAgICAgbW9ja0FwcC52YXVsdC5jcmVhdGUubW9ja1Jlc29sdmVkVmFsdWUoKTtcbiAgICAgICAgICAgIG1vY2tBcHAudmF1bHQuY3JlYXRlRm9sZGVyLm1vY2tSZXNvbHZlZFZhbHVlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaXQoJ3Nob3VsZCBzYXZlIHRvIHZhdWx0IHdpdGggY3VzdG9tIGZpbGVuYW1lJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmRmU2VydmljZS5leHBvcnRHcmFwaChncmFwaCwge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ3R1cnRsZScsXG4gICAgICAgICAgICAgICAgc2F2ZVRvVmF1bHQ6IHRydWUsXG4gICAgICAgICAgICAgICAgZmlsZU5hbWU6ICdjdXN0b20tbmFtZS50dGwnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICBleHBlY3QobW9ja0FwcC52YXVsdC5jcmVhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgICAgICAgICdjdXN0b20tbmFtZS50dGwnLFxuICAgICAgICAgICAgICAgIGV4cGVjdC5hbnkoU3RyaW5nKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpdCgnc2hvdWxkIHNhdmUgdG8gdmF1bHQgaW4gdGFyZ2V0IGZvbGRlcicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJkZlNlcnZpY2UuZXhwb3J0R3JhcGgoZ3JhcGgsIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICd0dXJ0bGUnLFxuICAgICAgICAgICAgICAgIHNhdmVUb1ZhdWx0OiB0cnVlLFxuICAgICAgICAgICAgICAgIHRhcmdldEZvbGRlcjogJ2V4cG9ydHMnLFxuICAgICAgICAgICAgICAgIGZpbGVOYW1lOiAndGVzdC50dGwnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICBleHBlY3QobW9ja0FwcC52YXVsdC5jcmVhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgICAgICAgICdleHBvcnRzL3Rlc3QudHRsJyxcbiAgICAgICAgICAgICAgICBleHBlY3QuYW55KFN0cmluZylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaXQoJ3Nob3VsZCBnZW5lcmF0ZSBmaWxlbmFtZSB3aGVuIG5vdCBwcm92aWRlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJkZlNlcnZpY2UuZXhwb3J0R3JhcGgoZ3JhcGgsIHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICd0dXJ0bGUnLFxuICAgICAgICAgICAgICAgIHNhdmVUb1ZhdWx0OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICBleHBlY3QobW9ja0FwcC52YXVsdC5jcmVhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgICAgICAgIGV4cGVjdC5zdHJpbmdNYXRjaGluZygvLipcXC50dGwkLyksXG4gICAgICAgICAgICAgICAgZXhwZWN0LmFueShTdHJpbmcpXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn0pO1xuXG5kZXNjcmliZSgnTmFtZXNwYWNlTWFuYWdlcicsICgpID0+IHtcbiAgICBsZXQgbmFtZXNwYWNlTWFuYWdlcjogTmFtZXNwYWNlTWFuYWdlcjtcbiAgICBcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgICAgLy8gVXNlIG1vY2sgZm9yIE5hbWVzcGFjZU1hbmFnZXIgdGVzdHMgdG9vXG4gICAgICAgIGNvbnN0IE1vY2tlZE5hbWVzcGFjZU1hbmFnZXIgPSBOYW1lc3BhY2VNYW5hZ2VyIGFzIGplc3QuTW9ja2VkQ2xhc3M8dHlwZW9mIE5hbWVzcGFjZU1hbmFnZXI+O1xuICAgICAgICBuYW1lc3BhY2VNYW5hZ2VyID0gbmV3IE1vY2tlZE5hbWVzcGFjZU1hbmFnZXIoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNldHVwIGRlZmF1bHQgYmVoYXZpb3IgZm9yIHRoZXNlIHNwZWNpZmljIHRlc3RzXG4gICAgICAgIChuYW1lc3BhY2VNYW5hZ2VyLmhhc1ByZWZpeCBhcyBqZXN0Lk1vY2spLm1vY2tJbXBsZW1lbnRhdGlvbigocHJlZml4OiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbJ3JkZicsICdyZGZzJywgJ293bCcsICd4c2QnLCAndGVzdCddLmluY2x1ZGVzKHByZWZpeCk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgKG5hbWVzcGFjZU1hbmFnZXIuYWRkQmluZGluZyBhcyBqZXN0Lk1vY2spLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSk7XG4gICAgICAgIFxuICAgICAgICAobmFtZXNwYWNlTWFuYWdlci5nZXROYW1lc3BhY2UgYXMgamVzdC5Nb2NrKS5tb2NrSW1wbGVtZW50YXRpb24oKHByZWZpeDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICBpZiAocHJlZml4ID09PSAndGVzdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0b1N0cmluZzogKCkgPT4gJ2h0dHA6Ly90ZXN0LmV4YW1wbGUub3JnLycgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIChuYW1lc3BhY2VNYW5hZ2VyLmV4cGFuZENVUklFIGFzIGplc3QuTW9jaykubW9ja0ltcGxlbWVudGF0aW9uKChjdXJpZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICBpZiAoY3VyaWUgPT09ICdyZGY6dHlwZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpc1N1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGdldFZhbHVlOiAoKSA9PiBuZXcgSVJJKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjdHlwZScpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGlzU3VjY2VzczogZmFsc2UgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAobmFtZXNwYWNlTWFuYWdlci5jb21wcmVzc0lSSSBhcyBqZXN0Lk1vY2spLm1vY2tJbXBsZW1lbnRhdGlvbigoaXJpOiBJUkkpID0+IHtcbiAgICAgICAgICAgIGlmIChpcmkudG9TdHJpbmcoKSA9PT0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyN0eXBlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAncmRmOnR5cGUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlyaS50b1N0cmluZygpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBcbiAgICBpdCgnc2hvdWxkIGhhdmUgZGVmYXVsdCBuYW1lc3BhY2VzJywgKCkgPT4ge1xuICAgICAgICBleHBlY3QobmFtZXNwYWNlTWFuYWdlci5oYXNQcmVmaXgoJ3JkZicpKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QobmFtZXNwYWNlTWFuYWdlci5oYXNQcmVmaXgoJ3JkZnMnKSkudG9CZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KG5hbWVzcGFjZU1hbmFnZXIuaGFzUHJlZml4KCdvd2wnKSkudG9CZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KG5hbWVzcGFjZU1hbmFnZXIuaGFzUHJlZml4KCd4c2QnKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgICBcbiAgICBpdCgnc2hvdWxkIGFkZCBjdXN0b20gbmFtZXNwYWNlIGJpbmRpbmdzJywgKCkgPT4ge1xuICAgICAgICBuYW1lc3BhY2VNYW5hZ2VyLmFkZEJpbmRpbmcoJ3Rlc3QnLCAnaHR0cDovL3Rlc3QuZXhhbXBsZS5vcmcvJyk7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QobmFtZXNwYWNlTWFuYWdlci5oYXNQcmVmaXgoJ3Rlc3QnKSkudG9CZSh0cnVlKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IG5hbWVzcGFjZSA9IG5hbWVzcGFjZU1hbmFnZXIuZ2V0TmFtZXNwYWNlKCd0ZXN0Jyk7XG4gICAgICAgIGV4cGVjdChuYW1lc3BhY2U/LnRvU3RyaW5nKCkpLnRvQmUoJ2h0dHA6Ly90ZXN0LmV4YW1wbGUub3JnLycpO1xuICAgIH0pO1xuICAgIFxuICAgIGl0KCdzaG91bGQgZXhwYW5kIENVUklFcycsICgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmFtZXNwYWNlTWFuYWdlci5leHBhbmRDVVJJRSgncmRmOnR5cGUnKTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChyZXN1bHQuaXNTdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgaXJpID0gcmVzdWx0LmdldFZhbHVlKCk7XG4gICAgICAgIGV4cGVjdChpcmkudG9TdHJpbmcoKSkudG9CZSgnaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zI3R5cGUnKTtcbiAgICB9KTtcbiAgICBcbiAgICBpdCgnc2hvdWxkIGNvbXByZXNzIElSSXMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGlyaSA9IG5ldyBJUkkoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyN0eXBlJyk7XG4gICAgICAgIGNvbnN0IGNvbXByZXNzZWQgPSBuYW1lc3BhY2VNYW5hZ2VyLmNvbXByZXNzSVJJKGlyaSk7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QoY29tcHJlc3NlZCkudG9CZSgncmRmOnR5cGUnKTtcbiAgICB9KTtcbn0pO1xuXG5kZXNjcmliZSgnUkRGU2VyaWFsaXplcicsICgpID0+IHtcbiAgICBsZXQgc2VyaWFsaXplcjogUkRGU2VyaWFsaXplcjtcbiAgICBsZXQgZ3JhcGg6IEdyYXBoO1xuICAgIFxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgICAvLyBVc2UgbW9ja2VkIHNlcmlhbGl6ZXJcbiAgICAgICAgY29uc3QgTW9ja2VkUkRGU2VyaWFsaXplciA9IFJERlNlcmlhbGl6ZXIgYXMgamVzdC5Nb2NrZWRDbGFzczx0eXBlb2YgUkRGU2VyaWFsaXplcj47XG4gICAgICAgIGNvbnN0IG1vY2tOYW1lc3BhY2VNYW5hZ2VyID0gbmV3IChOYW1lc3BhY2VNYW5hZ2VyIGFzIGplc3QuTW9ja2VkQ2xhc3M8dHlwZW9mIE5hbWVzcGFjZU1hbmFnZXI+KSgpO1xuICAgICAgICBzZXJpYWxpemVyID0gbmV3IE1vY2tlZFJERlNlcmlhbGl6ZXIobW9ja05hbWVzcGFjZU1hbmFnZXIpO1xuICAgICAgICBncmFwaCA9IG5ldyBHcmFwaCgpO1xuICAgICAgICBcbiAgICAgICAgLy8gQWRkIHRlc3QgZGF0YVxuICAgICAgICBjb25zdCB0cmlwbGUgPSBuZXcgVHJpcGxlKFxuICAgICAgICAgICAgbmV3IElSSSgnaHR0cDovL2V4YW1wbGUub3JnL3BlcnNvbi8xJyksXG4gICAgICAgICAgICBuZXcgSVJJKCdodHRwOi8veG1sbnMuY29tL2ZvYWYvMC4xL25hbWUnKSxcbiAgICAgICAgICAgIExpdGVyYWwuc3RyaW5nKCdKb2huIERvZScpXG4gICAgICAgICk7XG4gICAgICAgIGdyYXBoLmFkZCh0cmlwbGUpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0dXAgbW9jayBiZWhhdmlvciBmb3Igc2VyaWFsaXplclxuICAgICAgICAoc2VyaWFsaXplci5zZXJpYWxpemUgYXMgamVzdC5Nb2NrKS5tb2NrSW1wbGVtZW50YXRpb24oKGdyYXBoLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICBsZXQgY29udGVudDogc3RyaW5nO1xuICAgICAgICAgICAgc3dpdGNoIChvcHRpb25zLmZvcm1hdCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3R1cnRsZSc6XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSAnQHByZWZpeCBmb2FmOiA8aHR0cDovL3htbG5zLmNvbS9mb2FmLzAuMS8+IC5cXG48aHR0cDovL2V4YW1wbGUub3JnL3BlcnNvbi8xPiBmb2FmOm5hbWUgXCJKb2huIERvZVwiIC4nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICduLXRyaXBsZXMnOlxuICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gJzxodHRwOi8vZXhhbXBsZS5vcmcvcGVyc29uLzE+IDxodHRwOi8veG1sbnMuY29tL2ZvYWYvMC4xL25hbWU+IFwiSm9obiBEb2VcIiAuJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9ICdAcHJlZml4IGZvYWY6IDxodHRwOi8veG1sbnMuY29tL2ZvYWYvMC4xLz4gLlxcbjxodHRwOi8vZXhhbXBsZS5vcmcvcGVyc29uLzE+IGZvYWY6bmFtZSBcIkpvaG4gRG9lXCIgLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaXNTdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldFZhbHVlOiAoKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IG9wdGlvbnMuZm9ybWF0LFxuICAgICAgICAgICAgICAgICAgICB0cmlwbGVDb3VudDogMVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBcbiAgICBpdCgnc2hvdWxkIHNlcmlhbGl6ZSB0byBUdXJ0bGUgZm9ybWF0JywgKCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzZXJpYWxpemVyLnNlcmlhbGl6ZShncmFwaCwge1xuICAgICAgICAgICAgZm9ybWF0OiAndHVydGxlJyxcbiAgICAgICAgICAgIHByZXR0eVByaW50OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBzZXJpYWxpemVkRGF0YSA9IHJlc3VsdC5nZXRWYWx1ZSgpO1xuICAgICAgICBleHBlY3Qoc2VyaWFsaXplZERhdGEuY29udGVudCkudG9Db250YWluKCdAcHJlZml4Jyk7XG4gICAgICAgIGV4cGVjdChzZXJpYWxpemVkRGF0YS5jb250ZW50KS50b0NvbnRhaW4oJ2ZvYWY6bmFtZScpO1xuICAgICAgICBleHBlY3Qoc2VyaWFsaXplZERhdGEuY29udGVudCkudG9Db250YWluKCdcIkpvaG4gRG9lXCInKTtcbiAgICB9KTtcbiAgICBcbiAgICBpdCgnc2hvdWxkIHNlcmlhbGl6ZSB0byBOLVRyaXBsZXMgZm9ybWF0JywgKCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzZXJpYWxpemVyLnNlcmlhbGl6ZShncmFwaCwge1xuICAgICAgICAgICAgZm9ybWF0OiAnbi10cmlwbGVzJ1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChyZXN1bHQuaXNTdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgICBcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZERhdGEgPSByZXN1bHQuZ2V0VmFsdWUoKTtcbiAgICAgICAgZXhwZWN0KHNlcmlhbGl6ZWREYXRhLmNvbnRlbnQpLnRvQ29udGFpbignPGh0dHA6Ly9leGFtcGxlLm9yZy9wZXJzb24vMT4nKTtcbiAgICAgICAgZXhwZWN0KHNlcmlhbGl6ZWREYXRhLmNvbnRlbnQpLnRvQ29udGFpbignPGh0dHA6Ly94bWxucy5jb20vZm9hZi8wLjEvbmFtZT4nKTtcbiAgICAgICAgZXhwZWN0KHNlcmlhbGl6ZWREYXRhLmNvbnRlbnQpLnRvQ29udGFpbignXCJKb2huIERvZVwiJyk7XG4gICAgICAgIGV4cGVjdChzZXJpYWxpemVkRGF0YS5jb250ZW50KS50b0NvbnRhaW4oJyAuJyk7XG4gICAgfSk7XG4gICAgXG4gICAgaXQoJ3Nob3VsZCBwcm92aWRlIGZpbGUgZXh0ZW5zaW9uIGZvciBmb3JtYXQnLCAoKSA9PiB7XG4gICAgICAgIC8vIE1vY2sgc3RhdGljIG1ldGhvZHNcbiAgICAgICAgKFJERlNlcmlhbGl6ZXIuZ2V0RmlsZUV4dGVuc2lvbiBhcyBqZXN0Lk1vY2spID0gamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoZm9ybWF0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleHRlbnNpb25zID0ge1xuICAgICAgICAgICAgICAgICd0dXJ0bGUnOiAnLnR0bCcsXG4gICAgICAgICAgICAgICAgJ24tdHJpcGxlcyc6ICcubnQnLFxuICAgICAgICAgICAgICAgICdqc29uLWxkJzogJy5qc29ubGQnLFxuICAgICAgICAgICAgICAgICdyZGYteG1sJzogJy5yZGYnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGV4dGVuc2lvbnNbZm9ybWF0XTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QoUkRGU2VyaWFsaXplci5nZXRGaWxlRXh0ZW5zaW9uKCd0dXJ0bGUnKSkudG9CZSgnLnR0bCcpO1xuICAgICAgICBleHBlY3QoUkRGU2VyaWFsaXplci5nZXRGaWxlRXh0ZW5zaW9uKCduLXRyaXBsZXMnKSkudG9CZSgnLm50Jyk7XG4gICAgICAgIGV4cGVjdChSREZTZXJpYWxpemVyLmdldEZpbGVFeHRlbnNpb24oJ2pzb24tbGQnKSkudG9CZSgnLmpzb25sZCcpO1xuICAgICAgICBleHBlY3QoUkRGU2VyaWFsaXplci5nZXRGaWxlRXh0ZW5zaW9uKCdyZGYteG1sJykpLnRvQmUoJy5yZGYnKTtcbiAgICB9KTtcbiAgICBcbiAgICBpdCgnc2hvdWxkIHByb3ZpZGUgTUlNRSB0eXBlIGZvciBmb3JtYXQnLCAoKSA9PiB7XG4gICAgICAgIC8vIE1vY2sgc3RhdGljIG1ldGhvZHNcbiAgICAgICAgKFJERlNlcmlhbGl6ZXIuZ2V0TWltZVR5cGUgYXMgamVzdC5Nb2NrKSA9IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKGZvcm1hdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWltZVR5cGVzID0ge1xuICAgICAgICAgICAgICAgICd0dXJ0bGUnOiAndGV4dC90dXJ0bGUnLFxuICAgICAgICAgICAgICAgICduLXRyaXBsZXMnOiAnYXBwbGljYXRpb24vbi10cmlwbGVzJyxcbiAgICAgICAgICAgICAgICAnanNvbi1sZCc6ICdhcHBsaWNhdGlvbi9sZCtqc29uJyxcbiAgICAgICAgICAgICAgICAncmRmLXhtbCc6ICdhcHBsaWNhdGlvbi9yZGYreG1sJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBtaW1lVHlwZXNbZm9ybWF0XTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QoUkRGU2VyaWFsaXplci5nZXRNaW1lVHlwZSgndHVydGxlJykpLnRvQmUoJ3RleHQvdHVydGxlJyk7XG4gICAgICAgIGV4cGVjdChSREZTZXJpYWxpemVyLmdldE1pbWVUeXBlKCduLXRyaXBsZXMnKSkudG9CZSgnYXBwbGljYXRpb24vbi10cmlwbGVzJyk7XG4gICAgICAgIGV4cGVjdChSREZTZXJpYWxpemVyLmdldE1pbWVUeXBlKCdqc29uLWxkJykpLnRvQmUoJ2FwcGxpY2F0aW9uL2xkK2pzb24nKTtcbiAgICAgICAgZXhwZWN0KFJERlNlcmlhbGl6ZXIuZ2V0TWltZVR5cGUoJ3JkZi14bWwnKSkudG9CZSgnYXBwbGljYXRpb24vcmRmK3htbCcpO1xuICAgIH0pO1xufSk7XG5cbmRlc2NyaWJlKCdSREZQYXJzZXInLCAoKSA9PiB7XG4gICAgbGV0IHBhcnNlcjogUkRGUGFyc2VyO1xuICAgIFxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgICAvLyBVc2UgbW9ja2VkIHBhcnNlclxuICAgICAgICBjb25zdCBNb2NrZWRSREZQYXJzZXIgPSBSREZQYXJzZXIgYXMgamVzdC5Nb2NrZWRDbGFzczx0eXBlb2YgUkRGUGFyc2VyPjtcbiAgICAgICAgY29uc3QgbW9ja05hbWVzcGFjZU1hbmFnZXIgPSBuZXcgKE5hbWVzcGFjZU1hbmFnZXIgYXMgamVzdC5Nb2NrZWRDbGFzczx0eXBlb2YgTmFtZXNwYWNlTWFuYWdlcj4pKCk7XG4gICAgICAgIHBhcnNlciA9IG5ldyBNb2NrZWRSREZQYXJzZXIobW9ja05hbWVzcGFjZU1hbmFnZXIpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0dXAgbW9jayBiZWhhdmlvciBmb3IgcGFyc2VyXG4gICAgICAgIChwYXJzZXIucGFyc2UgYXMgamVzdC5Nb2NrKS5tb2NrSW1wbGVtZW50YXRpb24oKGNvbnRlbnQsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGdyYXBoID0gbmV3IEdyYXBoKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFNpbXVsYXRlIHBhcnNpbmcgYmFzZWQgb24gY29udGVudCBhbmQgZm9ybWF0XG4gICAgICAgICAgICBpZiAoY29udGVudC5pbmNsdWRlcygnZm9hZjpuYW1lJykgfHwgY29udGVudC5pbmNsdWRlcygnaHR0cDovL3htbG5zLmNvbS9mb2FmLzAuMS9uYW1lJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmlwbGUgPSBuZXcgVHJpcGxlKFxuICAgICAgICAgICAgICAgICAgICBuZXcgSVJJKCdodHRwOi8vZXhhbXBsZS5vcmcvcGVyc29uMScpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgSVJJKCdodHRwOi8veG1sbnMuY29tL2ZvYWYvMC4xL25hbWUnKSxcbiAgICAgICAgICAgICAgICAgICAgTGl0ZXJhbC5zdHJpbmcoJ0FsaWNlIFNtaXRoJylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGdyYXBoLmFkZCh0cmlwbGUpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChjb250ZW50LmluY2x1ZGVzKCdmb2FmOmFnZScpIHx8IGNvbnRlbnQuaW5jbHVkZXMoJ2FnZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFnZVRyaXBsZSA9IG5ldyBUcmlwbGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgSVJJKCdodHRwOi8vZXhhbXBsZS5vcmcvcGVyc29uMScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IElSSSgnaHR0cDovL3htbG5zLmNvbS9mb2FmLzAuMS9hZ2UnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBMaXRlcmFsKCcyOCcsIG5ldyBJUkkoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hI2ludGVnZXInKSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGguYWRkKGFnZVRyaXBsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjb250ZW50LmluY2x1ZGVzKCdleDp0ZXN0JykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmlwbGUgPSBuZXcgVHJpcGxlKFxuICAgICAgICAgICAgICAgICAgICBuZXcgSVJJKCdodHRwOi8vZXhhbXBsZS5vcmcvdGVzdCcpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgSVJJKCdodHRwOi8vZXhhbXBsZS5vcmcvcHJvcCcpLFxuICAgICAgICAgICAgICAgICAgICBMaXRlcmFsLnN0cmluZygndmFsdWUnKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZ3JhcGguYWRkKHRyaXBsZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRlbnQgPT09ICdUaGlzIGlzIG5vdCB2YWxpZCBSREYgYXQgYWxsIScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpc1N1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBpc0ZhaWx1cmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGdldEVycm9yOiAoKSA9PiAnUGFyc2UgZXJyb3I6IGludmFsaWQgc3ludGF4J1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaXNTdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldFZhbHVlOiAoKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBncmFwaCxcbiAgICAgICAgICAgICAgICAgICAgdHJpcGxlQ291bnQ6IGdyYXBoLnNpemUoKSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlczogeyBcbiAgICAgICAgICAgICAgICAgICAgICAgICdmb2FmJzogJ2h0dHA6Ly94bWxucy5jb20vZm9hZi8wLjEvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdleCc6ICdodHRwOi8vZXhhbXBsZS5vcmcvJyBcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZ3M6IFtdXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIFxuICAgIGl0KCdzaG91bGQgcGFyc2UgVHVydGxlIGZvcm1hdCcsICgpID0+IHtcbiAgICAgICAgY29uc3QgdHVydGxlQ29udGVudCA9IGBcbiAgICAgICAgICAgIEBwcmVmaXggZm9hZjogPGh0dHA6Ly94bWxucy5jb20vZm9hZi8wLjEvPiAuXG4gICAgICAgICAgICBAcHJlZml4IGV4OiA8aHR0cDovL2V4YW1wbGUub3JnLz4gLlxuICAgICAgICAgICAgXG4gICAgICAgICAgICBleDpwZXJzb24xIGZvYWY6bmFtZSBcIkFsaWNlIFNtaXRoXCIgO1xuICAgICAgICAgICAgICAgICAgICAgICBmb2FmOmFnZSBcIjI4XCJeXjxodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYSNpbnRlZ2VyPiAuXG4gICAgICAgIGA7XG4gICAgICAgIFxuICAgICAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIucGFyc2UodHVydGxlQ29udGVudCwgeyBmb3JtYXQ6ICd0dXJ0bGUnIH0pO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBwYXJzZVJlc3VsdCA9IHJlc3VsdC5nZXRWYWx1ZSgpO1xuICAgICAgICBleHBlY3QocGFyc2VSZXN1bHQudHJpcGxlQ291bnQpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgICAgZXhwZWN0KHBhcnNlUmVzdWx0LmdyYXBoLnNpemUoKSkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgICAgICBleHBlY3QocGFyc2VSZXN1bHQubmFtZXNwYWNlc1snZm9hZiddKS50b0JlKCdodHRwOi8veG1sbnMuY29tL2ZvYWYvMC4xLycpO1xuICAgIH0pO1xuICAgIFxuICAgIGl0KCdzaG91bGQgcGFyc2UgTi1UcmlwbGVzIGZvcm1hdCcsICgpID0+IHtcbiAgICAgICAgY29uc3QgbnRyaXBsZXNDb250ZW50ID0gYFxuICAgICAgICAgICAgPGh0dHA6Ly9leGFtcGxlLm9yZy9wZXJzb24xPiA8aHR0cDovL3htbG5zLmNvbS9mb2FmLzAuMS9uYW1lPiBcIkJvYiBKb2huc29uXCIgLlxuICAgICAgICAgICAgPGh0dHA6Ly9leGFtcGxlLm9yZy9wZXJzb24xPiA8aHR0cDovL3htbG5zLmNvbS9mb2FmLzAuMS9hZ2U+IFwiMzJcIl5ePGh0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hI2ludGVnZXI+IC5cbiAgICAgICAgYDtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlci5wYXJzZShudHJpcGxlc0NvbnRlbnQsIHsgZm9ybWF0OiAnbi10cmlwbGVzJyB9KTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChyZXN1bHQuaXNTdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSByZXN1bHQuZ2V0VmFsdWUoKTtcbiAgICAgICAgZXhwZWN0KHBhcnNlUmVzdWx0LnRyaXBsZUNvdW50KS50b0JlKDIpO1xuICAgICAgICBleHBlY3QocGFyc2VSZXN1bHQuZ3JhcGguc2l6ZSgpKS50b0JlKDIpO1xuICAgIH0pO1xuICAgIFxuICAgIGl0KCdzaG91bGQgYXV0by1kZXRlY3QgZm9ybWF0JywgKCkgPT4ge1xuICAgICAgICBjb25zdCB0dXJ0bGVDb250ZW50ID0gJ0BwcmVmaXggZXg6IDxodHRwOi8vZXhhbXBsZS5vcmcvPiAuIGV4OnRlc3QgZXg6cHJvcCBcInZhbHVlXCIgLic7XG4gICAgICAgIFxuICAgICAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIucGFyc2UodHVydGxlQ29udGVudCk7IC8vIE5vIGZvcm1hdCBzcGVjaWZpZWRcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChyZXN1bHQuaXNTdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSByZXN1bHQuZ2V0VmFsdWUoKTtcbiAgICAgICAgZXhwZWN0KHBhcnNlUmVzdWx0LnRyaXBsZUNvdW50KS50b0JlKDEpO1xuICAgIH0pO1xuICAgIFxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHBhcnNpbmcgZXJyb3JzIGdyYWNlZnVsbHknLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGludmFsaWRDb250ZW50ID0gJ1RoaXMgaXMgbm90IHZhbGlkIFJERiBhdCBhbGwhJztcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlci5wYXJzZShpbnZhbGlkQ29udGVudCwgeyBcbiAgICAgICAgICAgIGZvcm1hdDogJ3R1cnRsZScsXG4gICAgICAgICAgICBzdHJpY3RNb2RlOiBmYWxzZSBcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBTaG91bGQgZWl0aGVyIHN1Y2NlZWQgd2l0aCB3YXJuaW5ncyBvciBmYWlsIGdyYWNlZnVsbHlcbiAgICAgICAgaWYgKHJlc3VsdC5pc0ZhaWx1cmUpIHtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2V0RXJyb3IoKSkudG9Db250YWluKCdQYXJzZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSByZXN1bHQuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIGV4cGVjdChwYXJzZVJlc3VsdC53YXJuaW5ncykudG9CZURlZmluZWQoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7Il0sInZlcnNpb24iOjN9