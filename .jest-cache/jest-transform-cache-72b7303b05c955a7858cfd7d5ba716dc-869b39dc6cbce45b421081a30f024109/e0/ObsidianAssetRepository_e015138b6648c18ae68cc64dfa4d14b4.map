{"file":"/Users/kitelev/Documents/exocortex-obsidian-plugin/src/infrastructure/repositories/ObsidianAssetRepository.ts","mappings":"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","names":[],"sources":["/Users/kitelev/Documents/exocortex-obsidian-plugin/src/infrastructure/repositories/ObsidianAssetRepository.ts"],"sourcesContent":["import { App, TFile } from \"obsidian\";\nimport { IAssetRepository } from \"../../domain/repositories/IAssetRepository\";\nimport { Asset } from \"../../domain/entities/Asset\";\nimport { AssetId } from \"../../domain/value-objects/AssetId\";\nimport { ClassName } from \"../../domain/value-objects/ClassName\";\nimport { OntologyPrefix } from \"../../domain/value-objects/OntologyPrefix\";\nimport { AbstractFileRepository } from \"../../shared/AbstractFileRepository\";\nimport { FileOperationUtils } from \"../../shared/utils/FileOperationUtils\";\n\n/**\n * Obsidian implementation of IAssetRepository\n * Handles asset persistence using Obsidian vault\n */\nexport class ObsidianAssetRepository\n  extends AbstractFileRepository\n  implements IAssetRepository\n{\n  constructor(app: App) {\n    super(app);\n  }\n\n  async findById(id: AssetId): Promise<Asset | null> {\n    const files = this.app.vault.getMarkdownFiles();\n\n    for (const file of files) {\n      const cache = this.app.metadataCache.getFileCache(file);\n      if (cache?.frontmatter?.[\"exo__Asset_uid\"] === id.toString()) {\n        const asset = Asset.fromFrontmatter(cache.frontmatter, file.basename);\n        // Only return valid assets - invalid ones are silently ignored\n        if (asset) {\n          return asset;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  async findByClass(className: ClassName): Promise<Asset[]> {\n    const files = this.app.vault.getMarkdownFiles();\n    const assets: Asset[] = [];\n\n    for (const file of files) {\n      const cache = this.app.metadataCache.getFileCache(file);\n      if (cache?.frontmatter) {\n        const classes = cache.frontmatter[\"exo__Instance_class\"];\n        const classArray = Array.isArray(classes) ? classes : [classes];\n\n        if (\n          classArray.some(\n            (c) => c === className.toWikiLink() || c === className.toString(),\n          )\n        ) {\n          const asset = Asset.fromFrontmatter(cache.frontmatter, file.basename);\n          // Only include valid assets - invalid ones are silently ignored\n          if (asset) {\n            assets.push(asset);\n          }\n        }\n      }\n    }\n\n    return assets;\n  }\n\n  async findByOntology(prefix: OntologyPrefix): Promise<Asset[]> {\n    const files = this.app.vault.getMarkdownFiles();\n    const assets: Asset[] = [];\n\n    for (const file of files) {\n      const cache = this.app.metadataCache.getFileCache(file);\n      if (cache?.frontmatter) {\n        const ontology = cache.frontmatter[\"exo__Asset_isDefinedBy\"];\n        const ontologyValue = ontology?.replace(/\\[\\[!?|\\]\\]/g, \"\");\n\n        if (ontologyValue === prefix.toString()) {\n          const asset = Asset.fromFrontmatter(cache.frontmatter, file.basename);\n          // Only include valid assets - invalid ones are silently ignored\n          if (asset) {\n            assets.push(asset);\n          }\n        }\n      }\n    }\n\n    return assets;\n  }\n\n  async save(asset: Asset): Promise<void> {\n    await this.saveEntityWithFrontmatter(\n      asset,\n      (a) => a.getTitle(),\n      (a) => a.toFrontmatter(),\n      (a) => this.findExistingAssetFile(a),\n      \"Asset\",\n    );\n  }\n\n  private findExistingAssetFile(asset: Asset): TFile | null {\n    const frontmatter = asset.toFrontmatter();\n    const storedPath = (asset as any).props?.filePath;\n    const assetId = frontmatter[\"exo__Asset_uid\"];\n    const filename = asset.getTitle();\n\n    return this.findFileWithFallback({\n      uid: assetId,\n      storedPath,\n      filename,\n    });\n  }\n\n  async delete(id: AssetId): Promise<void> {\n    const asset = await this.findById(id);\n    if (asset) {\n      await this.deleteFileByEntity(asset, (a) => a.getTitle(), \"Asset\");\n    }\n  }\n\n  async exists(id: AssetId): Promise<boolean> {\n    try {\n      const found = await this.findById(id);\n      return found !== null;\n    } catch (error) {\n      console.error(\"Error checking asset existence:\", error);\n      return false;\n    }\n  }\n\n  async findAll(): Promise<Asset[]> {\n    const files = this.app.vault.getMarkdownFiles();\n    const assets: Asset[] = [];\n\n    for (const file of files) {\n      const cache = this.app.metadataCache.getFileCache(file);\n      if (cache?.frontmatter?.[\"exo__Asset_uid\"]) {\n        const asset = Asset.fromFrontmatter(cache.frontmatter, file.basename);\n        // Only include valid assets - invalid ones are silently ignored\n        if (asset) {\n          assets.push(asset);\n        }\n      }\n    }\n\n    return assets;\n  }\n\n  async findByFilename(filename: string): Promise<Asset | null> {\n    // Handle different filename formats\n    let searchPath = filename;\n\n    // Add .md extension if not present\n    if (!searchPath.endsWith(\".md\")) {\n      searchPath = `${searchPath}.md`;\n    }\n\n    // Try to find by path first\n    let file = this.app.vault.getAbstractFileByPath(searchPath);\n\n    // If not found, search all files by basename\n    if (!file) {\n      const files = this.app.vault.getMarkdownFiles();\n      file =\n        files.find((f) => f.path === searchPath || f.name === searchPath) ||\n        null;\n    }\n\n    if (file instanceof TFile) {\n      const cache = this.app.metadataCache.getFileCache(file);\n      if (cache?.frontmatter) {\n        const asset = Asset.fromFrontmatter(cache.frontmatter, file.basename);\n        // Only return valid assets - invalid ones are silently ignored\n        if (asset) {\n          // Store the file path for later use in save\n          (asset as any).props.filePath = file.path;\n          return asset;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Update only the frontmatter of a file by path\n   */\n  async updateFrontmatterByPath(\n    filePath: string,\n    updates: Record<string, any>,\n  ): Promise<void> {\n    await super.updateFrontmatterByPath(filePath, updates);\n  }\n}\n"],"version":3}