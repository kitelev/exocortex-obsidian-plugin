{"file":"/Users/kitelev/Documents/exocortex-obsidian-plugin/src/application/services/RDFService.ts","mappings":"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","names":[],"sources":["/Users/kitelev/Documents/exocortex-obsidian-plugin/src/application/services/RDFService.ts"],"sourcesContent":["/**\n * RDF Service - Coordinates RDF operations using specialized services\n * Follows Single Responsibility Principle by delegating to specific services\n */\n\nimport { Graph } from \"../../domain/semantic/core/Graph\";\nimport {\n  Triple,\n  IRI,\n  BlankNode,\n  Literal,\n} from \"../../domain/semantic/core/Triple\";\nimport { Result } from \"../../domain/core/Result\";\nimport {\n  RDFSerializer,\n  RDFFormat,\n  SerializationOptions,\n  SerializationResult,\n} from \"./RDFSerializer\";\nimport { RDFParser, ParseOptions, ParseResult } from \"./RDFParser\";\nimport { NamespaceManager } from \"./NamespaceManager\";\nimport { RDFValidator, ValidationOptions } from \"./RDFValidator\";\nimport { INotificationService } from \"../ports/INotificationService\";\nimport { IFileSystemAdapter } from \"../ports/IFileSystemAdapter\";\nimport {\n  MemoryOptimizedImporter,\n  StreamingImportOptions,\n} from \"../../infrastructure/performance/MemoryOptimizedImporter\";\nimport { IndexedGraph } from \"../../domain/semantic/core/IndexedGraph\";\n\nexport interface RDFExportOptions {\n  format: RDFFormat;\n  includeComments?: boolean;\n  prettyPrint?: boolean;\n  baseIRI?: string;\n  fileName?: string;\n  saveToVault?: boolean;\n  targetFolder?: string;\n}\n\nexport interface RDFImportOptions extends StreamingImportOptions {\n  format?: RDFFormat;\n  mergeMode: \"merge\" | \"replace\";\n  validateInput?: boolean;\n  strictMode?: boolean;\n  baseIRI?: string;\n  useOptimizedImporter?: boolean;\n}\n\nexport type { ValidationError } from \"./RDFValidator\";\n\nexport class RDFService {\n  private serializer: RDFSerializer;\n  private parser: RDFParser;\n  private validator: RDFValidator;\n  private optimizedImporter: MemoryOptimizedImporter;\n  private namespaceManager: NamespaceManager;\n\n  constructor(\n    private notificationService: INotificationService,\n    private fileSystemAdapter: IFileSystemAdapter,\n    namespaceManager?: NamespaceManager,\n  ) {\n    this.namespaceManager = namespaceManager || new NamespaceManager();\n    this.serializer = new RDFSerializer(this.namespaceManager);\n    this.parser = new RDFParser(this.namespaceManager);\n    this.validator = new RDFValidator();\n    this.optimizedImporter = new MemoryOptimizedImporter();\n  }\n\n  /**\n   * Export graph to RDF format\n   */\n  async exportGraph(\n    graph: Graph,\n    options: RDFExportOptions,\n  ): Promise<Result<SerializationResult>> {\n    try {\n      const validationResult = this.validator.validateExportOptions(options);\n      if (validationResult.isFailure) {\n        return Result.fail<SerializationResult>(validationResult.errorValue());\n      }\n\n      const serializationOptions: SerializationOptions = {\n        format: options.format,\n        includeComments: options.includeComments ?? true,\n        prettyPrint: options.prettyPrint ?? true,\n        baseIRI: options.baseIRI,\n        namespaceManager: this.namespaceManager,\n      };\n\n      const result = this.serializer.serialize(graph, serializationOptions);\n      if (result.isFailure) {\n        return result;\n      }\n\n      const serializedData = result.getValue();\n\n      if (options.saveToVault) {\n        const fileName = this.fileSystemAdapter.generateFileName(\n          options.fileName,\n          this.getFormatInfo(options.format).extension.slice(1),\n        );\n        const filePath = options.targetFolder\n          ? `${options.targetFolder}/${fileName}`\n          : fileName;\n\n        const saveResult = await this.fileSystemAdapter.writeFile(\n          filePath,\n          serializedData.content,\n        );\n        if (saveResult.isFailure) {\n          return Result.fail(saveResult.errorValue());\n        }\n\n        this.notificationService.showSuccess(\n          `Exported ${serializedData.tripleCount} triples to ${filePath}`,\n        );\n      }\n\n      return result;\n    } catch (error) {\n      return Result.fail(`Export failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Import RDF data and merge with existing graph\n   */\n  async importRDF(\n    content: string,\n    graph: Graph,\n    options: RDFImportOptions,\n  ): Promise<Result<{ graph: Graph; imported: ParseResult }>> {\n    try {\n      const validationResult = this.validator.validateImportOptions(options);\n      if (validationResult.isFailure) {\n        return Result.fail<{ graph: Graph; imported: ParseResult }>(\n          validationResult.errorValue(),\n        );\n      }\n\n      const parseOptions: ParseOptions = {\n        format: options.format,\n        baseIRI: options.baseIRI,\n        namespaceManager: this.namespaceManager,\n        validateInput: options.validateInput ?? true,\n        strictMode: options.strictMode ?? false,\n      };\n\n      const parseResult = this.parser.parse(content, parseOptions);\n      if (parseResult.isFailure) {\n        return Result.fail(\n          `Import parsing failed: ${parseResult.errorValue()}`,\n        );\n      }\n\n      const imported = parseResult.getValue();\n\n      if (options.validateInput) {\n        const validationOptions: ValidationOptions = {\n          strictMode: options.strictMode,\n          checkDuplicates: true,\n          checkNamespaces: true,\n          checkLiterals: true,\n        };\n\n        const graphValidation = this.validator.validateGraph(\n          imported.graph,\n          validationOptions,\n        );\n        if (graphValidation.isFailure) {\n          return Result.fail(graphValidation.errorValue());\n        }\n\n        const validation = graphValidation.getValue();\n        if (!validation.isValid && options.strictMode) {\n          const errorMessages = validation.errors\n            .map((e) => e.message)\n            .join(\"; \");\n          return Result.fail(`Import validation failed: ${errorMessages}`);\n        }\n\n        if (validation.warnings.length > 0) {\n          this.notificationService.showWarning(\n            `Import completed with ${validation.warnings.length} warnings`,\n          );\n        }\n      }\n\n      let finalGraph: Graph;\n\n      // Use optimized importer for large files\n      const useOptimized =\n        options.useOptimizedImporter !== false &&\n        (content.length > 50000 || options.chunkSize);\n\n      if (useOptimized && graph instanceof IndexedGraph) {\n        // Use optimized batch processing\n        if (options.mergeMode === \"replace\") {\n          graph.clear();\n        }\n\n        graph.beginBatch();\n        for (const triple of imported.graph.toArray()) {\n          graph.add(triple);\n        }\n        graph.commitBatch();\n\n        finalGraph = graph;\n      } else {\n        // Standard merge\n        if (options.mergeMode === \"replace\") {\n          finalGraph = imported.graph;\n        } else {\n          finalGraph = graph.clone();\n          if (finalGraph instanceof IndexedGraph) {\n            finalGraph.beginBatch();\n            finalGraph.merge(imported.graph);\n            finalGraph.commitBatch();\n          } else {\n            finalGraph.merge(imported.graph);\n          }\n        }\n      }\n\n      for (const [prefix, namespace] of Object.entries(imported.namespaces)) {\n        if (!this.namespaceManager.hasPrefix(prefix)) {\n          this.namespaceManager.addBinding(prefix, namespace);\n        }\n      }\n\n      return Result.ok({ graph: finalGraph, imported });\n    } catch (error) {\n      return Result.fail(`Import failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Import RDF from vault file\n   */\n  async importFromVaultFile(\n    filePath: string,\n    graph: Graph,\n    options: RDFImportOptions,\n  ): Promise<Result<{ graph: Graph; imported: ParseResult }>> {\n    try {\n      const contentResult = await this.fileSystemAdapter.readFile(filePath);\n      if (contentResult.isFailure) {\n        return Result.fail(contentResult.errorValue());\n      }\n\n      if (!options.format) {\n        const fileName = filePath.split(\"/\").pop() || filePath;\n        options.format = this.fileSystemAdapter.detectFormatFromExtension(\n          fileName,\n        ) as RDFFormat;\n      }\n\n      return await this.importRDF(contentResult.getValue(), graph, options);\n    } catch (error) {\n      return Result.fail(`Failed to import from vault file: ${error.message}`);\n    }\n  }\n\n  /**\n   * Export SPARQL query results\n   */\n  async exportQueryResults(\n    results: any[],\n    format: RDFFormat,\n    fileName?: string,\n    saveToVault: boolean = true,\n  ): Promise<Result<SerializationResult>> {\n    try {\n      const graph = this.convertQueryResultsToGraph(results);\n\n      const options: RDFExportOptions = {\n        format,\n        fileName: fileName || \"sparql-results\",\n        saveToVault,\n        includeComments: true,\n        prettyPrint: true,\n        targetFolder: \"exports\",\n      };\n\n      return await this.exportGraph(graph, options);\n    } catch (error) {\n      return Result.fail(`Query results export failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Validate a graph\n   */\n  async validateGraph(\n    graph: Graph,\n    options?: ValidationOptions,\n  ): Promise<Result<any>> {\n    return this.validator.validateGraph(graph, options);\n  }\n\n  /**\n   * List RDF files in vault\n   */\n  async listRDFFiles(folder?: string): Promise<Result<any[]>> {\n    return this.fileSystemAdapter.listFiles(folder, \"ttl\");\n  }\n\n  /**\n   * Convert SPARQL query results to graph\n   */\n  private convertQueryResultsToGraph(results: any[]): Graph {\n    const graph = new Graph();\n\n    for (const result of results) {\n      if (result.subject && result.predicate && result.object) {\n        try {\n          const subject = this.createNodeFromValue(result.subject);\n          const predicate = this.createNodeFromValue(result.predicate) as IRI;\n          const object = this.createNodeFromValue(result.object);\n\n          if (subject && predicate && object) {\n            const triple = new Triple(\n              subject as IRI | BlankNode,\n              predicate,\n              object,\n            );\n            graph.add(triple);\n          }\n        } catch (error) {\n          console.warn(\"Failed to convert query result to triple:\", error);\n        }\n      }\n    }\n\n    return graph;\n  }\n\n  /**\n   * Create RDF node from query result value\n   */\n  private createNodeFromValue(value: any): IRI | BlankNode | Literal | null {\n    if (typeof value === \"string\") {\n      if (value.startsWith(\"_:\")) {\n        return new BlankNode(value);\n      } else if (\n        value.startsWith(\"http://\") ||\n        value.startsWith(\"https://\") ||\n        value.includes(\":\")\n      ) {\n        try {\n          return new IRI(value);\n        } catch {\n          return Literal.string(value);\n        }\n      } else {\n        return Literal.string(value);\n      }\n    } else if (typeof value === \"number\") {\n      return Number.isInteger(value)\n        ? Literal.integer(value)\n        : Literal.double(value);\n    } else if (typeof value === \"boolean\") {\n      return Literal.boolean(value);\n    } else if (value && typeof value === \"object\") {\n      if (value.type === \"uri\" || value.type === \"iri\") {\n        return new IRI(value.value);\n      } else if (value.type === \"bnode\") {\n        return new BlankNode(value.value);\n      } else if (value.type === \"literal\") {\n        if (value.datatype) {\n          return new Literal(value.value, new IRI(value.datatype));\n        } else if (value.lang) {\n          return new Literal(value.value, undefined, value.lang);\n        } else {\n          return new Literal(value.value);\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Get namespace manager instance\n   */\n  getNamespaceManager(): NamespaceManager {\n    return this.namespaceManager;\n  }\n\n  /**\n   * Get supported export formats\n   */\n  getSupportedFormats(): RDFFormat[] {\n    return [\"turtle\", \"n-triples\", \"json-ld\", \"rdf-xml\"];\n  }\n\n  /**\n   * Get format information\n   */\n  getFormatInfo(format: RDFFormat): {\n    extension: string;\n    mimeType: string;\n    name: string;\n  } {\n    const formatMap = {\n      turtle: { extension: \".ttl\", mimeType: \"text/turtle\", name: \"Turtle\" },\n      \"n-triples\": {\n        extension: \".nt\",\n        mimeType: \"application/n-triples\",\n        name: \"N-Triples\",\n      },\n      \"json-ld\": {\n        extension: \".jsonld\",\n        mimeType: \"application/ld+json\",\n        name: \"JSON-LD\",\n      },\n      \"rdf-xml\": {\n        extension: \".rdf\",\n        mimeType: \"application/rdf+xml\",\n        name: \"RDF/XML\",\n      },\n    };\n\n    return formatMap[format];\n  }\n}\n"],"version":3}