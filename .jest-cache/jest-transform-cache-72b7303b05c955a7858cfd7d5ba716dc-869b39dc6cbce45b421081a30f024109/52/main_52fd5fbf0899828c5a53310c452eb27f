0a709464a7386cb4efc8024887425065
/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ExocortexPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian20 = require("obsidian");

// src/domain/semantic/core/Graph.ts
var Graph = class {
  constructor(triples = []) {
    this.triples = /* @__PURE__ */ new Set();
    this.spo = /* @__PURE__ */ new Map();
    this.pos = /* @__PURE__ */ new Map();
    this.osp = /* @__PURE__ */ new Map();
    for (const triple of triples) {
      this.add(triple);
    }
  }
  /**
   * Add a triple to the graph
   */
  add(triple) {
    if (this.has(triple))
      return;
    this.triples.add(triple);
    const s = triple.getSubject().toString();
    const p = triple.getPredicate().toString();
    const o = triple.getObject().toString();
    if (!this.spo.has(s))
      this.spo.set(s, /* @__PURE__ */ new Map());
    if (!this.spo.get(s).has(p))
      this.spo.get(s).set(p, /* @__PURE__ */ new Set());
    this.spo.get(s).get(p).add(o);
    if (!this.pos.has(p))
      this.pos.set(p, /* @__PURE__ */ new Map());
    if (!this.pos.get(p).has(o))
      this.pos.get(p).set(o, /* @__PURE__ */ new Set());
    this.pos.get(p).get(o).add(s);
    if (!this.osp.has(o))
      this.osp.set(o, /* @__PURE__ */ new Map());
    if (!this.osp.get(o).has(s))
      this.osp.get(o).set(s, /* @__PURE__ */ new Set());
    this.osp.get(o).get(s).add(p);
  }
  /**
   * Remove a triple from the graph
   */
  remove(triple) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
    if (!this.has(triple))
      return;
    this.triples.delete(triple);
    const s = triple.getSubject().toString();
    const p = triple.getPredicate().toString();
    const o = triple.getObject().toString();
    (_b = (_a = this.spo.get(s)) == null ? void 0 : _a.get(p)) == null ? void 0 : _b.delete(o);
    if (((_d = (_c = this.spo.get(s)) == null ? void 0 : _c.get(p)) == null ? void 0 : _d.size) === 0) {
      (_e = this.spo.get(s)) == null ? void 0 : _e.delete(p);
    }
    if (((_f = this.spo.get(s)) == null ? void 0 : _f.size) === 0) {
      this.spo.delete(s);
    }
    (_h = (_g = this.pos.get(p)) == null ? void 0 : _g.get(o)) == null ? void 0 : _h.delete(s);
    if (((_j = (_i = this.pos.get(p)) == null ? void 0 : _i.get(o)) == null ? void 0 : _j.size) === 0) {
      (_k = this.pos.get(p)) == null ? void 0 : _k.delete(o);
    }
    if (((_l = this.pos.get(p)) == null ? void 0 : _l.size) === 0) {
      this.pos.delete(p);
    }
    (_n = (_m = this.osp.get(o)) == null ? void 0 : _m.get(s)) == null ? void 0 : _n.delete(p);
    if (((_p = (_o = this.osp.get(o)) == null ? void 0 : _o.get(s)) == null ? void 0 : _p.size) === 0) {
      (_q = this.osp.get(o)) == null ? void 0 : _q.delete(s);
    }
    if (((_r = this.osp.get(o)) == null ? void 0 : _r.size) === 0) {
      this.osp.delete(o);
    }
  }
  /**
   * Check if the graph contains a triple
   */
  has(triple) {
    var _a, _b, _c;
    const s = triple.getSubject().toString();
    const p = triple.getPredicate().toString();
    const o = triple.getObject().toString();
    return (_c = (_b = (_a = this.spo.get(s)) == null ? void 0 : _a.get(p)) == null ? void 0 : _b.has(o)) != null ? _c : false;
  }
  /**
   * Get all triples matching a pattern
   * null values act as wildcards
   */
  match(subject = null, predicate = null, object = null) {
    var _a, _b, _c;
    const results = [];
    if (subject && predicate && object) {
      for (const triple of this.triples) {
        if (triple.getSubject().toString() === subject.toString() && triple.getPredicate().toString() === predicate.toString() && triple.getObject().toString() === object.toString()) {
          results.push(triple);
        }
      }
    } else if (subject && predicate) {
      const objects = (_a = this.spo.get(subject.toString())) == null ? void 0 : _a.get(predicate.toString());
      if (objects) {
        for (const triple of this.triples) {
          if (triple.getSubject().toString() === subject.toString() && triple.getPredicate().toString() === predicate.toString()) {
            results.push(triple);
          }
        }
      }
    } else if (predicate && object) {
      const subjects = (_b = this.pos.get(predicate.toString())) == null ? void 0 : _b.get(object.toString());
      if (subjects) {
        for (const triple of this.triples) {
          if (triple.getPredicate().toString() === predicate.toString() && triple.getObject().toString() === object.toString()) {
            results.push(triple);
          }
        }
      }
    } else if (subject && object) {
      const predicates = (_c = this.osp.get(object.toString())) == null ? void 0 : _c.get(subject.toString());
      if (predicates) {
        for (const triple of this.triples) {
          if (triple.getSubject().toString() === subject.toString() && triple.getObject().toString() === object.toString()) {
            results.push(triple);
          }
        }
      }
    } else if (subject) {
      for (const triple of this.triples) {
        if (triple.getSubject().toString() === subject.toString()) {
          results.push(triple);
        }
      }
    } else if (predicate) {
      for (const triple of this.triples) {
        if (triple.getPredicate().toString() === predicate.toString()) {
          results.push(triple);
        }
      }
    } else if (object) {
      for (const triple of this.triples) {
        if (triple.getObject().toString() === object.toString()) {
          results.push(triple);
        }
      }
    } else {
      return Array.from(this.triples);
    }
    return results;
  }
  /**
   * Get all subjects in the graph
   */
  subjects() {
    const subjects = /* @__PURE__ */ new Set();
    for (const triple of this.triples) {
      subjects.add(triple.getSubject());
    }
    return subjects;
  }
  /**
   * Get all predicates in the graph
   */
  predicates() {
    const predicates = /* @__PURE__ */ new Set();
    for (const triple of this.triples) {
      predicates.add(triple.getPredicate());
    }
    return predicates;
  }
  /**
   * Get all objects in the graph
   */
  objects() {
    const objects = /* @__PURE__ */ new Set();
    for (const triple of this.triples) {
      objects.add(triple.getObject());
    }
    return objects;
  }
  /**
   * Get the size of the graph (number of triples)
   */
  size() {
    return this.triples.size;
  }
  /**
   * Check if the graph is empty
   */
  isEmpty() {
    return this.triples.size === 0;
  }
  /**
   * Clear all triples from the graph
   */
  clear() {
    this.triples.clear();
    this.spo.clear();
    this.pos.clear();
    this.osp.clear();
  }
  /**
   * Merge another graph into this one
   */
  merge(other) {
    for (const triple of other.toArray()) {
      this.add(triple);
    }
  }
  /**
   * Create a new graph with triples matching a pattern
   */
  filter(subject = null, predicate = null, object = null) {
    return new Graph(this.match(subject, predicate, object));
  }
  /**
   * Convert the graph to an array of triples
   */
  toArray() {
    return Array.from(this.triples);
  }
  /**
   * Create a human-readable string representation
   */
  toString() {
    return Array.from(this.triples).map((t) => t.toString()).join("\n");
  }
  /**
   * Create a copy of this graph
   */
  clone() {
    return new Graph(this.toArray());
  }
  /**
   * Check if two graphs are equal
   */
  equals(other) {
    if (this.size() !== other.size())
      return false;
    for (const triple of this.triples) {
      if (!other.has(triple))
        return false;
    }
    return true;
  }
};

// src/domain/core/Result.ts
var Result = class {
  constructor(isSuccess, error, value) {
    if (isSuccess && error) {
      throw new Error("InvalidOperation: A result cannot be successful and contain an error");
    }
    if (!isSuccess && !error) {
      throw new Error("InvalidOperation: A failing result needs to contain an error message");
    }
    this.isSuccess = isSuccess;
    this.isFailure = !isSuccess;
    this.error = error;
    this._value = value;
    Object.freeze(this);
  }
  getValue() {
    if (!this.isSuccess) {
      throw new Error(`Can't get the value of an error result. Use 'errorValue' instead.`);
    }
    return this._value;
  }
  errorValue() {
    return this.error;
  }
  getErrorMessage() {
    return this.error;
  }
  static ok(value) {
    return new Result(true, void 0, value);
  }
  static fail(error) {
    return new Result(false, error);
  }
  static combine(results) {
    for (const result of results) {
      if (result.isFailure)
        return result;
    }
    return Result.ok();
  }
};

// src/domain/semantic/core/Triple.ts
var IRI = class {
  constructor(value) {
    this.value = value;
    if (!this.isValid(value)) {
      throw new Error(`Invalid IRI: ${value}`);
    }
  }
  isValid(value) {
    try {
      new URL(value);
      return true;
    } catch (e) {
      return /^[a-zA-Z][a-zA-Z0-9_]*(__[a-zA-Z][a-zA-Z0-9_]*(_[a-zA-Z][a-zA-Z0-9_]*)?)?$/.test(value) || /^[a-zA-Z][a-zA-Z0-9]*:[a-zA-Z_][a-zA-Z0-9_-]*$/.test(value);
    }
  }
  toString() {
    return this.value;
  }
  equals(other) {
    return this.value === other.value;
  }
  static from(value) {
    try {
      return Result.ok(new IRI(value));
    } catch (error) {
      return Result.fail(`Invalid IRI: ${error.message}`);
    }
  }
};
var _BlankNode = class {
  constructor(id = _BlankNode.generateId()) {
    this.id = id;
  }
  static generateId() {
    return `_:b${++_BlankNode.counter}`;
  }
  toString() {
    return this.id;
  }
  equals(other) {
    return this.id === other.id;
  }
};
var BlankNode = _BlankNode;
BlankNode.counter = 0;
var Literal = class {
  constructor(value, datatype, language) {
    this.value = value;
    this.datatype = datatype;
    this.language = language;
    if (language && datatype) {
      throw new Error("Literal cannot have both language and datatype");
    }
  }
  toString() {
    if (this.language) {
      return `"${this.value}"@${this.language}`;
    }
    if (this.datatype) {
      return `"${this.value}"^^${this.datatype.toString()}`;
    }
    return `"${this.value}"`;
  }
  getValue() {
    return this.value;
  }
  getDatatype() {
    return this.datatype;
  }
  getLanguage() {
    return this.language;
  }
  equals(other) {
    const datatypeEquals = this.datatype && other.datatype ? this.datatype.equals(other.datatype) : this.datatype === other.datatype;
    return this.value === other.value && datatypeEquals && this.language === other.language;
  }
  static string(value) {
    return new Literal(value, XSD.string);
  }
  static boolean(value) {
    return new Literal(value.toString(), XSD.boolean);
  }
  static integer(value) {
    return new Literal(Math.floor(value).toString(), XSD.integer);
  }
  static double(value) {
    return new Literal(value.toString(), XSD.double);
  }
  static dateTime(value) {
    return new Literal(value.toISOString(), XSD.dateTime);
  }
  static langString(value, language) {
    return new Literal(value, void 0, language);
  }
};
var Triple = class {
  constructor(subject, predicate, object) {
    this.subject = subject;
    this.predicate = predicate;
    this.object = object;
  }
  getSubject() {
    return this.subject;
  }
  getPredicate() {
    return this.predicate;
  }
  getObject() {
    return this.object;
  }
  toString() {
    return `${this.subject.toString()} ${this.predicate.toString()} ${this.object.toString()} .`;
  }
  equals(other) {
    return this.subjectEquals(other.subject) && this.predicate.equals(other.predicate) && this.objectEquals(other.object);
  }
  subjectEquals(other) {
    if (this.subject instanceof IRI && other instanceof IRI) {
      return this.subject.equals(other);
    }
    if (this.subject instanceof BlankNode && other instanceof BlankNode) {
      return this.subject.equals(other);
    }
    return false;
  }
  objectEquals(other) {
    if (this.object instanceof IRI && other instanceof IRI) {
      return this.object.equals(other);
    }
    if (this.object instanceof BlankNode && other instanceof BlankNode) {
      return this.object.equals(other);
    }
    if (this.object instanceof Literal && other instanceof Literal) {
      return this.object.equals(other);
    }
    return false;
  }
};
var RDF = class {
};
RDF.namespace = new IRI("http://www.w3.org/1999/02/22-rdf-syntax-ns#");
RDF.type = new IRI("http://www.w3.org/1999/02/22-rdf-syntax-ns#type");
RDF.Property = new IRI("http://www.w3.org/1999/02/22-rdf-syntax-ns#Property");
RDF.Statement = new IRI("http://www.w3.org/1999/02/22-rdf-syntax-ns#Statement");
RDF.subject = new IRI("http://www.w3.org/1999/02/22-rdf-syntax-ns#subject");
RDF.predicate = new IRI("http://www.w3.org/1999/02/22-rdf-syntax-ns#predicate");
RDF.object = new IRI("http://www.w3.org/1999/02/22-rdf-syntax-ns#object");
var RDFS = class {
};
RDFS.namespace = new IRI("http://www.w3.org/2000/01/rdf-schema#");
RDFS.Class = new IRI("http://www.w3.org/2000/01/rdf-schema#Class");
RDFS.subClassOf = new IRI("http://www.w3.org/2000/01/rdf-schema#subClassOf");
RDFS.subPropertyOf = new IRI("http://www.w3.org/2000/01/rdf-schema#subPropertyOf");
RDFS.domain = new IRI("http://www.w3.org/2000/01/rdf-schema#domain");
RDFS.range = new IRI("http://www.w3.org/2000/01/rdf-schema#range");
RDFS.label = new IRI("http://www.w3.org/2000/01/rdf-schema#label");
RDFS.comment = new IRI("http://www.w3.org/2000/01/rdf-schema#comment");
var OWL = class {
};
OWL.namespace = new IRI("http://www.w3.org/2002/07/owl#");
OWL.Class = new IRI("http://www.w3.org/2002/07/owl#Class");
OWL.ObjectProperty = new IRI("http://www.w3.org/2002/07/owl#ObjectProperty");
OWL.DatatypeProperty = new IRI("http://www.w3.org/2002/07/owl#DatatypeProperty");
OWL.sameAs = new IRI("http://www.w3.org/2002/07/owl#sameAs");
OWL.differentFrom = new IRI("http://www.w3.org/2002/07/owl#differentFrom");
OWL.equivalentClass = new IRI("http://www.w3.org/2002/07/owl#equivalentClass");
var XSD = class {
};
XSD.namespace = new IRI("http://www.w3.org/2001/XMLSchema#");
XSD.string = new IRI("http://www.w3.org/2001/XMLSchema#string");
XSD.boolean = new IRI("http://www.w3.org/2001/XMLSchema#boolean");
XSD.integer = new IRI("http://www.w3.org/2001/XMLSchema#integer");
XSD.double = new IRI("http://www.w3.org/2001/XMLSchema#double");
XSD.dateTime = new IRI("http://www.w3.org/2001/XMLSchema#dateTime");
XSD.date = new IRI("http://www.w3.org/2001/XMLSchema#date");
var EXO = class {
};
EXO.namespace = new IRI("https://exocortex.io/ontology/core#");
EXO.Asset = new IRI("https://exocortex.io/ontology/core#Asset");
EXO.uuid = new IRI("https://exocortex.io/ontology/core#uuid");
EXO.createdAt = new IRI("https://exocortex.io/ontology/core#createdAt");
EXO.updatedAt = new IRI("https://exocortex.io/ontology/core#updatedAt");
EXO.isDefinedBy = new IRI("https://exocortex.io/ontology/core#isDefinedBy");
var EMS = class {
};
EMS.namespace = new IRI("https://exocortex.io/ontology/ems#");
EMS.Task = new IRI("https://exocortex.io/ontology/ems#Task");
EMS.Project = new IRI("https://exocortex.io/ontology/ems#Project");
EMS.Area = new IRI("https://exocortex.io/ontology/ems#Area");
EMS.status = new IRI("https://exocortex.io/ontology/ems#status");
EMS.priority = new IRI("https://exocortex.io/ontology/ems#priority");

// src/presentation/processors/SPARQLProcessor.ts
var import_obsidian4 = require("obsidian");

// src/application/services/QueryCache.ts
var DEFAULT_CACHE_CONFIG = {
  maxSize: 1e3,
  defaultTTL: 5 * 60 * 1e3,
  // 5 minutes
  maxTTL: 30 * 60 * 1e3,
  // 30 minutes
  cleanupInterval: 60 * 1e3,
  // 1 minute
  enabled: true
};
var QueryCache = class {
  constructor(config = {}) {
    this.config = { ...DEFAULT_CACHE_CONFIG, ...config };
    this.cache = /* @__PURE__ */ new Map();
    this.stats = {
      hits: 0,
      misses: 0,
      evictions: 0,
      totalQueries: 0,
      hitRate: 0,
      size: 0,
      maxSize: this.config.maxSize
    };
    this.startCleanupTimer();
  }
  /**
   * Get cached result for a query
   */
  get(queryKey) {
    if (!this.config.enabled) {
      this.stats.misses++;
      this.stats.totalQueries++;
      this.updateHitRate();
      return null;
    }
    const entry = this.cache.get(queryKey);
    this.stats.totalQueries++;
    if (!entry) {
      this.stats.misses++;
      this.updateHitRate();
      return null;
    }
    if (Date.now() > entry.expiresAt) {
      this.cache.delete(queryKey);
      this.stats.misses++;
      this.stats.evictions++;
      this.updateStats();
      this.updateHitRate();
      return null;
    }
    this.stats.hits++;
    this.updateHitRate();
    return entry.value;
  }
  /**
   * Set cached result for a query
   */
  set(queryKey, value, ttl) {
    if (!this.config.enabled) {
      return;
    }
    const requestedTTL = ttl !== void 0 ? ttl : this.config.defaultTTL;
    const effectiveTTL = Math.min(Math.max(requestedTTL, 0), this.config.maxTTL);
    const now = Date.now();
    if (effectiveTTL <= 0) {
      return;
    }
    while (this.cache.size >= this.config.maxSize) {
      this.evictOldest();
    }
    const entry = {
      value,
      timestamp: now,
      expiresAt: now + effectiveTTL,
      queryHash: this.hashQuery(queryKey)
    };
    this.cache.set(queryKey, entry);
    this.updateStats();
  }
  /**
   * Normalize and create cache key from SPARQL query
   */
  createCacheKey(query) {
    const colonIndex = query.indexOf(":");
    let prefix = "";
    let queryPart = query;
    if (colonIndex > 0 && colonIndex < 20) {
      prefix = query.substring(0, colonIndex).toLowerCase() + ":";
      queryPart = query.substring(colonIndex + 1);
    }
    const normalized = queryPart.trim().replace(/[\r\n\t]+/g, " ").replace(/\s+/g, " ").replace(/\s*\{\s*/g, " { ").replace(/\s*\}\s*/g, " } ").replace(/\s*\(\s*/g, " ( ").replace(/\s*\)\s*/g, " ) ").replace(/\s+/g, " ").trim().toLowerCase();
    const fullKey = prefix + normalized;
    if (fullKey.length > 1e3) {
      return this.hashQuery(fullKey);
    }
    return fullKey;
  }
  /**
   * Invalidate all cached entries
   */
  invalidateAll() {
    const sizeBefore = this.cache.size;
    this.cache.clear();
    this.stats.evictions += sizeBefore;
    this.updateStats();
  }
  /**
   * Invalidate entries based on a predicate function
   */
  invalidateWhere(predicate) {
    let invalidated = 0;
    for (const [key, entry] of this.cache.entries()) {
      if (predicate(key, entry)) {
        this.cache.delete(key);
        invalidated++;
      }
    }
    this.stats.evictions += invalidated;
    this.updateStats();
    return invalidated;
  }
  /**
   * Get current cache statistics
   */
  getStatistics() {
    return { ...this.stats };
  }
  /**
   * Update cache configuration
   */
  updateConfig(newConfig) {
    this.config = { ...this.config, ...newConfig };
    this.stats.maxSize = this.config.maxSize;
    if (!this.config.enabled) {
      this.invalidateAll();
    }
    while (this.cache.size > this.config.maxSize) {
      this.evictOldest();
    }
    this.updateStats();
    if (newConfig.cleanupInterval !== void 0) {
      this.stopCleanupTimer();
      this.startCleanupTimer();
    }
  }
  /**
   * Get current configuration
   */
  getConfig() {
    return { ...this.config };
  }
  /**
   * Manually trigger cleanup of expired entries
   */
  cleanup() {
    const now = Date.now();
    let cleaned = 0;
    for (const [key, entry] of this.cache.entries()) {
      if (now > entry.expiresAt) {
        this.cache.delete(key);
        cleaned++;
      }
    }
    if (cleaned > 0) {
      this.stats.evictions += cleaned;
      this.updateStats();
    }
    return cleaned;
  }
  /**
   * Check if a query result is cached
   */
  has(queryKey) {
    if (!this.config.enabled) {
      return false;
    }
    const entry = this.cache.get(queryKey);
    if (!entry) {
      return false;
    }
    if (Date.now() > entry.expiresAt) {
      this.cache.delete(queryKey);
      this.stats.evictions++;
      this.updateStats();
      return false;
    }
    return true;
  }
  /**
   * Destroy the cache and cleanup resources
   */
  destroy() {
    this.stopCleanupTimer();
    this.cache.clear();
  }
  // Private methods
  hashQuery(query) {
    let hash = 0;
    if (query.length === 0)
      return hash.toString();
    for (let i = 0; i < query.length; i++) {
      const char = query.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString();
  }
  evictOldest() {
    let oldestKey = null;
    let oldestTimestamp = Infinity;
    for (const [key, entry] of this.cache.entries()) {
      if (entry.timestamp < oldestTimestamp) {
        oldestTimestamp = entry.timestamp;
        oldestKey = key;
      }
    }
    if (oldestKey) {
      this.cache.delete(oldestKey);
      this.stats.evictions++;
      this.updateStats();
    }
  }
  updateStats() {
    this.stats.size = this.cache.size;
  }
  updateHitRate() {
    this.stats.hitRate = this.stats.totalQueries > 0 ? this.stats.hits / this.stats.totalQueries * 100 : 0;
  }
  startCleanupTimer() {
    if (this.config.cleanupInterval > 0) {
      this.cleanupTimer = setInterval(() => {
        this.cleanup();
      }, this.config.cleanupInterval);
    }
  }
  stopCleanupTimer() {
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
      this.cleanupTimer = void 0;
    }
  }
};

// src/application/SPARQLEngine.ts
var SPARQLEngine = class {
  constructor(graph, cacheConfig) {
    this.graph = graph;
    this.queryCache = new QueryCache(cacheConfig);
  }
  /**
   * Execute CONSTRUCT query to generate new triples
   */
  construct(query) {
    const cacheKey = this.queryCache.createCacheKey(`CONSTRUCT:${query}`);
    const cachedResult = this.queryCache.get(cacheKey);
    if (cachedResult) {
      return { ...cachedResult, cached: true };
    }
    const constructMatch = query.match(/CONSTRUCT\s*\{(.*?)\}\s*WHERE\s*\{(.*?)\}/is);
    if (!constructMatch) {
      throw new Error("Invalid CONSTRUCT query format");
    }
    const template = this.parseConstructTemplate(constructMatch[1]);
    const patterns = this.parsePatterns(constructMatch[2]);
    if (patterns.length === 0) {
      return { triples: [], provenance: `CONSTRUCT query at ${new Date().toISOString()}` };
    }
    const generatedTriples = [];
    if (patterns.length === 1) {
      const pattern = patterns[0];
      const subject = pattern.subject.startsWith("?") ? null : new IRI(pattern.subject);
      const predicate = pattern.predicate.startsWith("?") ? null : new IRI(pattern.predicate);
      const object = pattern.object.startsWith("?") ? null : pattern.object.startsWith('"') ? Literal.string(pattern.object.replace(/^"|"$/g, "")) : new IRI(pattern.object);
      const matchedTriples = this.graph.match(subject, predicate, object);
      for (const triple of matchedTriples) {
        const binding = this.createBinding(pattern, triple);
        const newTriples = this.instantiateTemplate(template, binding);
        generatedTriples.push(...newTriples);
      }
    } else {
      const bindings = this.executeWhereClause(patterns);
      for (const binding of bindings) {
        const newTriples = this.instantiateTemplate(template, binding);
        generatedTriples.push(...newTriples);
      }
    }
    const limitMatch = query.match(/LIMIT\s+(\d+)/i);
    let result;
    if (limitMatch) {
      const limit = parseInt(limitMatch[1]);
      result = {
        triples: generatedTriples.slice(0, limit),
        provenance: `CONSTRUCT query at ${new Date().toISOString()}`,
        cached: false
      };
    } else {
      result = {
        triples: generatedTriples,
        provenance: `CONSTRUCT query at ${new Date().toISOString()}`,
        cached: false
      };
    }
    this.queryCache.set(cacheKey, result);
    return result;
  }
  parseConstructTemplate(templateClause) {
    const templates = [];
    const lines = templateClause.trim().split(/\.\s*(?:\n|\s|$)/);
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed)
        continue;
      const parts = trimmed.split(/\s+/);
      if (parts.length >= 3) {
        let object = parts.slice(2).join(" ");
        templates.push({
          subject: parts[0],
          predicate: parts[1],
          object
        });
      }
    }
    return templates;
  }
  createBinding(pattern, triple) {
    const binding = {};
    if (pattern.subject.startsWith("?")) {
      binding[pattern.subject.substring(1)] = triple.getSubject().toString();
    }
    if (pattern.predicate.startsWith("?")) {
      binding[pattern.predicate.substring(1)] = triple.getPredicate().toString();
    }
    if (pattern.object.startsWith("?")) {
      binding[pattern.object.substring(1)] = triple.getObject().toString();
    }
    return binding;
  }
  instantiateTemplate(template, binding) {
    const triples = [];
    for (const t of template) {
      const subjectStr = this.resolveValue(t.subject, binding);
      const predicateStr = this.resolveValue(t.predicate, binding);
      const objectStr = this.resolveValue(t.object, binding);
      if (subjectStr && predicateStr && objectStr) {
        const subject = subjectStr.startsWith("_:") ? new BlankNode(subjectStr) : new IRI(subjectStr);
        const predicate = new IRI(predicateStr);
        let object;
        if (objectStr.startsWith('"')) {
          object = Literal.string(objectStr.replace(/^"|"$/g, ""));
        } else if (objectStr === "true" || objectStr === "false") {
          object = Literal.boolean(objectStr === "true");
        } else if (objectStr.startsWith("_:")) {
          object = new BlankNode(objectStr);
        } else if (/^\d+$/.test(objectStr)) {
          object = Literal.integer(parseInt(objectStr));
        } else if (/^\d+\.\d+$/.test(objectStr)) {
          object = Literal.double(parseFloat(objectStr));
        } else {
          object = new IRI(objectStr);
        }
        triples.push(new Triple(subject, predicate, object));
      }
    }
    return triples;
  }
  resolveValue(value, binding) {
    if (value.startsWith("?")) {
      const varName = value.substring(1);
      return binding[varName] || null;
    }
    return value;
  }
  executeWhereClause(patterns) {
    if (patterns.length === 0)
      return [];
    const firstPattern = patterns[0];
    const firstTriples = this.graph.match(
      firstPattern.subject.startsWith("?") ? null : firstPattern.subject,
      firstPattern.predicate.startsWith("?") ? null : firstPattern.predicate,
      firstPattern.object.startsWith("?") ? null : firstPattern.object
    );
    let bindings = [];
    for (const triple of firstTriples) {
      bindings.push(this.createBinding(firstPattern, triple));
    }
    for (let i = 1; i < patterns.length; i++) {
      const pattern = patterns[i];
      const newBindings = [];
      for (const binding of bindings) {
        const subjectStr = pattern.subject.startsWith("?") ? binding[pattern.subject.substring(1)] || null : pattern.subject;
        const predicateStr = pattern.predicate.startsWith("?") ? binding[pattern.predicate.substring(1)] || null : pattern.predicate;
        const objectStr = pattern.object.startsWith("?") ? binding[pattern.object.substring(1)] || null : pattern.object;
        const subject = subjectStr ? new IRI(subjectStr) : null;
        const predicate = predicateStr ? new IRI(predicateStr) : null;
        const object = objectStr ? objectStr.startsWith('"') ? Literal.string(objectStr.replace(/^"|"$/g, "")) : new IRI(objectStr) : null;
        const matches = this.graph.match(subject, predicate, object);
        for (const triple of matches) {
          const extendedBinding = { ...binding };
          if (pattern.subject.startsWith("?") && !subjectStr) {
            extendedBinding[pattern.subject.substring(1)] = triple.getSubject().toString();
          }
          if (pattern.predicate.startsWith("?") && !predicateStr) {
            extendedBinding[pattern.predicate.substring(1)] = triple.getPredicate().toString();
          }
          if (pattern.object.startsWith("?") && !objectStr) {
            extendedBinding[pattern.object.substring(1)] = triple.getObject().toString();
          }
          newBindings.push(extendedBinding);
        }
      }
      bindings = newBindings;
    }
    return bindings;
  }
  select(query) {
    const cacheKey = this.queryCache.createCacheKey(`SELECT:${query}`);
    const cachedResult = this.queryCache.get(cacheKey);
    if (cachedResult) {
      return { ...cachedResult, cached: true };
    }
    const results = [];
    const selectMatch = query.match(/SELECT\s+(.*?)\s+WHERE\s*\{(.*?)\}/is);
    if (!selectMatch) {
      throw new Error("Invalid SPARQL query format");
    }
    const variables = this.parseVariables(selectMatch[1]);
    const patterns = this.parsePatterns(selectMatch[2]);
    if (patterns.length === 0) {
      const emptyResult = { results: [], cached: false };
      this.queryCache.set(cacheKey, emptyResult);
      return emptyResult;
    }
    const pattern = patterns[0];
    const subject = pattern.subject.startsWith("?") ? null : new IRI(pattern.subject);
    const predicate = pattern.predicate.startsWith("?") ? null : new IRI(pattern.predicate);
    const object = pattern.object.startsWith("?") ? null : pattern.object.startsWith('"') ? Literal.string(pattern.object.replace(/^"|"$/g, "")) : new IRI(pattern.object);
    const triples = this.graph.match(subject, predicate, object);
    for (const triple of triples) {
      const binding = {};
      if (pattern.subject.startsWith("?")) {
        const varName = pattern.subject.substring(1);
        if (variables.includes("*") || variables.includes(varName)) {
          binding[varName] = triple.getSubject().toString();
        }
      }
      if (pattern.predicate.startsWith("?")) {
        const varName = pattern.predicate.substring(1);
        if (variables.includes("*") || variables.includes(varName)) {
          binding[varName] = triple.getPredicate().toString();
        }
      }
      if (pattern.object.startsWith("?")) {
        const varName = pattern.object.substring(1);
        if (variables.includes("*") || variables.includes(varName)) {
          binding[varName] = triple.getObject().toString();
        }
      }
      if (Object.keys(binding).length > 0) {
        results.push(binding);
      }
    }
    const limitMatch = query.match(/LIMIT\s+(\d+)/i);
    let result;
    if (limitMatch) {
      const limit = parseInt(limitMatch[1]);
      result = { results: results.slice(0, limit), cached: false };
    } else {
      result = { results, cached: false };
    }
    this.queryCache.set(cacheKey, result);
    return result;
  }
  parseVariables(selectClause) {
    const trimmed = selectClause.trim();
    if (trimmed === "*") {
      return ["*"];
    }
    const variables = [];
    const varPattern = /\?(\w+)/g;
    let match;
    while ((match = varPattern.exec(trimmed)) !== null) {
      variables.push(match[1]);
    }
    return variables;
  }
  parsePatterns(whereClause) {
    const patterns = [];
    const lines = whereClause.trim().split(/\.\s*(?:\n|\s|$)/);
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed)
        continue;
      const parts = trimmed.split(/\s+/);
      if (parts.length >= 3) {
        patterns.push({
          subject: parts[0],
          predicate: parts[1],
          object: parts.slice(2).join(" ")
          // Keep quotes for proper matching
        });
      }
    }
    return patterns;
  }
  /**
   * Get cache statistics
   */
  getCacheStatistics() {
    return this.queryCache.getStatistics();
  }
  /**
   * Invalidate all cached queries
   */
  invalidateCache() {
    this.queryCache.invalidateAll();
  }
  /**
   * Update cache configuration
   */
  updateCacheConfig(config) {
    this.queryCache.updateConfig(config);
  }
  /**
   * Get current cache configuration
   */
  getCacheConfig() {
    return this.queryCache.getConfig();
  }
  /**
   * Cleanup expired cache entries
   */
  cleanupCache() {
    return this.queryCache.cleanup();
  }
  /**
   * Destroy cache and cleanup resources
   */
  destroy() {
    this.queryCache.destroy();
  }
};

// src/application/services/RDFService.ts
var import_obsidian2 = require("obsidian");

// src/application/services/NamespaceManager.ts
var NamespaceManager = class {
  constructor() {
    this.bindings = /* @__PURE__ */ new Map();
    this.reverseBindings = /* @__PURE__ */ new Map();
    this.initializeDefaultNamespaces();
  }
  /**
   * Initialize common RDF namespace prefixes
   */
  initializeDefaultNamespaces() {
    this.addBinding("rdf", "http://www.w3.org/1999/02/22-rdf-syntax-ns#");
    this.addBinding("rdfs", "http://www.w3.org/2000/01/rdf-schema#");
    this.addBinding("owl", "http://www.w3.org/2002/07/owl#");
    this.addBinding("xsd", "http://www.w3.org/2001/XMLSchema#");
    this.addBinding("dc", "http://purl.org/dc/elements/1.1/");
    this.addBinding("dcterms", "http://purl.org/dc/terms/");
    this.addBinding("foaf", "http://xmlns.com/foaf/0.1/");
    this.addBinding("skos", "http://www.w3.org/2004/02/skos/core#");
    this.addBinding("void", "http://rdfs.org/ns/void#");
    this.addBinding("exo", "https://exocortex.io/ontology/core#");
    this.addBinding("ems", "https://exocortex.io/ontology/ems#");
    this.addBinding("vault", "obsidian://vault/");
  }
  /**
   * Add a namespace binding
   */
  addBinding(prefix, namespace) {
    try {
      const iri = new IRI(namespace);
      this.bindings.set(prefix, iri);
      this.reverseBindings.set(namespace, prefix);
    } catch (error) {
      console.warn(`Invalid namespace URI for prefix ${prefix}: ${namespace}`);
    }
  }
  /**
   * Remove a namespace binding
   */
  removeBinding(prefix) {
    const namespace = this.bindings.get(prefix);
    if (namespace) {
      this.bindings.delete(prefix);
      this.reverseBindings.delete(namespace.toString());
    }
  }
  /**
   * Get namespace URI for a prefix
   */
  getNamespace(prefix) {
    return this.bindings.get(prefix);
  }
  /**
   * Get prefix for a namespace URI
   */
  getPrefix(namespace) {
    return this.reverseBindings.get(namespace);
  }
  /**
   * Expand a CURIE (Compact URI) to full IRI
   */
  expandCURIE(curie) {
    const colonIndex = curie.indexOf(":");
    if (colonIndex === -1) {
      return Result.fail(`Invalid CURIE format: ${curie}`);
    }
    const prefix = curie.substring(0, colonIndex);
    const localName = curie.substring(colonIndex + 1);
    const namespace = this.bindings.get(prefix);
    if (!namespace) {
      return Result.fail(`Unknown prefix: ${prefix}`);
    }
    try {
      const fullIRI = new IRI(namespace.toString() + localName);
      return Result.ok(fullIRI);
    } catch (error) {
      return Result.fail(`Invalid expanded IRI: ${error.message}`);
    }
  }
  /**
   * Compress a full IRI to CURIE if possible
   */
  compressIRI(iri) {
    const iriString = iri.toString();
    for (const [namespace, prefix] of this.reverseBindings) {
      if (iriString.startsWith(namespace)) {
        const localName = iriString.substring(namespace.length);
        if (this.isValidLocalName(localName)) {
          return `${prefix}:${localName}`;
        }
      }
    }
    return `<${iriString}>`;
  }
  /**
   * Check if a local name is valid for CURIE compression
   */
  isValidLocalName(localName) {
    return /^[a-zA-Z_][a-zA-Z0-9_-]*$/.test(localName);
  }
  /**
   * Parse and add namespace prefixes from RDF content
   */
  parseNamespaces(content, format) {
    const lines = content.split("\n");
    for (const line of lines) {
      const trimmed = line.trim();
      if (format === "turtle" || format === "n3") {
        const prefixMatch = trimmed.match(/^@prefix\s+(\w+):\s+<([^>]+)>\s*\.\s*$/);
        if (prefixMatch) {
          const [, prefix, namespace] = prefixMatch;
          this.addBinding(prefix, namespace);
          continue;
        }
        const sparqlPrefixMatch = trimmed.match(/^PREFIX\s+(\w+):\s+<([^>]+)>\s*$/);
        if (sparqlPrefixMatch) {
          const [, prefix, namespace] = sparqlPrefixMatch;
          this.addBinding(prefix, namespace);
        }
      }
    }
  }
  /**
   * Generate namespace prefix declarations for a format
   */
  generatePrefixDeclarations(format) {
    const declarations = [];
    for (const [prefix, namespace] of this.bindings) {
      switch (format) {
        case "turtle":
        case "n3":
          declarations.push(`@prefix ${prefix}: <${namespace.toString()}> .`);
          break;
        case "sparql":
          declarations.push(`PREFIX ${prefix}: <${namespace.toString()}>`);
          break;
      }
    }
    return declarations.join("\n");
  }
  /**
   * Get all namespace bindings
   */
  getAllBindings() {
    return Array.from(this.bindings.entries()).map(([prefix, namespace]) => ({
      prefix,
      namespace
    }));
  }
  /**
   * Clear all custom bindings (keeps default ones)
   */
  clearCustomBindings() {
    this.bindings.clear();
    this.reverseBindings.clear();
    this.initializeDefaultNamespaces();
  }
  /**
   * Check if a prefix exists
   */
  hasPrefix(prefix) {
    return this.bindings.has(prefix);
  }
  /**
   * Check if a namespace exists
   */
  hasNamespace(namespace) {
    return this.reverseBindings.has(namespace);
  }
  /**
   * Create a copy of the namespace manager
   */
  clone() {
    const clone = new NamespaceManager();
    clone.clearCustomBindings();
    for (const [prefix, namespace] of this.bindings) {
      clone.addBinding(prefix, namespace.toString());
    }
    return clone;
  }
};

// src/application/services/RDFSerializer.ts
var RDFSerializer = class {
  constructor(namespaceManager) {
    this.namespaceManager = namespaceManager || new NamespaceManager();
  }
  /**
   * Serialize a graph to the specified RDF format
   */
  serialize(graph, options) {
    try {
      if (options.baseIRI) {
        try {
          new URL(options.baseIRI);
        } catch (e) {
          return Result.fail(`Invalid base IRI: ${options.baseIRI}`);
        }
      }
      const nm = options.namespaceManager || this.namespaceManager;
      let content;
      const warnings = [];
      switch (options.format) {
        case "turtle":
          content = this.serializeToTurtle(graph, nm, options);
          break;
        case "n-triples":
          content = this.serializeToNTriples(graph, warnings);
          break;
        case "json-ld":
          content = this.serializeToJSONLD(graph, nm, options);
          break;
        case "rdf-xml":
          content = this.serializeToRDFXML(graph, nm, options);
          break;
        default:
          return Result.fail(`Unsupported format: ${options.format}`);
      }
      const result = {
        content,
        format: options.format,
        tripleCount: graph.size(),
        metadata: {
          namespaces: this.extractNamespaces(nm),
          warnings: warnings.length > 0 ? warnings : void 0
        }
      };
      return Result.ok(result);
    } catch (error) {
      return Result.fail(`Serialization failed: ${error.message}`);
    }
  }
  /**
   * Serialize graph to Turtle format
   */
  serializeToTurtle(graph, nm, options) {
    const lines = [];
    const { includeComments = true, prettyPrint = true } = options;
    if (includeComments) {
      lines.push("# RDF Graph exported from Exocortex");
      lines.push(`# Generated on ${new Date().toISOString()}`);
      lines.push(`# Triple count: ${graph.size()}`);
      lines.push("");
    }
    const prefixDeclarations = nm.generatePrefixDeclarations("turtle");
    if (prefixDeclarations) {
      lines.push(prefixDeclarations);
      lines.push("");
    }
    const subjectGroups = this.groupTriplesBySubject(graph);
    for (const [subject, triples] of subjectGroups) {
      if (triples.length === 0)
        continue;
      const subjectStr = this.formatNode(subject, nm);
      if (triples.length === 1) {
        const triple = triples[0];
        const predicateStr = this.formatNode(triple.getPredicate(), nm);
        const objectStr = this.formatNode(triple.getObject(), nm);
        lines.push(`${subjectStr} ${predicateStr} ${objectStr} .`);
      } else {
        lines.push(`${subjectStr}`);
        const predicateGroups = this.groupTriplesByPredicate(triples);
        const predicateEntries = Array.from(predicateGroups.entries());
        for (let i = 0; i < predicateEntries.length; i++) {
          const [predicate, objects] = predicateEntries[i];
          const predicateStr = this.formatNode(predicate, nm);
          const isLast = i === predicateEntries.length - 1;
          if (objects.length === 1) {
            const objectStr = this.formatNode(objects[0], nm);
            lines.push(`    ${predicateStr} ${objectStr}${isLast ? " ." : " ;"}`);
          } else {
            lines.push(`    ${predicateStr}`);
            for (let j = 0; j < objects.length; j++) {
              const objectStr = this.formatNode(objects[j], nm);
              const isLastObject = j === objects.length - 1;
              const suffix = isLastObject ? isLast ? " ." : " ;" : " ,";
              lines.push(`        ${objectStr}${suffix}`);
            }
          }
        }
      }
      if (prettyPrint) {
        lines.push("");
      }
    }
    return lines.join("\n");
  }
  /**
   * Serialize graph to N-Triples format
   */
  serializeToNTriples(graph, warnings) {
    const lines = [];
    for (const triple of graph.toArray()) {
      try {
        const subjectStr = this.formatNodeNTriples(triple.getSubject());
        const predicateStr = this.formatNodeNTriples(triple.getPredicate());
        const objectStr = this.formatNodeNTriples(triple.getObject());
        lines.push(`${subjectStr} ${predicateStr} ${objectStr} .`);
      } catch (error) {
        warnings.push(`Failed to serialize triple: ${error.message}`);
      }
    }
    return lines.join("\n");
  }
  /**
   * Serialize graph to JSON-LD format
   */
  serializeToJSONLD(graph, nm, options) {
    const context = {};
    for (const binding of nm.getAllBindings()) {
      context[binding.prefix] = binding.namespace.toString();
    }
    if (options.baseIRI) {
      context["@base"] = options.baseIRI;
    }
    const subjects = {};
    for (const triple of graph.toArray()) {
      const subjectId = this.formatNodeJSONLD(triple.getSubject(), nm);
      const predicate = this.formatNodeJSONLD(triple.getPredicate(), nm);
      const object = this.formatObjectJSONLD(triple.getObject(), nm);
      if (!subjects[subjectId]) {
        subjects[subjectId] = { "@id": subjectId };
      }
      if (subjects[subjectId][predicate]) {
        if (!Array.isArray(subjects[subjectId][predicate])) {
          subjects[subjectId][predicate] = [subjects[subjectId][predicate]];
        }
        subjects[subjectId][predicate].push(object);
      } else {
        subjects[subjectId][predicate] = object;
      }
    }
    const jsonLD = {
      "@context": context,
      "@graph": Object.values(subjects)
    };
    return JSON.stringify(jsonLD, null, options.prettyPrint ? 2 : 0);
  }
  /**
   * Serialize graph to RDF/XML format
   */
  serializeToRDFXML(graph, nm, options) {
    const lines = [];
    lines.push('<?xml version="1.0" encoding="UTF-8"?>');
    let rdfElement = "<rdf:RDF";
    rdfElement += ' xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"';
    for (const binding of nm.getAllBindings()) {
      if (binding.prefix !== "rdf") {
        rdfElement += ` xmlns:${binding.prefix}="${binding.namespace.toString()}"`;
      }
    }
    if (options.baseIRI) {
      rdfElement += ` xml:base="${options.baseIRI}"`;
    }
    rdfElement += ">";
    lines.push(rdfElement);
    const subjectGroups = this.groupTriplesBySubject(graph);
    for (const [subject, triples] of subjectGroups) {
      if (triples.length === 0)
        continue;
      const rdfTypeTriples = triples.filter(
        (t) => t.getPredicate().toString() === "http://www.w3.org/1999/02/22-rdf-syntax-ns#type"
      );
      if (rdfTypeTriples.length > 0) {
        const type = rdfTypeTriples[0].getObject();
        const typeStr = this.formatNodeRDFXML(type, nm);
        lines.push(`  <${typeStr} rdf:about="${this.escapeXML(subject.toString())}">`);
      } else {
        lines.push(`  <rdf:Description rdf:about="${this.escapeXML(subject.toString())}">`);
      }
      for (const triple of triples) {
        const predicate = triple.getPredicate();
        const object = triple.getObject();
        if (predicate.toString() === "http://www.w3.org/1999/02/22-rdf-syntax-ns#type") {
          continue;
        }
        const predicateStr = this.formatNodeRDFXML(predicate, nm);
        if (object instanceof Literal) {
          let literalElement = `    <${predicateStr}`;
          if (object.getDatatype()) {
            literalElement += ` rdf:datatype="${this.escapeXML(object.getDatatype().toString())}"`;
          }
          if (object.getLanguage()) {
            literalElement += ` xml:lang="${object.getLanguage()}"`;
          }
          literalElement += `>${this.escapeXML(object.getValue())}</${predicateStr}>`;
          lines.push(literalElement);
        } else {
          const objectAttr = object instanceof BlankNode ? `rdf:nodeID="${object.toString().substring(2)}"` : `rdf:resource="${this.escapeXML(object.toString())}"`;
          lines.push(`    <${predicateStr} ${objectAttr}/>`);
        }
      }
      if (rdfTypeTriples.length > 0) {
        const type = rdfTypeTriples[0].getObject();
        const typeStr = this.formatNodeRDFXML(type, nm);
        lines.push(`  </${typeStr}>`);
      } else {
        lines.push("  </rdf:Description>");
      }
    }
    lines.push("</rdf:RDF>");
    return lines.join("\n");
  }
  /**
   * Group triples by subject
   */
  groupTriplesBySubject(graph) {
    const groups = /* @__PURE__ */ new Map();
    for (const triple of graph.toArray()) {
      const subject = triple.getSubject();
      const subjectKey = subject.toString();
      if (!groups.has(subject)) {
        groups.set(subject, []);
      }
      groups.get(subject).push(triple);
    }
    return groups;
  }
  /**
   * Group triples by predicate
   */
  groupTriplesByPredicate(triples) {
    const groups = /* @__PURE__ */ new Map();
    for (const triple of triples) {
      const predicate = triple.getPredicate();
      if (!groups.has(predicate)) {
        groups.set(predicate, []);
      }
      groups.get(predicate).push(triple.getObject());
    }
    return groups;
  }
  /**
   * Format a node for Turtle/N3 output
   */
  formatNode(node, nm) {
    if (node instanceof IRI) {
      return nm.compressIRI(node);
    } else if (node instanceof BlankNode) {
      return node.toString();
    } else if (node instanceof Literal) {
      return node.toString();
    }
    throw new Error(`Unknown node type: ${typeof node}`);
  }
  /**
   * Format a node for N-Triples output (no prefixes)
   */
  formatNodeNTriples(node) {
    if (node instanceof IRI) {
      return `<${node.toString()}>`;
    } else if (node instanceof BlankNode) {
      return node.toString();
    } else if (node instanceof Literal) {
      return node.toString();
    }
    throw new Error(`Unknown node type: ${typeof node}`);
  }
  /**
   * Format a node for JSON-LD output
   */
  formatNodeJSONLD(node, nm) {
    if (node instanceof IRI) {
      const compressed = nm.compressIRI(node);
      return compressed.startsWith("<") && compressed.endsWith(">") ? compressed.slice(1, -1) : compressed;
    } else if (node instanceof BlankNode) {
      return node.toString();
    }
    throw new Error(`Invalid node type for JSON-LD ID: ${typeof node}`);
  }
  /**
   * Format an object for JSON-LD output
   */
  formatObjectJSONLD(object, nm) {
    if (object instanceof IRI) {
      return { "@id": this.formatNodeJSONLD(object, nm) };
    } else if (object instanceof BlankNode) {
      return { "@id": object.toString() };
    } else if (object instanceof Literal) {
      const result = { "@value": object.getValue() };
      if (object.getDatatype()) {
        result["@type"] = this.formatNodeJSONLD(object.getDatatype(), nm);
      }
      if (object.getLanguage()) {
        result["@language"] = object.getLanguage();
      }
      return result;
    }
    throw new Error(`Unknown object type: ${typeof object}`);
  }
  /**
   * Format a node for RDF/XML output
   */
  formatNodeRDFXML(node, nm) {
    if (node instanceof IRI) {
      const compressed = nm.compressIRI(node);
      return compressed.startsWith("<") && compressed.endsWith(">") ? node.toString() : compressed;
    } else if (node instanceof BlankNode) {
      return node.toString();
    } else if (node instanceof Literal) {
      return node.toString();
    }
    throw new Error(`Unknown node type: ${typeof node}`);
  }
  /**
   * Escape special XML characters
   */
  escapeXML(text) {
    return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
  }
  /**
   * Extract namespaces from namespace manager
   */
  extractNamespaces(nm) {
    const namespaces = {};
    for (const binding of nm.getAllBindings()) {
      namespaces[binding.prefix] = binding.namespace.toString();
    }
    return namespaces;
  }
  /**
   * Get file extension for format
   */
  static getFileExtension(format) {
    switch (format) {
      case "turtle":
        return ".ttl";
      case "n-triples":
        return ".nt";
      case "json-ld":
        return ".jsonld";
      case "rdf-xml":
        return ".rdf";
      default:
        return ".rdf";
    }
  }
  /**
   * Get MIME type for format
   */
  static getMimeType(format) {
    switch (format) {
      case "turtle":
        return "text/turtle";
      case "n-triples":
        return "application/n-triples";
      case "json-ld":
        return "application/ld+json";
      case "rdf-xml":
        return "application/rdf+xml";
      default:
        return "application/rdf+xml";
    }
  }
};

// src/application/services/RDFParser.ts
var RDFParser = class {
  constructor(namespaceManager) {
    this.namespaceManager = namespaceManager || new NamespaceManager();
  }
  /**
   * Parse RDF content into a Graph
   */
  parse(content, options = {}) {
    try {
      const nm = options.namespaceManager || this.namespaceManager.clone();
      const format = options.format || this.detectFormat(content);
      const warnings = [];
      const errors = [];
      let graph;
      switch (format) {
        case "turtle":
          graph = this.parseTurtle(content, nm, options, warnings, errors);
          break;
        case "n-triples":
          graph = this.parseNTriples(content, warnings, errors);
          break;
        case "json-ld":
          graph = this.parseJSONLD(content, nm, options, warnings, errors);
          break;
        case "rdf-xml":
          graph = this.parseRDFXML(content, nm, options, warnings, errors);
          break;
        default:
          return Result.fail(`Unsupported format: ${format}`);
      }
      if (options.validateInput) {
        const validationErrors = this.validateGraph(graph);
        errors.push(...validationErrors);
      }
      if (options.strictMode && errors.length > 0) {
        return Result.fail(`Parse errors in strict mode: ${errors.join("; ")}`);
      }
      const result = {
        graph,
        tripleCount: graph.size(),
        namespaces: this.extractNamespaces(nm),
        warnings: warnings.length > 0 ? warnings : void 0,
        errors: errors.length > 0 ? errors : void 0
      };
      return Result.ok(result);
    } catch (error) {
      return Result.fail(`Parse failed: ${error.message}`);
    }
  }
  /**
   * Detect RDF format from content
   */
  detectFormat(content) {
    const trimmed = content.trim();
    if (trimmed.startsWith("{") && trimmed.endsWith("}")) {
      try {
        const parsed = JSON.parse(trimmed);
        if (parsed["@context"] || parsed["@graph"] || parsed["@id"]) {
          return "json-ld";
        }
      } catch (e) {
      }
    }
    if (trimmed.startsWith("<?xml") || trimmed.includes("<rdf:RDF")) {
      return "rdf-xml";
    }
    if (trimmed.includes("@prefix") || trimmed.includes("@base")) {
      return "turtle";
    }
    const lines = trimmed.split("\n").filter((line) => line.trim());
    if (lines.every((line) => line.trim().endsWith(" ."))) {
      if (lines.some((line) => line.includes("<") && line.includes(">"))) {
        return "n-triples";
      }
    }
    return "turtle";
  }
  /**
   * Parse Turtle format
   */
  parseTurtle(content, nm, options, warnings, errors) {
    const graph = new Graph();
    let currentSubject = null;
    let baseIRI = options.baseIRI;
    const prefixPattern = /@prefix\s+(\w+):\s+<([^>]+)>\s*\./g;
    let match;
    while ((match = prefixPattern.exec(content)) !== null) {
      nm.addBinding(match[1], match[2]);
    }
    let processedContent = content.replace(/@prefix\s+\w+:\s+<[^>]+>\s*\./g, "");
    const basePattern = /@base\s+<([^>]+)>\s*\./g;
    const baseMatch = basePattern.exec(processedContent);
    if (baseMatch) {
      baseIRI = baseMatch[1];
      processedContent = processedContent.replace(/@base\s+<[^>]+>\s*\./g, "");
    }
    const statements = processedContent.split(/\.\s*(?=(?:[^"]*"[^"]*")*[^"]*$)/).filter((s) => s.trim());
    for (let i = 0; i < statements.length; i++) {
      const statement = statements[i].trim();
      if (!statement || statement.startsWith("#"))
        continue;
      try {
        const triples = this.parseTurtleStatement(statement, nm, currentSubject, baseIRI);
        for (const triple of triples) {
          if (triple.subject) {
            currentSubject = triple.subject;
          }
          if (triple.triple) {
            graph.add(triple.triple);
          }
        }
      } catch (error) {
        const errorMsg = `Statement ${i + 1}: ${error.message}`;
        if (options.strictMode) {
          errors.push(errorMsg);
        } else {
          warnings.push(errorMsg);
        }
      }
    }
    return graph;
  }
  /**
   * Parse a single Turtle statement
   */
  parseTurtleStatement(statement, nm, currentSubject, baseIRI) {
    const results = [];
    statement = statement.trim();
    if (!statement)
      return results;
    statement = statement.replace(/\.\s*$/, "");
    if (statement.includes(";")) {
      const parts = statement.split(";").map((s) => s.trim()).filter((s) => s);
      let subject = null;
      for (let i = 0; i < parts.length; i++) {
        const tokens = this.tokenizeTurtleLine(parts[i]);
        if (i === 0 && tokens.length >= 3) {
          subject = this.parseNode(tokens[0], nm, baseIRI);
          const predicate = this.parseNode(tokens[1], nm, baseIRI);
          const object = this.parseNode(tokens[2], nm, baseIRI);
          const triple = new Triple(subject, predicate, object);
          results.push({ subject, triple });
        } else if (subject && tokens.length >= 2) {
          const predicate = this.parseNode(tokens[0], nm, baseIRI);
          const object = this.parseNode(tokens[1], nm, baseIRI);
          const triple = new Triple(subject, predicate, object);
          results.push({ triple });
        }
      }
    } else {
      const tokens = this.tokenizeTurtleLine(statement);
      if (tokens.length >= 3) {
        const subject = this.parseNode(tokens[0], nm, baseIRI);
        const predicate = this.parseNode(tokens[1], nm, baseIRI);
        const object = this.parseNode(tokens[2], nm, baseIRI);
        const triple = new Triple(subject, predicate, object);
        results.push({ subject, triple });
      }
    }
    return results;
  }
  /**
   * Tokenize a Turtle line
   */
  tokenizeTurtleLine(line) {
    const tokens = [];
    let current = "";
    let inQuotes = false;
    let quoteChar = "";
    let inBrackets = false;
    let afterQuote = false;
    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      const nextChar = i < line.length - 1 ? line[i + 1] : "";
      if (char === '"' || char === "'") {
        if (!inQuotes) {
          inQuotes = true;
          quoteChar = char;
          afterQuote = false;
        } else if (char === quoteChar) {
          inQuotes = false;
          quoteChar = "";
          afterQuote = true;
        }
        current += char;
      } else if (char === "<") {
        inBrackets = true;
        current += char;
      } else if (char === ">") {
        inBrackets = false;
        current += char;
        if (nextChar === " " || nextChar === "") {
          if (current) {
            tokens.push(current);
            current = "";
          }
        }
      } else if (char === "^" && nextChar === "^" && afterQuote) {
        current += "^^";
        i++;
      } else if (char === " " && !inQuotes && !inBrackets) {
        if (current) {
          tokens.push(current);
          current = "";
          afterQuote = false;
        }
      } else {
        current += char;
      }
    }
    if (current) {
      tokens.push(current);
    }
    return tokens;
  }
  /**
   * Parse N-Triples format
   */
  parseNTriples(content, warnings, errors) {
    const graph = new Graph();
    const lines = content.split("\n");
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (!line || line.startsWith("#"))
        continue;
      try {
        const triple = this.parseNTriplesLine(line);
        if (triple) {
          graph.add(triple);
        }
      } catch (error) {
        warnings.push(`Line ${i + 1}: ${error.message}`);
      }
    }
    return graph;
  }
  /**
   * Parse a single N-Triples line
   */
  parseNTriplesLine(line) {
    const match = line.match(/^(<[^>]+>|_:[a-zA-Z0-9]+)\s+(<[^>]+>)\s+(<[^>]+>|_:[a-zA-Z0-9]+|"[^"]*"(?:\^\^<[^>]+>|@[a-z-]+)?)\s+\.\s*$/);
    if (!match) {
      throw new Error(`Invalid N-Triples format: ${line}`);
    }
    const [, subjectStr, predicateStr, objectStr] = match;
    const subject = this.parseNTriplesNode(subjectStr);
    const predicate = this.parseNTriplesNode(predicateStr);
    const object = this.parseNTriplesNode(objectStr);
    return new Triple(subject, predicate, object);
  }
  /**
   * Parse JSON-LD format
   */
  parseJSONLD(content, nm, options, warnings, errors) {
    const graph = new Graph();
    try {
      const jsonld = JSON.parse(content);
      if (jsonld["@context"]) {
        this.processJSONLDContext(jsonld["@context"], nm);
      }
      const graphData = jsonld["@graph"] || (Array.isArray(jsonld) ? jsonld : [jsonld]);
      const subjects = Array.isArray(graphData) ? graphData : [graphData];
      for (const subject of subjects) {
        this.processJSONLDSubject(subject, graph, nm, options.baseIRI);
      }
    } catch (error) {
      errors.push(`JSON-LD parse error: ${error.message}`);
    }
    return graph;
  }
  /**
   * Process JSON-LD context
   */
  processJSONLDContext(context, nm) {
    if (typeof context === "string") {
      return;
    }
    if (typeof context === "object") {
      for (const [key, value] of Object.entries(context)) {
        if (typeof value === "string" && key !== "@base" && key !== "@vocab") {
          nm.addBinding(key, value);
        }
      }
    }
  }
  /**
   * Process JSON-LD subject
   */
  processJSONLDSubject(subject, graph, nm, baseIRI) {
    if (!subject["@id"])
      return;
    const subjectNode = this.parseJSONLDNode(subject["@id"], nm, baseIRI);
    for (const [predicate, values] of Object.entries(subject)) {
      if (predicate === "@id" || predicate === "@context")
        continue;
      const predicateIRI = this.parseJSONLDPredicate(predicate, nm, baseIRI);
      const valueArray = Array.isArray(values) ? values : [values];
      for (const value of valueArray) {
        const objectNode = this.parseJSONLDValue(value, nm, baseIRI);
        const triple = new Triple(subjectNode, predicateIRI, objectNode);
        graph.add(triple);
      }
    }
  }
  /**
   * Parse RDF/XML format (basic implementation)
   */
  parseRDFXML(content, nm, options, warnings, errors) {
    const graph = new Graph();
    warnings.push("RDF/XML parsing is limited - consider using a specialized XML parser");
    return graph;
  }
  /**
   * Parse a node (IRI, BlankNode, or Literal)
   */
  parseNode(nodeStr, nm, baseIRI) {
    nodeStr = nodeStr.trim();
    if (nodeStr.startsWith("_:")) {
      return new BlankNode(nodeStr);
    }
    if (nodeStr.startsWith("<") && nodeStr.endsWith(">")) {
      const iri = nodeStr.slice(1, -1);
      return new IRI(baseIRI && !iri.includes("://") ? baseIRI + iri : iri);
    }
    if (nodeStr.startsWith('"')) {
      return this.parseLiteral(nodeStr);
    }
    if (nodeStr.includes(":")) {
      const expanded = nm.expandCURIE(nodeStr);
      if (expanded.isSuccess) {
        return expanded.getValue();
      }
    }
    throw new Error(`Cannot parse node: ${nodeStr}`);
  }
  /**
   * Parse N-Triples node
   */
  parseNTriplesNode(nodeStr) {
    nodeStr = nodeStr.trim();
    if (nodeStr.startsWith("<") && nodeStr.endsWith(">")) {
      return new IRI(nodeStr.slice(1, -1));
    }
    if (nodeStr.startsWith("_:")) {
      return new BlankNode(nodeStr);
    }
    if (nodeStr.startsWith('"')) {
      return this.parseLiteral(nodeStr);
    }
    throw new Error(`Cannot parse N-Triples node: ${nodeStr}`);
  }
  /**
   * Parse JSON-LD node
   */
  parseJSONLDNode(nodeId, nm, baseIRI) {
    if (nodeId.startsWith("_:")) {
      return new BlankNode(nodeId);
    }
    if (nodeId.includes(":") && !nodeId.startsWith("http")) {
      const expanded = nm.expandCURIE(nodeId);
      if (expanded.isSuccess) {
        return expanded.getValue();
      }
    }
    return new IRI(baseIRI && !nodeId.includes("://") ? baseIRI + nodeId : nodeId);
  }
  /**
   * Parse JSON-LD predicate
   */
  parseJSONLDPredicate(predicate, nm, baseIRI) {
    if (predicate.includes(":") && !predicate.startsWith("http")) {
      const expanded = nm.expandCURIE(predicate);
      if (expanded.isSuccess) {
        return expanded.getValue();
      }
    }
    return new IRI(baseIRI && !predicate.includes("://") ? baseIRI + predicate : predicate);
  }
  /**
   * Parse JSON-LD value
   */
  parseJSONLDValue(value, nm, baseIRI) {
    if (typeof value === "string") {
      return Literal.string(value);
    }
    if (typeof value === "number") {
      return Number.isInteger(value) ? Literal.integer(value) : Literal.double(value);
    }
    if (typeof value === "boolean") {
      return Literal.boolean(value);
    }
    if (typeof value === "object") {
      if (value["@id"]) {
        return this.parseJSONLDNode(value["@id"], nm, baseIRI);
      }
      if (value["@value"]) {
        let literal = new Literal(value["@value"]);
        if (value["@type"]) {
          const datatype = this.parseJSONLDPredicate(value["@type"], nm, baseIRI);
          literal = new Literal(value["@value"], datatype);
        }
        if (value["@language"]) {
          literal = new Literal(value["@value"], void 0, value["@language"]);
        }
        return literal;
      }
    }
    throw new Error(`Cannot parse JSON-LD value: ${JSON.stringify(value)}`);
  }
  /**
   * Parse a literal string
   */
  parseLiteral(literalStr) {
    let match = literalStr.match(/^"([^"]*)"$/);
    if (match) {
      return new Literal(match[1]);
    }
    match = literalStr.match(/^"([^"]*)"@([a-z-]+)$/);
    if (match) {
      return new Literal(match[1], void 0, match[2]);
    }
    match = literalStr.match(/^"([^"]*)"(?:\^\^)<([^>]+)>$/);
    if (match) {
      return new Literal(match[1], new IRI(match[2]));
    }
    if (literalStr.includes("^^<")) {
      const parts = literalStr.split("^^");
      if (parts.length === 2) {
        const value = parts[0].replace(/^"|"$/g, "");
        const datatype = parts[1].replace(/^<|>$/g, "");
        return new Literal(value, new IRI(datatype));
      }
    }
    match = literalStr.match(/^"([^"]*)"(?:\^\^)([^\s]+)$/);
    if (match) {
      return new Literal(match[1]);
    }
    throw new Error(`Cannot parse literal: ${literalStr}`);
  }
  /**
   * Validate parsed graph
   */
  validateGraph(graph) {
    const errors = [];
    for (const triple of graph.toArray()) {
      const subject = triple.getSubject();
      if (!(subject instanceof IRI) && !(subject instanceof BlankNode)) {
        errors.push(`Invalid subject type: ${typeof subject}`);
      }
      const predicate = triple.getPredicate();
      if (!(predicate instanceof IRI)) {
        errors.push(`Invalid predicate type: ${typeof predicate}`);
      }
    }
    return errors;
  }
  /**
   * Extract namespaces from namespace manager
   */
  extractNamespaces(nm) {
    const namespaces = {};
    for (const binding of nm.getAllBindings()) {
      namespaces[binding.prefix] = binding.namespace.toString();
    }
    return namespaces;
  }
};

// src/application/services/RDFValidator.ts
var RDFValidator = class {
  constructor() {
  }
  validateGraph(graph, options = {}) {
    const errors = [];
    const warnings = [];
    const stats = {
      tripleCount: 0,
      duplicateCount: 0,
      invalidIRICount: 0,
      invalidLiteralCount: 0
    };
    try {
      const triples = graph.toArray();
      stats.tripleCount = triples.length;
      const seenTriples = /* @__PURE__ */ new Set();
      for (const triple of triples) {
        const validationErrors = this.validateTriple(triple, options);
        errors.push(...validationErrors.filter((e) => e.type === "error"));
        warnings.push(...validationErrors.filter((e) => e.type === "warning"));
        if (validationErrors.some((e) => e.message.includes("Invalid IRI"))) {
          stats.invalidIRICount++;
        }
        if (validationErrors.some((e) => e.message.includes("Invalid literal"))) {
          stats.invalidLiteralCount++;
        }
        if (options.checkDuplicates) {
          const tripleKey = this.getTripleKey(triple);
          if (seenTriples.has(tripleKey)) {
            stats.duplicateCount++;
            warnings.push({
              type: "warning",
              message: "Duplicate triple detected",
              triple
            });
          } else {
            seenTriples.add(tripleKey);
          }
        }
      }
      const result = {
        isValid: errors.length === 0,
        errors,
        warnings,
        stats
      };
      return Result.ok(result);
    } catch (error) {
      return Result.fail(`Validation failed: ${error.message}`);
    }
  }
  validateTriple(triple, options = {}) {
    const errors = [];
    const subject = triple.getSubject();
    const predicate = triple.getPredicate();
    const object = triple.getObject();
    if (!subject || !predicate || !object) {
      errors.push({
        type: "error",
        message: "Triple is missing required components",
        triple
      });
      return errors;
    }
    if (subject instanceof IRI) {
      const iriErrors = this.validateIRI(subject.toString());
      if (iriErrors.length > 0) {
        errors.push({
          type: options.strictMode ? "error" : "warning",
          message: `Invalid IRI in subject: ${iriErrors.join(", ")}`,
          triple
        });
      }
    }
    if (predicate instanceof IRI) {
      const iriErrors = this.validateIRI(predicate.toString());
      if (iriErrors.length > 0) {
        errors.push({
          type: "error",
          message: `Invalid IRI in predicate: ${iriErrors.join(", ")}`,
          triple
        });
      }
    }
    if (object instanceof IRI) {
      const iriErrors = this.validateIRI(object.toString());
      if (iriErrors.length > 0) {
        errors.push({
          type: options.strictMode ? "error" : "warning",
          message: `Invalid IRI in object: ${iriErrors.join(", ")}`,
          triple
        });
      }
    }
    if (options.checkLiterals && object instanceof Literal) {
      const literalErrors = this.validateLiteral(object);
      errors.push(...literalErrors);
    }
    return errors;
  }
  validateIRI(iri) {
    const errors = [];
    if (!iri || iri.trim() === "") {
      errors.push("IRI cannot be empty");
      return errors;
    }
    if (!/^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(iri)) {
      errors.push("IRI must start with a valid scheme");
    }
    const invalidChars = /[\s<>"{}|\\^`]/;
    if (invalidChars.test(iri)) {
      errors.push("IRI contains invalid characters");
    }
    if (iri.length > 2048) {
      errors.push("IRI exceeds maximum length");
    }
    return errors;
  }
  validateLiteral(literal) {
    const errors = [];
    const datatype = literal.getDatatype();
    const language = literal.getLanguage();
    const value = literal.getValue();
    if (datatype) {
      const datatypeErrors = this.validateIRI(datatype.toString());
      if (datatypeErrors.length > 0) {
        errors.push({
          type: "warning",
          message: `Invalid datatype IRI: ${datatypeErrors.join(", ")}`
        });
      }
      const isValid = this.validateLiteralValue(value, datatype.toString());
      if (!isValid) {
        errors.push({
          type: "warning",
          message: `Literal value does not match declared datatype ${datatype.toString()}`
        });
      }
    }
    if (language) {
      if (!/^[a-z]{2,3}(-[A-Z]{2})?$/.test(language)) {
        errors.push({
          type: "warning",
          message: `Invalid language tag: ${language}`
        });
      }
    }
    return errors;
  }
  validateLiteralValue(value, datatypeIRI) {
    const xsdNamespace = "http://www.w3.org/2001/XMLSchema#";
    if (datatypeIRI === `${xsdNamespace}integer`) {
      return /^-?\d+$/.test(value);
    }
    if (datatypeIRI === `${xsdNamespace}decimal`) {
      return /^-?\d+(\.\d+)?$/.test(value);
    }
    if (datatypeIRI === `${xsdNamespace}boolean`) {
      return value === "true" || value === "false";
    }
    if (datatypeIRI === `${xsdNamespace}dateTime`) {
      return /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(value);
    }
    if (datatypeIRI === `${xsdNamespace}date`) {
      return /^\d{4}-\d{2}-\d{2}$/.test(value);
    }
    return true;
  }
  validateExportOptions(options) {
    if (!options.format) {
      return Result.fail("Export format is required");
    }
    const validFormats = ["turtle", "n-triples", "json-ld", "rdf-xml"];
    if (!validFormats.includes(options.format)) {
      return Result.fail(`Unsupported export format: ${options.format}`);
    }
    if (options.targetFolder && typeof options.targetFolder !== "string") {
      return Result.fail("Target folder must be a string");
    }
    if (options.fileName && typeof options.fileName !== "string") {
      return Result.fail("File name must be a string");
    }
    return Result.ok();
  }
  validateImportOptions(options) {
    if (!options.mergeMode) {
      return Result.fail("Merge mode is required");
    }
    if (options.mergeMode !== "merge" && options.mergeMode !== "replace") {
      return Result.fail(`Invalid merge mode: ${options.mergeMode}`);
    }
    if (options.format) {
      const validFormats = ["turtle", "n-triples", "json-ld", "rdf-xml"];
      if (!validFormats.includes(options.format)) {
        return Result.fail(`Unsupported import format: ${options.format}`);
      }
    }
    return Result.ok();
  }
  getTripleKey(triple) {
    const subject = triple.getSubject();
    const predicate = triple.getPredicate();
    const object = triple.getObject();
    const subjectStr = subject instanceof IRI ? subject.toString() : subject instanceof BlankNode ? `_:${subject.toString()}` : "";
    const predicateStr = predicate.toString();
    const objectStr = object instanceof IRI ? object.toString() : object instanceof BlankNode ? `_:${object.toString()}` : object instanceof Literal ? `"${object.toString()}"` : "";
    return `${subjectStr}|${predicateStr}|${objectStr}`;
  }
};

// src/application/services/RDFFileManager.ts
var import_obsidian = require("obsidian");
var RDFFileManager = class {
  constructor(app) {
    this.app = app;
  }
  async saveToVault(content, filePath) {
    try {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian.TFile) {
        await this.app.vault.modify(file, content);
      } else {
        const folderPath = filePath.substring(0, filePath.lastIndexOf("/"));
        if (folderPath && !this.app.vault.getAbstractFileByPath(folderPath)) {
          await this.app.vault.createFolder(folderPath);
        }
        await this.app.vault.create(filePath, content);
      }
      return Result.ok({
        filePath,
        success: true,
        message: `File saved successfully to ${filePath}`
      });
    } catch (error) {
      return Result.fail(`Failed to save file: ${error.message}`);
    }
  }
  async readFromVault(filePath) {
    try {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!(file instanceof import_obsidian.TFile)) {
        return Result.fail(`File not found: ${filePath}`);
      }
      const content = await this.app.vault.read(file);
      return Result.ok(content);
    } catch (error) {
      return Result.fail(`Failed to read file: ${error.message}`);
    }
  }
  async deleteFromVault(filePath) {
    try {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!(file instanceof import_obsidian.TFile)) {
        return Result.fail(`File not found: ${filePath}`);
      }
      await this.app.vault.delete(file);
      return Result.ok();
    } catch (error) {
      return Result.fail(`Failed to delete file: ${error.message}`);
    }
  }
  generateFileName(baseName, format) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
    const extension = this.getFileExtension(format);
    if (baseName) {
      const nameWithoutExt = baseName.replace(/\.[^/.]+$/, "");
      return `${nameWithoutExt}.${extension}`;
    }
    return `export_${timestamp}.${extension}`;
  }
  getFileExtension(format) {
    const extensions = {
      "turtle": "ttl",
      "n-triples": "nt",
      "json-ld": "jsonld",
      "rdf-xml": "rdf"
    };
    return extensions[format] || "rdf";
  }
  detectFormatFromExtension(filePath) {
    var _a;
    const extension = (_a = filePath.split(".").pop()) == null ? void 0 : _a.toLowerCase();
    const formatMap = {
      "ttl": "turtle",
      "turtle": "turtle",
      "nt": "n-triples",
      "ntriples": "n-triples",
      "jsonld": "json-ld",
      "json": "json-ld",
      "rdf": "rdf-xml",
      "xml": "rdf-xml"
    };
    return extension ? formatMap[extension] : void 0;
  }
  async listRDFFiles(folder) {
    try {
      const files = this.app.vault.getFiles();
      const rdfExtensions = ["ttl", "nt", "jsonld", "rdf", "xml"];
      const rdfFiles = files.filter((file) => {
        const extension = file.extension.toLowerCase();
        const inCorrectFolder = !folder || file.path.startsWith(folder);
        return rdfExtensions.includes(extension) && inCorrectFolder;
      });
      return Result.ok(rdfFiles);
    } catch (error) {
      return Result.fail(`Failed to list RDF files: ${error.message}`);
    }
  }
  async ensureFolderExists(folderPath) {
    try {
      if (!this.app.vault.getAbstractFileByPath(folderPath)) {
        await this.app.vault.createFolder(folderPath);
      }
      return Result.ok();
    } catch (error) {
      return Result.fail(`Failed to create folder: ${error.message}`);
    }
  }
  getFileInfo(file) {
    return {
      size: file.stat.size,
      modified: new Date(file.stat.mtime),
      created: new Date(file.stat.ctime)
    };
  }
};

// src/application/services/RDFService.ts
var RDFService = class {
  constructor(app, namespaceManager) {
    this.app = app;
    this.namespaceManager = namespaceManager || new NamespaceManager();
    this.serializer = new RDFSerializer(this.namespaceManager);
    this.parser = new RDFParser(this.namespaceManager);
    this.validator = new RDFValidator();
    this.fileManager = new RDFFileManager(app);
  }
  /**
   * Export graph to RDF format
   */
  async exportGraph(graph, options) {
    var _a, _b;
    try {
      const validationResult = this.validator.validateExportOptions(options);
      if (validationResult.isFailure) {
        return Result.fail(validationResult.errorValue());
      }
      const serializationOptions = {
        format: options.format,
        includeComments: (_a = options.includeComments) != null ? _a : true,
        prettyPrint: (_b = options.prettyPrint) != null ? _b : true,
        baseIRI: options.baseIRI,
        namespaceManager: this.namespaceManager
      };
      const result = this.serializer.serialize(graph, serializationOptions);
      if (result.isFailure) {
        return result;
      }
      const serializedData = result.getValue();
      if (options.saveToVault) {
        const fileName = this.fileManager.generateFileName(options.fileName, options.format);
        const filePath = options.targetFolder ? `${options.targetFolder}/${fileName}` : fileName;
        const saveResult = await this.fileManager.saveToVault(serializedData.content, filePath);
        if (saveResult.isFailure) {
          return Result.fail(saveResult.errorValue());
        }
        new import_obsidian2.Notice(`Exported ${serializedData.tripleCount} triples to ${filePath}`);
      }
      return result;
    } catch (error) {
      return Result.fail(`Export failed: ${error.message}`);
    }
  }
  /**
   * Import RDF data and merge with existing graph
   */
  async importRDF(content, graph, options) {
    var _a, _b;
    try {
      const validationResult = this.validator.validateImportOptions(options);
      if (validationResult.isFailure) {
        return Result.fail(validationResult.errorValue());
      }
      const parseOptions = {
        format: options.format,
        baseIRI: options.baseIRI,
        namespaceManager: this.namespaceManager,
        validateInput: (_a = options.validateInput) != null ? _a : true,
        strictMode: (_b = options.strictMode) != null ? _b : false
      };
      const parseResult = this.parser.parse(content, parseOptions);
      if (parseResult.isFailure) {
        return Result.fail(`Import parsing failed: ${parseResult.errorValue()}`);
      }
      const imported = parseResult.getValue();
      if (options.validateInput) {
        const validationOptions = {
          strictMode: options.strictMode,
          checkDuplicates: true,
          checkNamespaces: true,
          checkLiterals: true
        };
        const graphValidation = this.validator.validateGraph(imported.graph, validationOptions);
        if (graphValidation.isFailure) {
          return Result.fail(graphValidation.errorValue());
        }
        const validation = graphValidation.getValue();
        if (!validation.isValid && options.strictMode) {
          const errorMessages = validation.errors.map((e) => e.message).join("; ");
          return Result.fail(`Import validation failed: ${errorMessages}`);
        }
        if (validation.warnings.length > 0) {
          new import_obsidian2.Notice(`Import completed with ${validation.warnings.length} warnings`);
        }
      }
      let finalGraph;
      if (options.mergeMode === "replace") {
        finalGraph = imported.graph;
      } else {
        finalGraph = graph.clone();
        finalGraph.merge(imported.graph);
      }
      for (const [prefix, namespace] of Object.entries(imported.namespaces)) {
        if (!this.namespaceManager.hasPrefix(prefix)) {
          this.namespaceManager.addBinding(prefix, namespace);
        }
      }
      return Result.ok({ graph: finalGraph, imported });
    } catch (error) {
      return Result.fail(`Import failed: ${error.message}`);
    }
  }
  /**
   * Import RDF from vault file
   */
  async importFromVaultFile(file, graph, options) {
    try {
      const contentResult = await this.fileManager.readFromVault(file.path);
      if (contentResult.isFailure) {
        return Result.fail(contentResult.errorValue());
      }
      if (!options.format) {
        options.format = this.fileManager.detectFormatFromExtension(file.name);
      }
      return await this.importRDF(contentResult.getValue(), graph, options);
    } catch (error) {
      return Result.fail(`Failed to import from vault file: ${error.message}`);
    }
  }
  /**
   * Export SPARQL query results
   */
  async exportQueryResults(results, format, fileName, saveToVault = true) {
    try {
      const graph = this.convertQueryResultsToGraph(results);
      const options = {
        format,
        fileName: fileName || "sparql-results",
        saveToVault,
        includeComments: true,
        prettyPrint: true,
        targetFolder: "exports"
      };
      return await this.exportGraph(graph, options);
    } catch (error) {
      return Result.fail(`Query results export failed: ${error.message}`);
    }
  }
  /**
   * Validate a graph
   */
  async validateGraph(graph, options) {
    return this.validator.validateGraph(graph, options);
  }
  /**
   * List RDF files in vault
   */
  async listRDFFiles(folder) {
    return this.fileManager.listRDFFiles(folder);
  }
  /**
   * Convert SPARQL query results to graph
   */
  convertQueryResultsToGraph(results) {
    const graph = new Graph();
    for (const result of results) {
      if (result.subject && result.predicate && result.object) {
        try {
          const subject = this.createNodeFromValue(result.subject);
          const predicate = this.createNodeFromValue(result.predicate);
          const object = this.createNodeFromValue(result.object);
          if (subject && predicate && object) {
            const triple = new Triple(subject, predicate, object);
            graph.add(triple);
          }
        } catch (error) {
          console.warn("Failed to convert query result to triple:", error);
        }
      }
    }
    return graph;
  }
  /**
   * Create RDF node from query result value
   */
  createNodeFromValue(value) {
    if (typeof value === "string") {
      if (value.startsWith("_:")) {
        return new BlankNode(value);
      } else if (value.startsWith("http://") || value.startsWith("https://") || value.includes(":")) {
        try {
          return new IRI(value);
        } catch (e) {
          return Literal.string(value);
        }
      } else {
        return Literal.string(value);
      }
    } else if (typeof value === "number") {
      return Number.isInteger(value) ? Literal.integer(value) : Literal.double(value);
    } else if (typeof value === "boolean") {
      return Literal.boolean(value);
    } else if (value && typeof value === "object") {
      if (value.type === "uri" || value.type === "iri") {
        return new IRI(value.value);
      } else if (value.type === "bnode") {
        return new BlankNode(value.value);
      } else if (value.type === "literal") {
        if (value.datatype) {
          return new Literal(value.value, new IRI(value.datatype));
        } else if (value.lang) {
          return new Literal(value.value, void 0, value.lang);
        } else {
          return new Literal(value.value);
        }
      }
    }
    return null;
  }
  /**
   * Get namespace manager instance
   */
  getNamespaceManager() {
    return this.namespaceManager;
  }
  /**
   * Get supported export formats
   */
  getSupportedFormats() {
    return ["turtle", "n-triples", "json-ld", "rdf-xml"];
  }
  /**
   * Get format information
   */
  getFormatInfo(format) {
    const formatMap = {
      "turtle": { extension: ".ttl", mimeType: "text/turtle", name: "Turtle" },
      "n-triples": { extension: ".nt", mimeType: "application/n-triples", name: "N-Triples" },
      "json-ld": { extension: ".jsonld", mimeType: "application/ld+json", name: "JSON-LD" },
      "rdf-xml": { extension: ".rdf", mimeType: "application/rdf+xml", name: "RDF/XML" }
    };
    return formatMap[format];
  }
};

// src/presentation/modals/ExportRDFModal.ts
var import_obsidian3 = require("obsidian");
var ExportRDFModal = class extends import_obsidian3.Modal {
  constructor(app, graph, namespaceManager, onExport) {
    super(app);
    this.options = {
      format: "turtle",
      includeComments: true,
      prettyPrint: true,
      saveToVault: true,
      fileName: "knowledge-graph"
    };
    this.graph = graph;
    this.namespaceManager = namespaceManager || new NamespaceManager();
    this.serializer = new RDFSerializer(this.namespaceManager);
    this.onExport = onExport;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Export Knowledge Graph" });
    const statsEl = contentEl.createDiv("export-stats");
    statsEl.innerHTML = `
            <div class="stat-item">
                <span class="stat-label">Triples:</span>
                <span class="stat-value">${this.graph.size()}</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Subjects:</span>
                <span class="stat-value">${this.graph.subjects().size}</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Predicates:</span>
                <span class="stat-value">${this.graph.predicates().size}</span>
            </div>
        `;
    new import_obsidian3.Setting(contentEl).setName("Export format").setDesc("Choose the RDF serialization format").addDropdown((dropdown) => {
      dropdown.addOption("turtle", "Turtle (.ttl)").addOption("ntriples", "N-Triples (.nt)").addOption("jsonld", "JSON-LD (.jsonld)").addOption("rdfxml", "RDF/XML (.rdf)").setValue(this.options.format).onChange((value) => {
        this.options.format = value;
        this.updateFileName();
        this.updatePreview();
      });
    });
    new import_obsidian3.Setting(contentEl).setName("File name").setDesc("Name for the exported file (without extension)").addText((text) => {
      text.setPlaceholder("knowledge-graph").setValue(this.options.fileName || "").onChange((value) => {
        this.options.fileName = value || "knowledge-graph";
      });
    });
    new import_obsidian3.Setting(contentEl).setName("Base IRI").setDesc("Optional base IRI for relative URIs").addText((text) => {
      text.setPlaceholder("https://example.org/data/").setValue(this.options.baseIRI || "").onChange((value) => {
        this.options.baseIRI = value || void 0;
        this.updatePreview();
      });
    });
    new import_obsidian3.Setting(contentEl).setName("Include comments").setDesc("Add comments with metadata and statistics").addToggle((toggle) => {
      toggle.setValue(this.options.includeComments).onChange((value) => {
        this.options.includeComments = value;
        this.updatePreview();
      });
    });
    new import_obsidian3.Setting(contentEl).setName("Pretty print").setDesc("Format output for readability (larger file size)").addToggle((toggle) => {
      toggle.setValue(this.options.prettyPrint).onChange((value) => {
        this.options.prettyPrint = value;
        this.updatePreview();
      });
    });
    new import_obsidian3.Setting(contentEl).setName("Save to vault").setDesc("Save file to vault, or download to computer").addToggle((toggle) => {
      toggle.setValue(this.options.saveToVault).onChange((value) => {
        this.options.saveToVault = value;
      });
    });
    const previewContainer = contentEl.createDiv("export-preview");
    previewContainer.createEl("h3", { text: "Preview" });
    const previewEl = previewContainer.createEl("pre");
    previewEl.addClass("export-preview-content");
    const buttonContainer = contentEl.createDiv("export-buttons");
    buttonContainer.addClass("modal-button-container");
    const exportButton = buttonContainer.createEl("button", {
      text: "Export",
      cls: "mod-cta"
    });
    exportButton.onclick = () => this.handleExport();
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.onclick = () => this.close();
    this.updatePreview();
    this.addStyles();
  }
  /**
   * Update file name based on format
   */
  updateFileName() {
    if (this.options.fileName && !this.options.fileName.includes(".")) {
    }
  }
  /**
   * Update preview content
   */
  updatePreview() {
    const previewEl = this.contentEl.querySelector(".export-preview-content");
    if (!previewEl)
      return;
    try {
      const sampleGraph = this.createSampleGraph();
      const serializationOptions = {
        format: this.options.format,
        includeComments: this.options.includeComments,
        prettyPrint: this.options.prettyPrint,
        baseIRI: this.options.baseIRI,
        namespaceManager: this.namespaceManager
      };
      const result = this.serializer.serialize(sampleGraph, serializationOptions);
      if (result.isSuccess) {
        const content = result.getValue().content;
        const lines = content.split("\n");
        const preview = lines.slice(0, 10).join("\n");
        previewEl.textContent = preview + (lines.length > 10 ? "\n... (truncated)" : "");
      } else {
        previewEl.textContent = `Preview error: ${result.errorValue()}`;
      }
    } catch (error) {
      previewEl.textContent = `Preview error: ${error.message}`;
    }
  }
  /**
   * Create a small sample graph for preview
   */
  createSampleGraph() {
    const sampleTriples = this.graph.toArray().slice(0, 5);
    return new Graph(sampleTriples);
  }
  /**
   * Handle export action
   */
  async handleExport() {
    var _a, _b;
    try {
      const serializationOptions = {
        format: this.options.format,
        includeComments: this.options.includeComments,
        prettyPrint: this.options.prettyPrint,
        baseIRI: this.options.baseIRI,
        namespaceManager: this.namespaceManager
      };
      const result = this.serializer.serialize(this.graph, serializationOptions);
      if (result.isFailure) {
        new import_obsidian3.Notice(`Export failed: ${result.errorValue()}`);
        return;
      }
      const serializedData = result.getValue();
      const extension = RDFSerializer.getFileExtension(this.options.format);
      const fileName = `${this.options.fileName || "knowledge-graph"}${extension}`;
      if (this.options.saveToVault) {
        await this.saveToVault(serializedData.content, fileName);
      } else {
        this.downloadFile(serializedData.content, fileName);
      }
      if (this.onExport) {
        this.onExport({
          content: serializedData.content,
          fileName,
          format: this.options.format
        });
      }
      const message = this.options.saveToVault ? `Exported ${serializedData.tripleCount} triples to ${fileName}` : `Downloaded ${serializedData.tripleCount} triples as ${fileName}`;
      new import_obsidian3.Notice(message);
      if ((_b = (_a = serializedData.metadata) == null ? void 0 : _a.warnings) == null ? void 0 : _b.length) {
        new import_obsidian3.Notice(`Warnings: ${serializedData.metadata.warnings.join("; ")}`, 5e3);
      }
      this.close();
    } catch (error) {
      new import_obsidian3.Notice(`Export error: ${error.message}`);
    }
  }
  /**
   * Save content to vault
   */
  async saveToVault(content, fileName) {
    const filePath = `exports/${fileName}`;
    try {
      const folder = this.app.vault.getAbstractFileByPath("exports");
      if (!folder) {
        await this.app.vault.createFolder("exports");
      }
      const existingFile = this.app.vault.getAbstractFileByPath(filePath);
      if (existingFile instanceof import_obsidian3.TFile) {
        await this.app.vault.modify(existingFile, content);
      } else {
        await this.app.vault.create(filePath, content);
      }
    } catch (error) {
      throw new Error(`Failed to save to vault: ${error.message}`);
    }
  }
  /**
   * Download file to computer
   */
  downloadFile(content, fileName) {
    const blob = new Blob([content], {
      type: RDFSerializer.getMimeType(this.options.format)
    });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = fileName;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }
  /**
   * Add custom styles
   */
  addStyles() {
    const style = document.createElement("style");
    style.textContent = `
            .export-stats {
                display: flex;
                gap: 20px;
                margin-bottom: 20px;
                padding: 10px;
                background: var(--background-secondary);
                border-radius: 6px;
            }
            
            .stat-item {
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            
            .stat-label {
                font-size: 12px;
                color: var(--text-muted);
                margin-bottom: 2px;
            }
            
            .stat-value {
                font-size: 18px;
                font-weight: 600;
                color: var(--text-normal);
            }
            
            .export-preview {
                margin: 20px 0;
            }
            
            .export-preview-content {
                max-height: 200px;
                overflow-y: auto;
                background: var(--background-secondary);
                padding: 10px;
                border-radius: 4px;
                font-family: var(--font-monospace);
                font-size: 12px;
                white-space: pre-wrap;
                margin: 0;
            }
            
            .export-buttons {
                display: flex;
                gap: 10px;
                justify-content: flex-end;
                margin-top: 20px;
                padding-top: 20px;
                border-top: 1px solid var(--background-modifier-border);
            }
            
            .modal-button-container button {
                padding: 8px 16px;
                border-radius: 4px;
                border: 1px solid var(--background-modifier-border);
                background: var(--background-primary);
                color: var(--text-normal);
                cursor: pointer;
            }
            
            .modal-button-container button:hover {
                background: var(--background-secondary);
            }
            
            .modal-button-container button.mod-cta {
                background: var(--interactive-accent);
                color: var(--text-on-accent);
                border-color: var(--interactive-accent);
            }
            
            .modal-button-container button.mod-cta:hover {
                background: var(--interactive-accent-hover);
                border-color: var(--interactive-accent-hover);
            }
        `;
    document.head.appendChild(style);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/application/services/SPARQLSanitizer.ts
var SPARQLSanitizer = class {
  constructor() {
    // Dangerous patterns that could lead to security issues
    this.dangerousPatterns = [
      // File system access attempts
      /FILE:/gi,
      /LOAD\s+<file:/gi,
      // Command injection patterns
      /;\s*DELETE/gi,
      /;\s*DROP/gi,
      /;\s*INSERT/gi,
      /;\s*CLEAR/gi,
      // Path traversal
      /\.\.[\/\\]/g,
      // Null byte injection
      /\x00/g,
      // Script injection
      /<script/gi,
      /javascript:/gi,
      /on\w+\s*=/gi
    ];
    // Allowed SPARQL keywords
    this.allowedKeywords = /* @__PURE__ */ new Set([
      "SELECT",
      "CONSTRUCT",
      "WHERE",
      "FILTER",
      "OPTIONAL",
      "UNION",
      "PREFIX",
      "BASE",
      "DISTINCT",
      "REDUCED",
      "ORDER",
      "BY",
      "ASC",
      "DESC",
      "LIMIT",
      "OFFSET",
      "GRAPH",
      "BIND",
      "VALUES",
      "GROUP",
      "HAVING",
      "SERVICE",
      "MINUS",
      "EXISTS",
      "NOT",
      "IN",
      "AS"
    ]);
  }
  /**
   * Sanitize SPARQL query for safe execution
   */
  sanitize(query) {
    if (!query || query.trim().length === 0) {
      return Result.fail("Empty query provided");
    }
    const warnings = [];
    let sanitized = query;
    let modified = false;
    for (const pattern of this.dangerousPatterns) {
      if (pattern.test(sanitized)) {
        warnings.push(`Dangerous pattern detected and removed: ${pattern.source}`);
        sanitized = sanitized.replace(pattern, "");
        modified = true;
      }
    }
    const validation = this.validateQueryStructure(sanitized);
    if (validation.warnings.length > 0) {
      warnings.push(...validation.warnings);
    }
    if (this.hasMultipleStatements(sanitized)) {
      warnings.push("Multiple statements detected - only first will be executed");
      sanitized = this.extractFirstStatement(sanitized);
      modified = true;
    }
    const iriValidation = this.validateIRIs(sanitized);
    if (iriValidation.warnings.length > 0) {
      warnings.push(...iriValidation.warnings);
    }
    const complexity = this.checkComplexity(sanitized);
    if (complexity.tooComplex) {
      return Result.fail(`Query too complex: ${complexity.reason}`);
    }
    return Result.ok({
      query: sanitized,
      modified,
      warnings
    });
  }
  /**
   * Validate query structure
   */
  validateQueryStructure(query) {
    const warnings = [];
    const upperQuery = query.toUpperCase();
    if (!upperQuery.includes("SELECT") && !upperQuery.includes("CONSTRUCT")) {
      warnings.push("Query must be SELECT or CONSTRUCT");
    }
    const openBrackets = (query.match(/\{/g) || []).length;
    const closeBrackets = (query.match(/\}/g) || []).length;
    if (openBrackets !== closeBrackets) {
      warnings.push("Unbalanced brackets detected");
    }
    const openParens = (query.match(/\(/g) || []).length;
    const closeParens = (query.match(/\)/g) || []).length;
    if (openParens !== closeParens) {
      warnings.push("Unbalanced parentheses detected");
    }
    return {
      valid: warnings.length === 0,
      warnings
    };
  }
  /**
   * Check if query contains multiple statements
   */
  hasMultipleStatements(query) {
    const queryKeywords = ["SELECT", "CONSTRUCT", "INSERT", "DELETE", "DROP"];
    let count = 0;
    for (const keyword of queryKeywords) {
      const regex = new RegExp(`\\b${keyword}\\b`, "gi");
      const matches = query.match(regex);
      if (matches) {
        count += matches.length;
      }
    }
    return count > 1;
  }
  /**
   * Extract first statement from query
   */
  extractFirstStatement(query) {
    let depth = 0;
    let inString = false;
    let stringChar = "";
    for (let i = 0; i < query.length; i++) {
      const char = query[i];
      if ((char === '"' || char === "'") && query[i - 1] !== "\\") {
        if (!inString) {
          inString = true;
          stringChar = char;
        } else if (char === stringChar) {
          inString = false;
        }
      }
      if (!inString) {
        if (char === "{")
          depth++;
        if (char === "}")
          depth--;
        if (depth === 0 && i > 0) {
          const remaining = query.substring(i + 1);
          if (/^\s*(SELECT|CONSTRUCT|INSERT|DELETE)/i.test(remaining)) {
            return query.substring(0, i + 1);
          }
        }
      }
    }
    return query;
  }
  /**
   * Validate IRI patterns in query
   */
  validateIRIs(query) {
    const warnings = [];
    const iriPattern = /<([^>]+)>/g;
    let match;
    while ((match = iriPattern.exec(query)) !== null) {
      const iri = match[1];
      if (iri.includes("..") || iri.includes("\\")) {
        warnings.push(`Suspicious IRI detected: ${iri}`);
      }
      if (iri.startsWith("file:")) {
        warnings.push(`File URI not allowed: ${iri}`);
      }
      if (iri.length > 2048) {
        warnings.push(`IRI too long: ${iri.substring(0, 50)}...`);
      }
    }
    return {
      valid: warnings.length === 0,
      warnings
    };
  }
  /**
   * Check query complexity to prevent DoS
   */
  checkComplexity(query) {
    if (query.length > 1e4) {
      return { tooComplex: true, reason: "Query exceeds maximum length" };
    }
    const triplePatterns = (query.match(/\.\s*\?/g) || []).length;
    if (triplePatterns > 100) {
      return { tooComplex: true, reason: "Too many triple patterns" };
    }
    const unions = (query.match(/\bUNION\b/gi) || []).length;
    if (unions > 10) {
      return { tooComplex: true, reason: "Too many UNION operations" };
    }
    const subqueries = (query.match(/\{[^}]*SELECT/gi) || []).length;
    if (subqueries > 5) {
      return { tooComplex: true, reason: "Too many nested subqueries" };
    }
    const filters = (query.match(/\bFILTER\b/gi) || []).length;
    if (filters > 20) {
      return { tooComplex: true, reason: "Too many FILTER operations" };
    }
    return { tooComplex: false };
  }
  /**
   * Escape special characters in literals
   */
  escapeStringLiteral(value) {
    return value.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/'/g, "\\'").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
  }
  /**
   * Create safe IRI from user input
   */
  createSafeIRI(input) {
    const safe = input.replace(/[<>'"`;]/g, "").replace(/\s+/g, "_").replace(/[^\w:/-]/g, "");
    if (!safe.includes(":")) {
      return `ex:${safe}`;
    }
    return safe;
  }
};

// src/presentation/processors/SPARQLProcessor.ts
var SPARQLProcessor = class {
  constructor(plugin, graph, focusService, cacheConfig) {
    this.plugin = plugin;
    this.graph = graph;
    this.engine = new SPARQLEngine(graph, cacheConfig);
    this.focusService = focusService;
    this.rdfService = new RDFService(plugin.app);
    this.sanitizer = new SPARQLSanitizer();
  }
  /**
   * Main processor method called by Obsidian
   */
  async processCodeBlock(source, el, ctx) {
    el.empty();
    const container = document.createElement("div");
    container.className = "exocortex-sparql-container";
    container.style.cssText = "border: 1px solid #e0e0e0; padding: 1em; margin: 1em 0; border-radius: 4px; background: #fafafa;";
    el.appendChild(container);
    try {
      const loadingEl = this.createLoadingIndicator();
      container.appendChild(loadingEl);
      const startTime = Date.now();
      const result = await this.executeQuery(source.trim());
      const executionTime = Date.now() - startTime;
      loadingEl.remove();
      const title = document.createElement("h3");
      title.textContent = "SPARQL Query Results";
      title.style.cssText = "margin-top: 0; color: #333;";
      container.appendChild(title);
      const queryPre = document.createElement("pre");
      queryPre.textContent = source.trim();
      queryPre.style.cssText = "background: #f5f5f5; padding: 0.5em; border-radius: 3px; font-size: 0.9em; overflow-x: auto;";
      container.appendChild(queryPre);
      if (result.cached) {
        const cacheIndicator = this.createCacheIndicator(result.cached);
        container.appendChild(cacheIndicator);
      }
      if (!result.results || result.results.length === 0) {
        const emptyMessage = document.createElement("div");
        emptyMessage.className = "sparql-empty-result";
        emptyMessage.textContent = "No results found";
        emptyMessage.style.cssText = "padding: 1em; text-align: center; color: #666;";
        container.appendChild(emptyMessage);
      } else {
        const table = this.createResultTable(result.results);
        container.appendChild(table);
        const exportControls = this.createExportControls(result.results, source.trim());
        container.appendChild(exportControls);
        const stats = this.createStatsElement(result.results.length, executionTime, result.cached);
        container.appendChild(stats);
      }
    } catch (error) {
      container.innerHTML = "";
      const errorEl = this.createErrorMessage(error);
      container.appendChild(errorEl);
      console.error("SPARQL execution error:", error);
    }
  }
  async executeQuery(sparql) {
    if (!sparql || sparql.trim().length === 0) {
      throw new Error("Empty query");
    }
    const sanitizationResult = this.sanitizer.sanitize(sparql);
    if (sanitizationResult.isFailure) {
      throw new Error(`Query validation failed: ${sanitizationResult.errorValue()}`);
    }
    const sanitized = sanitizationResult.getValue();
    if (sanitized.warnings.length > 0) {
      console.warn("SPARQL query warnings:", sanitized.warnings);
      new import_obsidian4.Notice(`Query executed with warnings: ${sanitized.warnings[0]}`);
    }
    const safeQuery = sanitized.query;
    const upperQuery = safeQuery.toUpperCase();
    if (upperQuery.includes("CONSTRUCT")) {
      const result = this.engine.construct(safeQuery);
      if (!result.cached) {
        for (const triple of result.triples) {
          this.graph.add(triple);
        }
      }
      const cacheInfo = result.cached ? " (cached)" : "";
      new import_obsidian4.Notice(`Generated ${result.triples.length} new triples${cacheInfo}`);
      return {
        results: result.triples.map((t) => ({
          subject: t.getSubject().toString(),
          predicate: t.getPredicate().toString(),
          object: t.getObject().toString(),
          provenance: result.provenance
        })),
        cached: result.cached
      };
    } else if (upperQuery.includes("SELECT")) {
      const selectResult = this.engine.select(safeQuery);
      let results = selectResult.results;
      if (this.focusService) {
        results = this.focusService.filterSPARQLResults(results);
      }
      return {
        results,
        cached: selectResult.cached
      };
    } else {
      throw new Error("Only SELECT and CONSTRUCT queries are currently supported");
    }
  }
  createResultTable(results) {
    const table = document.createElement("table");
    table.className = "sparql-results-table";
    if (results.length === 0) {
      return table;
    }
    const columns = Object.keys(results[0]);
    const thead = table.createTHead();
    const headerRow = thead.insertRow();
    for (const column of columns) {
      const th = document.createElement("th");
      th.textContent = column;
      headerRow.appendChild(th);
    }
    const tbody = table.createTBody();
    for (const row of results) {
      const tr = tbody.insertRow();
      for (const column of columns) {
        const td = tr.insertCell();
        const value = row[column];
        if (this.isNoteLink(value)) {
          const link = this.createNoteLink(value);
          td.appendChild(link);
        } else {
          td.textContent = value || "";
        }
      }
    }
    return table;
  }
  isNoteLink(value) {
    if (typeof value !== "string")
      return false;
    return value.startsWith("file://") || value.includes("/");
  }
  createNoteLink(uri) {
    const link = document.createElement("a");
    link.className = "internal-link";
    const noteName = uri.replace("file://", "").split("/").pop() || uri;
    link.textContent = noteName;
    link.addEventListener("click", (e) => {
      e.preventDefault();
      this.plugin.app.workspace.openLinkText(noteName, "");
    });
    return link;
  }
  createLoadingIndicator() {
    const loading = document.createElement("div");
    loading.className = "sparql-loading";
    loading.textContent = "Executing query...";
    return loading;
  }
  createErrorMessage(error) {
    const errorDiv = document.createElement("div");
    errorDiv.className = "sparql-error";
    errorDiv.style.cssText = "background: #ffebee; color: #c62828; padding: 1em; border-radius: 4px; border: 1px solid #ef5350;";
    const title = document.createElement("strong");
    title.textContent = "Query Error: ";
    errorDiv.appendChild(title);
    const message = document.createElement("span");
    message.textContent = error.message;
    errorDiv.appendChild(message);
    return errorDiv;
  }
  createStatsElement(count, time, cached) {
    const stats = document.createElement("div");
    stats.className = "sparql-stats";
    const cacheInfo = cached ? " (cached result)" : "";
    stats.textContent = `Executed in ${time}ms - ${count} results${cacheInfo}`;
    stats.style.cssText = "margin-top: 0.5em; color: #666; font-size: 0.9em;";
    return stats;
  }
  createCacheIndicator(cached) {
    const indicator = document.createElement("div");
    indicator.className = "sparql-cache-indicator";
    if (cached) {
      indicator.textContent = "\u{1F4CB} Cached Result";
      indicator.style.cssText = "background: #e8f5e8; color: #2e7d32; padding: 0.4em 0.8em; border-radius: 15px; font-size: 0.8em; display: inline-block; margin-bottom: 0.5em; border: 1px solid #c8e6c9;";
    } else {
      indicator.textContent = "\u{1F504} Fresh Result";
      indicator.style.cssText = "background: #e3f2fd; color: #1565c0; padding: 0.4em 0.8em; border-radius: 15px; font-size: 0.8em; display: inline-block; margin-bottom: 0.5em; border: 1px solid #bbdefb;";
    }
    return indicator;
  }
  /**
   * Get cache statistics for display
   */
  getCacheStatistics() {
    return this.engine.getCacheStatistics();
  }
  /**
   * Invalidate all cached queries
   */
  invalidateCache() {
    this.engine.invalidateCache();
  }
  /**
   * Cleanup expired cache entries
   */
  cleanupCache() {
    return this.engine.cleanupCache();
  }
  /**
   * Destroy cache and cleanup resources
   */
  destroy() {
    this.engine.destroy();
  }
  /**
   * Create export controls for SPARQL results
   */
  createExportControls(results, query) {
    const exportContainer = document.createElement("div");
    exportContainer.className = "sparql-export-controls";
    exportContainer.style.cssText = "margin: 1em 0; padding: 0.8em; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px;";
    const label = document.createElement("span");
    label.textContent = "Export results: ";
    label.style.cssText = "margin-right: 0.5em; font-weight: 500;";
    exportContainer.appendChild(label);
    const formats = [
      { format: "turtle", label: "Turtle" },
      { format: "json-ld", label: "JSON-LD" },
      { format: "n-triples", label: "N-Triples" },
      { format: "rdf-xml", label: "RDF/XML" }
    ];
    for (const { format, label: label2 } of formats) {
      const button = document.createElement("button");
      button.textContent = label2;
      button.className = "sparql-export-button";
      button.style.cssText = "margin: 0 0.3em; padding: 0.4em 0.8em; background: #007acc; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 0.85em;";
      button.addEventListener("mouseenter", () => {
        button.style.background = "#005a9e";
      });
      button.addEventListener("mouseleave", () => {
        button.style.background = "#007acc";
      });
      button.addEventListener("click", async (e) => {
        e.preventDefault();
        await this.exportQueryResults(results, format, query);
      });
      exportContainer.appendChild(button);
    }
    const advancedButton = document.createElement("button");
    advancedButton.textContent = "Advanced...";
    advancedButton.className = "sparql-export-advanced";
    advancedButton.style.cssText = "margin-left: 1em; padding: 0.4em 0.8em; background: #6c757d; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 0.85em;";
    advancedButton.addEventListener("mouseenter", () => {
      advancedButton.style.background = "#545b62";
    });
    advancedButton.addEventListener("mouseleave", () => {
      advancedButton.style.background = "#6c757d";
    });
    advancedButton.addEventListener("click", (e) => {
      e.preventDefault();
      this.openAdvancedExportModal(results, query);
    });
    exportContainer.appendChild(advancedButton);
    return exportContainer;
  }
  /**
   * Export query results in specified format
   */
  async exportQueryResults(results, format, query) {
    try {
      const fileName = `sparql-results-${Date.now()}`;
      const result = await this.rdfService.exportQueryResults(results, format, fileName);
      if (result.isSuccess) {
        const exportData = result.getValue();
        new import_obsidian4.Notice(`Exported ${exportData.tripleCount} triples as ${format.toUpperCase()}`);
      } else {
        new import_obsidian4.Notice(`Export failed: ${result.errorValue()}`);
      }
    } catch (error) {
      new import_obsidian4.Notice(`Export error: ${error.message}`);
      console.error("SPARQL export error:", error);
    }
  }
  /**
   * Open advanced export modal for query results
   */
  openAdvancedExportModal(results, query) {
    try {
      const resultsGraph = this.rdfService["convertQueryResultsToGraph"](results);
      const modal = new ExportRDFModal(
        this.plugin.app,
        resultsGraph,
        this.rdfService.getNamespaceManager(),
        (result) => {
          const timestamp = new Date().toISOString();
          const metadata = `

# Query executed at ${timestamp}
# ${query.replace(/\n/g, "\n# ")}
`;
          new import_obsidian4.Notice(`Advanced export completed: ${result.fileName}`);
        }
      );
      modal.open();
    } catch (error) {
      new import_obsidian4.Notice(`Failed to open export modal: ${error.message}`);
      console.error("Export modal error:", error);
    }
  }
};

// src/presentation/processors/GraphVisualizationProcessor.ts
var import_obsidian5 = require("obsidian");
var GraphVisualizationProcessor = class {
  constructor(plugin, graph) {
    this.plugin = plugin;
    this.graph = graph;
    this.engine = new SPARQLEngine(graph);
    this.rdfService = new RDFService(plugin.app);
  }
  /**
   * Main processor method called by Obsidian
   */
  async processCodeBlock(source, el, ctx) {
    el.empty();
    const container = document.createElement("div");
    container.className = "exocortex-graph-container";
    container.style.cssText = `
            border: 1px solid var(--background-modifier-border);
            padding: 1em;
            margin: 1em 0;
            border-radius: var(--radius-m);
            background: var(--background-secondary);
            position: relative;
        `;
    el.appendChild(container);
    try {
      const config = this.parseConfig(source.trim());
      const loadingEl = this.createLoadingIndicator();
      container.appendChild(loadingEl);
      const graphData = await this.getGraphData(config);
      loadingEl.remove();
      if (graphData.nodes.length === 0) {
        const emptyMessage = document.createElement("div");
        emptyMessage.textContent = "No graph data found";
        emptyMessage.style.cssText = "padding: 2em; text-align: center; color: var(--text-muted);";
        container.appendChild(emptyMessage);
        return;
      }
      await this.createGraphVisualization(container, graphData, config);
      this.addControls(container, graphData, config);
    } catch (error) {
      container.innerHTML = "";
      const errorEl = this.createErrorMessage(error);
      container.appendChild(errorEl);
      console.error("Graph visualization error:", error);
    }
  }
  parseConfig(source) {
    const config = {
      limit: 100,
      showLabels: true,
      nodeSize: 8,
      linkDistance: 80,
      depth: 2
    };
    const lines = source.split("\n").map((l) => l.trim()).filter((l) => l);
    if (source.toUpperCase().includes("SELECT")) {
      config.query = source;
      return config;
    }
    for (const line of lines) {
      if (line.includes(":")) {
        const [key, value] = line.split(":").map((s) => s.trim());
        switch (key.toLowerCase()) {
          case "focus":
            config.focus = value.replace(/\[\[|\]\]/g, "");
            break;
          case "depth":
            config.depth = parseInt(value) || 2;
            break;
          case "limit":
            config.limit = parseInt(value) || 100;
            break;
          case "query":
            config.query = value;
            break;
          case "showlabels":
            config.showLabels = value.toLowerCase() === "true";
            break;
          case "nodesize":
            config.nodeSize = parseInt(value) || 8;
            break;
          case "linkdistance":
            config.linkDistance = parseInt(value) || 80;
            break;
        }
      }
    }
    return config;
  }
  async getGraphData(config) {
    let triples = [];
    if (config.query) {
      const result = this.engine.select(config.query);
      for (const row of result.results) {
        if (row.s && row.p && row.o) {
          triples.push(new Triple(
            new IRI(row.s),
            new IRI(row.p),
            row.o.startsWith('"') ? Literal.string(row.o.replace(/^"|"$/g, "")) : new IRI(row.o)
          ));
        } else if (row.subject && row.predicate && row.object) {
          triples.push(new Triple(
            new IRI(row.subject),
            new IRI(row.predicate),
            row.object.startsWith('"') ? Literal.string(row.object.replace(/^"|"$/g, "")) : new IRI(row.object)
          ));
        }
      }
    } else if (config.focus) {
      triples = this.getTriplesAroundFocus(config.focus, config.depth || 2);
    } else {
      triples = this.graph.match(null, null, null);
    }
    if (config.limit && triples.length > config.limit) {
      triples = triples.slice(0, config.limit);
    }
    return this.convertTriplesToGraphData(triples);
  }
  getTriplesAroundFocus(focus, depth) {
    const visited = /* @__PURE__ */ new Set();
    const result = [];
    const queue = [{ entity: focus, currentDepth: 0 }];
    while (queue.length > 0) {
      const { entity, currentDepth } = queue.shift();
      if (visited.has(entity) || currentDepth >= depth) {
        continue;
      }
      visited.add(entity);
      const subjectTriples = this.graph.match(new IRI(entity), null, null);
      result.push(...subjectTriples);
      const objectTriples = this.graph.match(null, null, new IRI(entity));
      result.push(...objectTriples);
      if (currentDepth < depth - 1) {
        for (const triple of subjectTriples) {
          const objectStr = triple.getObject().toString();
          if (!visited.has(objectStr)) {
            queue.push({ entity: objectStr, currentDepth: currentDepth + 1 });
          }
        }
        for (const triple of objectTriples) {
          const subjectStr = triple.getSubject().toString();
          if (!visited.has(subjectStr)) {
            queue.push({ entity: subjectStr, currentDepth: currentDepth + 1 });
          }
        }
      }
    }
    return result;
  }
  convertTriplesToGraphData(triples) {
    const nodesMap = /* @__PURE__ */ new Map();
    const links = [];
    for (const triple of triples) {
      const subjectStr = triple.getSubject().toString();
      const predicateStr = triple.getPredicate().toString();
      const objectStr = triple.getObject().toString();
      if (!nodesMap.has(subjectStr)) {
        nodesMap.set(subjectStr, {
          id: subjectStr,
          label: this.getDisplayLabel(subjectStr),
          type: "subject",
          group: 1
        });
      }
      if (!nodesMap.has(objectStr)) {
        nodesMap.set(objectStr, {
          id: objectStr,
          label: this.getDisplayLabel(objectStr),
          type: "object",
          group: 2
        });
      }
      const linkId = `${subjectStr}-${predicateStr}-${objectStr}`;
      links.push({
        source: subjectStr,
        target: objectStr,
        label: predicateStr,
        id: linkId
      });
    }
    return {
      nodes: Array.from(nodesMap.values()),
      links
    };
  }
  getDisplayLabel(uri) {
    if (uri.startsWith("file://")) {
      return uri.replace("file://", "");
    }
    const parts = uri.split("/");
    return parts[parts.length - 1] || uri;
  }
  async createGraphVisualization(container, data, config) {
    const svgContainer = document.createElement("div");
    svgContainer.style.cssText = "position: relative; width: 100%; height: 600px; overflow: hidden;";
    container.appendChild(svgContainer);
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("width", "100%");
    svg.setAttribute("height", "600");
    svg.style.cssText = "border: 1px solid var(--background-modifier-border); background: var(--background-primary);";
    svgContainer.appendChild(svg);
    await this.createForceDirectedGraph(svg, data, config);
    container.__graphData = data;
    container.__graphConfig = config;
  }
  async createForceDirectedGraph(svg, data, config) {
    var _a, _b, _c, _d, _e, _f, _g;
    const width = 800;
    const height = 600;
    const centerX = width / 2;
    const centerY = height / 2;
    const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
    svg.appendChild(defs);
    const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
    marker.setAttribute("id", "arrowhead");
    marker.setAttribute("viewBox", "0 -5 10 10");
    marker.setAttribute("refX", "8");
    marker.setAttribute("refY", "0");
    marker.setAttribute("orient", "auto");
    marker.setAttribute("markerWidth", "6");
    marker.setAttribute("markerHeight", "6");
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("d", "M 0,-5 L 10 ,0 L 0,5");
    path.setAttribute("fill", "var(--text-muted)");
    marker.appendChild(path);
    defs.appendChild(marker);
    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
    svg.appendChild(g);
    this.positionNodes(data.nodes, width, height);
    const linksGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
    linksGroup.setAttribute("class", "links");
    g.appendChild(linksGroup);
    for (const link of data.links) {
      const sourceNode = data.nodes.find((n) => n.id === link.source);
      const targetNode = data.nodes.find((n) => n.id === link.target);
      if (sourceNode && targetNode) {
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", ((_a = sourceNode.x) == null ? void 0 : _a.toString()) || "0");
        line.setAttribute("y1", ((_b = sourceNode.y) == null ? void 0 : _b.toString()) || "0");
        line.setAttribute("x2", ((_c = targetNode.x) == null ? void 0 : _c.toString()) || "0");
        line.setAttribute("y2", ((_d = targetNode.y) == null ? void 0 : _d.toString()) || "0");
        line.setAttribute("stroke", "var(--text-muted)");
        line.setAttribute("stroke-width", "1");
        line.setAttribute("marker-end", "url(#arrowhead)");
        line.style.cursor = "pointer";
        line.addEventListener("mouseenter", () => {
          line.setAttribute("stroke", "var(--text-accent)");
          line.setAttribute("stroke-width", "2");
        });
        line.addEventListener("mouseleave", () => {
          line.setAttribute("stroke", "var(--text-muted)");
          line.setAttribute("stroke-width", "1");
        });
        linksGroup.appendChild(line);
        if (config.showLabels && link.label) {
          const midX = ((sourceNode.x || 0) + (targetNode.x || 0)) / 2;
          const midY = ((sourceNode.y || 0) + (targetNode.y || 0)) / 2;
          const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
          text.setAttribute("x", midX.toString());
          text.setAttribute("y", (midY - 5).toString());
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("font-size", "10");
          text.setAttribute("fill", "var(--text-muted)");
          text.textContent = this.truncateLabel(link.label, 15);
          const bbox = text.getBBox();
          const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
          rect.setAttribute("x", (bbox.x - 2).toString());
          rect.setAttribute("y", (bbox.y - 1).toString());
          rect.setAttribute("width", (bbox.width + 4).toString());
          rect.setAttribute("height", (bbox.height + 2).toString());
          rect.setAttribute("fill", "var(--background-primary)");
          rect.setAttribute("opacity", "0.8");
          linksGroup.appendChild(rect);
          linksGroup.appendChild(text);
        }
      }
    }
    const nodesGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
    nodesGroup.setAttribute("class", "nodes");
    g.appendChild(nodesGroup);
    for (const node of data.nodes) {
      const nodeGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
      nodeGroup.setAttribute("class", "node");
      nodeGroup.style.cursor = "pointer";
      const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      circle.setAttribute("cx", ((_e = node.x) == null ? void 0 : _e.toString()) || "0");
      circle.setAttribute("cy", ((_f = node.y) == null ? void 0 : _f.toString()) || "0");
      circle.setAttribute("r", (config.nodeSize || 8).toString());
      circle.setAttribute("fill", this.getNodeColor(node.type));
      circle.setAttribute("stroke", "var(--background-modifier-border)");
      circle.setAttribute("stroke-width", "2");
      nodeGroup.appendChild(circle);
      if (config.showLabels) {
        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.setAttribute("x", ((_g = node.x) == null ? void 0 : _g.toString()) || "0");
        text.setAttribute("y", ((node.y || 0) + (config.nodeSize || 8) + 15).toString());
        text.setAttribute("text-anchor", "middle");
        text.setAttribute("font-size", "12");
        text.setAttribute("fill", "var(--text-normal)");
        text.textContent = this.truncateLabel(node.label, 20);
        nodeGroup.appendChild(text);
      }
      nodeGroup.addEventListener("click", () => {
        this.handleNodeClick(node);
      });
      nodeGroup.addEventListener("mouseenter", () => {
        circle.setAttribute("r", ((config.nodeSize || 8) + 2).toString());
        circle.setAttribute("stroke-width", "3");
      });
      nodeGroup.addEventListener("mouseleave", () => {
        circle.setAttribute("r", (config.nodeSize || 8).toString());
        circle.setAttribute("stroke-width", "2");
      });
      nodesGroup.appendChild(nodeGroup);
    }
    this.addZoomPan(svg, g);
  }
  positionNodes(nodes, width, height) {
    const centerX = width / 2;
    const centerY = height / 2;
    const radius = Math.min(width, height) / 3;
    nodes.forEach((node, i) => {
      const angle = i / nodes.length * 2 * Math.PI;
      node.x = centerX + radius * Math.cos(angle);
      node.y = centerY + radius * Math.sin(angle);
    });
  }
  getNodeColor(type) {
    switch (type) {
      case "subject":
        return "var(--color-accent)";
      case "object":
        return "var(--color-blue)";
      case "predicate":
        return "var(--color-green)";
      default:
        return "var(--text-muted)";
    }
  }
  truncateLabel(label, maxLength) {
    if (label.length <= maxLength)
      return label;
    return label.substring(0, maxLength - 3) + "...";
  }
  handleNodeClick(node) {
    if (node.id.startsWith("file://") || node.id.includes(".md")) {
      const filename = node.id.replace("file://", "");
      this.plugin.app.workspace.openLinkText(filename, "");
    } else {
      new import_obsidian5.Notice(`Node: ${node.label}
Type: ${node.type}
ID: ${node.id}`, 3e3);
    }
  }
  addZoomPan(svg, g) {
    let isMouseDown = false;
    let startX = 0;
    let startY = 0;
    let currentTransform = { x: 0, y: 0, scale: 1 };
    svg.addEventListener("mousedown", (e) => {
      isMouseDown = true;
      startX = e.clientX;
      startY = e.clientY;
      svg.style.cursor = "grabbing";
    });
    svg.addEventListener("mousemove", (e) => {
      if (!isMouseDown)
        return;
      const deltaX = e.clientX - startX;
      const deltaY = e.clientY - startY;
      currentTransform.x += deltaX;
      currentTransform.y += deltaY;
      g.setAttribute(
        "transform",
        `translate(${currentTransform.x}, ${currentTransform.y}) scale(${currentTransform.scale})`
      );
      startX = e.clientX;
      startY = e.clientY;
    });
    svg.addEventListener("mouseup", () => {
      isMouseDown = false;
      svg.style.cursor = "grab";
    });
    svg.addEventListener("wheel", (e) => {
      e.preventDefault();
      const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;
      currentTransform.scale = Math.max(0.1, Math.min(3, currentTransform.scale * scaleFactor));
      g.setAttribute(
        "transform",
        `translate(${currentTransform.x}, ${currentTransform.y}) scale(${currentTransform.scale})`
      );
    });
    svg.style.cursor = "grab";
  }
  addControls(container, data, config) {
    const controlsDiv = document.createElement("div");
    controlsDiv.style.cssText = `
            margin-top: 1em;
            display: flex;
            gap: 0.5em;
            flex-wrap: wrap;
            align-items: center;
            padding: 0.5em;
            background: var(--background-modifier-form-field);
            border-radius: var(--radius-s);
        `;
    const info = document.createElement("span");
    info.textContent = `Nodes: ${data.nodes.length}, Links: ${data.links.length}`;
    info.style.cssText = "color: var(--text-muted); font-size: 0.9em; margin-right: auto;";
    controlsDiv.appendChild(info);
    const pngExportContainer = this.createPNGExportDropdown(container, data, config);
    controlsDiv.appendChild(pngExportContainer);
    const exportSvgBtn = document.createElement("button");
    exportSvgBtn.textContent = "Export SVG";
    exportSvgBtn.className = "mod-cta";
    exportSvgBtn.style.cssText = "padding: 0.25em 0.5em; font-size: 0.9em;";
    exportSvgBtn.addEventListener("click", () => this.exportAsSVG(container));
    controlsDiv.appendChild(exportSvgBtn);
    const rdfExportContainer = document.createElement("div");
    rdfExportContainer.style.cssText = "position: relative; display: inline-block;";
    const rdfExportBtn = document.createElement("button");
    rdfExportBtn.textContent = "Export RDF \u25BC";
    rdfExportBtn.style.cssText = "padding: 0.25em 0.5em; font-size: 0.9em; background: var(--interactive-accent); color: var(--text-on-accent); border: none; border-radius: 3px; cursor: pointer;";
    const rdfDropdown = document.createElement("div");
    rdfDropdown.style.cssText = `
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: var(--background-primary);
            border: 1px solid var(--background-modifier-border);
            border-radius: 3px;
            box-shadow: var(--shadow-s);
            z-index: 1000;
            min-width: 120px;
        `;
    const formats = [
      { format: "turtle", label: "Turtle (.ttl)" },
      { format: "json-ld", label: "JSON-LD (.jsonld)" },
      { format: "n-triples", label: "N-Triples (.nt)" },
      { format: "rdf-xml", label: "RDF/XML (.rdf)" }
    ];
    for (const { format, label } of formats) {
      const item = document.createElement("div");
      item.textContent = label;
      item.style.cssText = "padding: 0.5em 0.8em; cursor: pointer; border-bottom: 1px solid var(--background-modifier-border);";
      item.addEventListener("mouseenter", () => {
        item.style.background = "var(--background-modifier-hover)";
      });
      item.addEventListener("mouseleave", () => {
        item.style.background = "";
      });
      item.addEventListener("click", () => {
        this.exportGraphAsRDF(data, format);
        rdfDropdown.style.display = "none";
      });
      rdfDropdown.appendChild(item);
    }
    const advancedItem = document.createElement("div");
    advancedItem.textContent = "Advanced...";
    advancedItem.style.cssText = "padding: 0.5em 0.8em; cursor: pointer; font-weight: 500; color: var(--text-accent);";
    advancedItem.addEventListener("mouseenter", () => {
      advancedItem.style.background = "var(--background-modifier-hover)";
    });
    advancedItem.addEventListener("mouseleave", () => {
      advancedItem.style.background = "";
    });
    advancedItem.addEventListener("click", () => {
      this.openAdvancedRDFExport(data);
      rdfDropdown.style.display = "none";
    });
    rdfDropdown.appendChild(advancedItem);
    rdfExportBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      rdfDropdown.style.display = rdfDropdown.style.display === "none" ? "block" : "none";
    });
    document.addEventListener("click", () => {
      rdfDropdown.style.display = "none";
    });
    rdfExportContainer.appendChild(rdfExportBtn);
    rdfExportContainer.appendChild(rdfDropdown);
    controlsDiv.appendChild(rdfExportContainer);
    const resetBtn = document.createElement("button");
    resetBtn.textContent = "Reset View";
    resetBtn.style.cssText = "padding: 0.25em 0.5em; font-size: 0.9em;";
    resetBtn.addEventListener("click", () => this.resetView(container));
    controlsDiv.appendChild(resetBtn);
    container.appendChild(controlsDiv);
  }
  createPNGExportDropdown(container, data, config) {
    const pngExportContainer = document.createElement("div");
    pngExportContainer.style.cssText = "position: relative; display: inline-block;";
    const pngExportBtn = document.createElement("button");
    pngExportBtn.textContent = "Export PNG \u25BC";
    pngExportBtn.style.cssText = "padding: 0.25em 0.5em; font-size: 0.9em; background: var(--interactive-accent); color: var(--text-on-accent); border: none; border-radius: 3px; cursor: pointer;";
    const pngDropdown = document.createElement("div");
    pngDropdown.style.cssText = `
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: var(--background-primary);
            border: 1px solid var(--background-modifier-border);
            border-radius: 3px;
            box-shadow: var(--shadow-s);
            z-index: 1000;
            min-width: 180px;
        `;
    const resolutions = [
      { scale: 1, label: "Standard (800\xD7600)", filename: "graph-standard.png" },
      { scale: 2, label: "High-DPI (1600\xD71200)", filename: "graph-hd.png" },
      { scale: 4, label: "4K (3200\xD72400)", filename: "graph-4k.png" }
    ];
    for (const resolution of resolutions) {
      const item = document.createElement("div");
      item.textContent = resolution.label;
      item.style.cssText = "padding: 0.5em 0.8em; cursor: pointer; border-bottom: 1px solid var(--background-modifier-border);";
      item.addEventListener("mouseenter", () => {
        item.style.background = "var(--background-modifier-hover)";
      });
      item.addEventListener("mouseleave", () => {
        item.style.background = "";
      });
      item.addEventListener("click", () => {
        this.exportAsPNG(container, data, config, resolution.scale, resolution.filename);
        pngDropdown.style.display = "none";
      });
      pngDropdown.appendChild(item);
    }
    pngExportBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      pngDropdown.style.display = pngDropdown.style.display === "none" ? "block" : "none";
    });
    document.addEventListener("click", () => {
      pngDropdown.style.display = "none";
    });
    pngExportContainer.appendChild(pngExportBtn);
    pngExportContainer.appendChild(pngDropdown);
    return pngExportContainer;
  }
  async exportAsPNG(container, data, config, scale = 1, filename = "knowledge-graph.png") {
    const svg = container.querySelector("svg");
    if (!svg) {
      new import_obsidian5.Notice("No graph visualization found");
      return;
    }
    try {
      let loadingNotice = null;
      if (scale >= 2) {
        loadingNotice = new import_obsidian5.Notice(`Generating ${scale === 2 ? "high-resolution" : "4K"} PNG export...`, 0);
      }
      const canvas = document.createElement("canvas");
      const baseWidth = 800;
      const baseHeight = 600;
      canvas.width = baseWidth * scale;
      canvas.height = baseHeight * scale;
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        throw new Error("Could not get canvas context");
      }
      ctx.scale(scale, scale);
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      const bgColor = this.getThemeColor("--background-primary") || "#ffffff";
      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, baseWidth, baseHeight);
      const borderColor = this.getThemeColor("--background-modifier-border") || "#e5e5e5";
      ctx.strokeStyle = borderColor;
      ctx.lineWidth = 1;
      ctx.strokeRect(0, 0, baseWidth, baseHeight);
      await this.renderGraphToCanvas(ctx, data, config, baseWidth, baseHeight);
      canvas.toBlob((blob) => {
        if (blob) {
          this.downloadBlob(blob, filename);
          if (loadingNotice) {
            loadingNotice.hide();
          }
          const sizeKB = Math.round(blob.size / 1024);
          new import_obsidian5.Notice(`Graph exported as PNG (${sizeKB} KB)`);
        } else {
          throw new Error("Failed to create PNG blob");
        }
      }, "image/png", 0.9);
    } catch (error) {
      console.error("PNG export failed:", error);
      new import_obsidian5.Notice(`PNG export failed: ${error.message}`);
    }
  }
  async renderGraphToCanvas(ctx, data, config, width, height) {
    this.positionNodes(data.nodes, width, height);
    for (const link of data.links) {
      const sourceNode = data.nodes.find((n) => n.id === (typeof link.source === "string" ? link.source : link.source.id));
      const targetNode = data.nodes.find((n) => n.id === (typeof link.target === "string" ? link.target : link.target.id));
      if (sourceNode && targetNode) {
        ctx.beginPath();
        ctx.moveTo(sourceNode.x || 0, sourceNode.y || 0);
        ctx.lineTo(targetNode.x || 0, targetNode.y || 0);
        ctx.strokeStyle = this.getThemeColor("--text-muted") || "#6b7280";
        ctx.lineWidth = 1;
        ctx.stroke();
        this.drawArrowHead(ctx, sourceNode.x || 0, sourceNode.y || 0, targetNode.x || 0, targetNode.y || 0);
        if (config.showLabels && link.label) {
          const midX = ((sourceNode.x || 0) + (targetNode.x || 0)) / 2;
          const midY = ((sourceNode.y || 0) + (targetNode.y || 0)) / 2;
          const labelText = this.truncateLabel(link.label, 15);
          ctx.font = "10px var(--font-interface)";
          const textMetrics = ctx.measureText(labelText);
          ctx.fillStyle = this.getThemeColor("--background-primary") || "#ffffff";
          ctx.fillRect(midX - textMetrics.width / 2 - 2, midY - 7, textMetrics.width + 4, 12);
          ctx.fillStyle = this.getThemeColor("--text-muted") || "#6b7280";
          ctx.textAlign = "center";
          ctx.fillText(labelText, midX, midY + 3);
        }
      }
    }
    for (const node of data.nodes) {
      const x = node.x || 0;
      const y = node.y || 0;
      const radius = config.nodeSize || 8;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, 2 * Math.PI);
      ctx.fillStyle = this.getNodeCanvasColor(node.type);
      ctx.fill();
      ctx.strokeStyle = this.getThemeColor("--background-modifier-border") || "#e5e5e5";
      ctx.lineWidth = 2;
      ctx.stroke();
      if (config.showLabels) {
        ctx.font = "12px var(--font-interface)";
        ctx.fillStyle = this.getThemeColor("--text-normal") || "#000000";
        ctx.textAlign = "center";
        const labelText = this.truncateLabel(node.label, 20);
        ctx.fillText(labelText, x, y + radius + 15);
      }
    }
  }
  drawArrowHead(ctx, fromX, fromY, toX, toY) {
    const angle = Math.atan2(toY - fromY, toX - fromX);
    const arrowLength = 10;
    const arrowAngle = Math.PI / 6;
    const offsetDistance = 10;
    const offsetX = toX - offsetDistance * Math.cos(angle);
    const offsetY = toY - offsetDistance * Math.sin(angle);
    ctx.beginPath();
    ctx.moveTo(offsetX, offsetY);
    ctx.lineTo(
      offsetX - arrowLength * Math.cos(angle - arrowAngle),
      offsetY - arrowLength * Math.sin(angle - arrowAngle)
    );
    ctx.moveTo(offsetX, offsetY);
    ctx.lineTo(
      offsetX - arrowLength * Math.cos(angle + arrowAngle),
      offsetY - arrowLength * Math.sin(angle + arrowAngle)
    );
    ctx.strokeStyle = this.getThemeColor("--text-muted") || "#6b7280";
    ctx.lineWidth = 1;
    ctx.stroke();
  }
  getThemeColor(cssVariable) {
    try {
      const style = getComputedStyle(document.documentElement);
      const color = style.getPropertyValue(cssVariable).trim();
      if (!color)
        return null;
      if (color.startsWith("hsl")) {
        return this.hslToHex(color);
      }
      if (color.startsWith("rgb")) {
        return this.rgbToHex(color);
      }
      return color;
    } catch (error) {
      console.warn(`Failed to get theme color for ${cssVariable}:`, error);
      return null;
    }
  }
  getNodeCanvasColor(type) {
    switch (type) {
      case "subject":
        return this.getThemeColor("--color-accent") || "#7c3aed";
      case "object":
        return this.getThemeColor("--color-blue") || "#2563eb";
      case "predicate":
        return this.getThemeColor("--color-green") || "#059669";
      default:
        return "#6b7280";
    }
  }
  hslToHex(hsl) {
    return "#6b7280";
  }
  rgbToHex(rgb) {
    const match = rgb.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
    if (!match)
      return "#000000";
    const r = parseInt(match[1]);
    const g = parseInt(match[2]);
    const b = parseInt(match[3]);
    return "#" + [r, g, b].map((x) => {
      const hex = x.toString(16);
      return hex.length === 1 ? "0" + hex : hex;
    }).join("");
  }
  downloadBlob(blob, filename) {
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = filename;
    link.style.display = "none";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }
  exportAsSVG(container) {
    const svg = container.querySelector("svg");
    if (!svg)
      return;
    try {
      const serializer = new XMLSerializer();
      const svgString = serializer.serializeToString(svg);
      const blob = new Blob([svgString], { type: "image/svg+xml" });
      this.downloadBlob(blob, "knowledge-graph.svg");
      new import_obsidian5.Notice("Graph exported as SVG");
    } catch (error) {
      console.error("SVG export failed:", error);
      new import_obsidian5.Notice("Failed to export SVG");
    }
  }
  resetView(container) {
    const svg = container.querySelector("svg");
    const g = svg == null ? void 0 : svg.querySelector("g");
    if (g) {
      g.setAttribute("transform", "translate(0, 0) scale(1)");
    }
  }
  createLoadingIndicator() {
    const loading = document.createElement("div");
    loading.className = "graph-loading";
    loading.textContent = "Generating graph visualization...";
    loading.style.cssText = "padding: 2em; text-align: center; color: var(--text-muted);";
    return loading;
  }
  createErrorMessage(error) {
    const errorDiv = document.createElement("div");
    errorDiv.className = "graph-error";
    errorDiv.style.cssText = `
            background: var(--background-modifier-error);
            color: var(--text-error);
            padding: 1em;
            border-radius: var(--radius-m);
            border: 1px solid var(--background-modifier-border);
        `;
    const title = document.createElement("strong");
    title.textContent = "Graph Visualization Error: ";
    errorDiv.appendChild(title);
    const message = document.createElement("span");
    message.textContent = error.message;
    errorDiv.appendChild(message);
    return errorDiv;
  }
  /**
   * Export graph visualization data as RDF
   */
  async exportGraphAsRDF(data, format) {
    try {
      const triples = this.convertGraphDataToTriples(data);
      const graph = new Graph();
      for (const triple of triples) {
        graph.add(triple);
      }
      const fileName = `graph-visualization-${Date.now()}`;
      const result = await this.rdfService.exportGraph(graph, {
        format,
        fileName,
        saveToVault: true,
        includeComments: true,
        prettyPrint: true,
        targetFolder: "exports"
      });
      if (result.isSuccess) {
        const exportData = result.getValue();
        new import_obsidian5.Notice(`Exported graph visualization as ${format.toUpperCase()} (${exportData.tripleCount} triples)`);
      } else {
        new import_obsidian5.Notice(`Export failed: ${result.errorValue()}`);
      }
    } catch (error) {
      new import_obsidian5.Notice(`Export error: ${error.message}`);
      console.error("Graph RDF export error:", error);
    }
  }
  /**
   * Open advanced RDF export modal
   */
  openAdvancedRDFExport(data) {
    try {
      const triples = this.convertGraphDataToTriples(data);
      const graph = new Graph();
      for (const triple of triples) {
        graph.add(triple);
      }
      const modal = new ExportRDFModal(
        this.plugin.app,
        graph,
        this.rdfService.getNamespaceManager(),
        (result) => {
          new import_obsidian5.Notice(`Graph visualization exported: ${result.fileName}`);
        }
      );
      modal.open();
    } catch (error) {
      new import_obsidian5.Notice(`Failed to open export modal: ${error.message}`);
      console.error("Export modal error:", error);
    }
  }
  /**
   * Convert GraphData back to Triple format
   */
  convertGraphDataToTriples(data) {
    const triples = [];
    for (const link of data.links) {
      const sourceNode = data.nodes.find((n) => n.id === (typeof link.source === "string" ? link.source : link.source.id));
      const targetNode = data.nodes.find((n) => n.id === (typeof link.target === "string" ? link.target : link.target.id));
      if (sourceNode && targetNode) {
        triples.push(new Triple(
          new IRI(sourceNode.id),
          new IRI(link.label),
          new IRI(targetNode.id)
        ));
      }
    }
    return triples;
  }
};

// src/presentation/modals/CreateAssetModal.ts
var import_obsidian16 = require("obsidian");

// src/application/core/Container.ts
var Container = class {
  constructor() {
    this.services = /* @__PURE__ */ new Map();
    this.factories = /* @__PURE__ */ new Map();
  }
  static getInstance() {
    if (!Container.instance) {
      Container.instance = new Container();
    }
    return Container.instance;
  }
  /**
   * Register a service factory
   */
  register(token, factory) {
    this.factories.set(token, factory);
  }
  /**
   * Register a singleton service
   */
  registerSingleton(token, service) {
    this.services.set(token, service);
  }
  /**
   * Resolve a service
   */
  resolve(token) {
    if (this.services.has(token)) {
      return this.services.get(token);
    }
    if (this.factories.has(token)) {
      const factory = this.factories.get(token);
      if (factory) {
        const service = factory();
        return service;
      }
    }
    throw new Error(`Service not found: ${token}`);
  }
  /**
   * Check if a service is registered
   */
  has(token) {
    return this.services.has(token) || this.factories.has(token);
  }
  /**
   * Clear all registrations
   */
  clear() {
    this.services.clear();
    this.factories.clear();
  }
  /**
   * Reset the container instance (for testing)
   */
  static reset() {
    if (Container.instance) {
      Container.instance.clear();
      Container.instance = null;
    }
  }
};

// src/infrastructure/repositories/ObsidianAssetRepository.ts
var import_obsidian6 = require("obsidian");

// src/domain/value-objects/AssetId.ts
var AssetId = class {
  constructor(value) {
    this.value = value;
  }
  static create(value) {
    if (!value || value.trim().length === 0) {
      return Result.fail("AssetId cannot be empty");
    }
    return Result.ok(new AssetId(value));
  }
  static generate() {
    const uuid = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
    return new AssetId(uuid);
  }
  toString() {
    return this.value;
  }
  equals(other) {
    return this.value === other.value;
  }
};

// src/domain/value-objects/ClassName.ts
var ClassName = class {
  constructor(value) {
    this.value = value;
  }
  static create(value) {
    if (!value || value.trim().length === 0) {
      return Result.fail("ClassName cannot be empty");
    }
    const cleaned = value.replace(/\[\[|\]\]/g, "");
    if (!/^[a-zA-Z_][a-zA-Z0-9_]*(?:__[a-zA-Z][a-zA-Z0-9_]*)?$/.test(cleaned)) {
      return Result.fail(`Invalid class name format: ${value}`);
    }
    return Result.ok(new ClassName(cleaned));
  }
  toString() {
    return this.value;
  }
  toWikiLink() {
    return `[[${this.value}]]`;
  }
  getPrefix() {
    const parts = this.value.split("__");
    return parts.length > 1 ? parts[0] : "";
  }
  getName() {
    const parts = this.value.split("__");
    return parts.length > 1 ? parts[1] : parts[0];
  }
  equals(other) {
    return this.value === other.value;
  }
};

// src/domain/value-objects/OntologyPrefix.ts
var OntologyPrefix = class {
  constructor(value) {
    this.value = value;
  }
  static create(value) {
    if (!value || value.trim().length === 0) {
      return Result.fail("OntologyPrefix cannot be empty");
    }
    if (!/^[a-z][a-z0-9]*$/.test(value)) {
      return Result.fail(`Invalid ontology prefix format: ${value}. Must be lowercase alphanumeric starting with a letter`);
    }
    return Result.ok(new OntologyPrefix(value));
  }
  toString() {
    return this.value;
  }
  toFileName() {
    return `!${this.value}`;
  }
  equals(other) {
    return this.value === other.value;
  }
};

// src/domain/core/Entity.ts
var Entity = class {
  constructor(props) {
    this._domainEvents = [];
    this.props = props;
  }
  /**
   * Entities are equal if they have the same ID
   */
  equals(object) {
    if (object === null || object === void 0) {
      return false;
    }
    if (this === object) {
      return true;
    }
    if (!this.isEntity(object)) {
      return false;
    }
    return this._id === object._id;
  }
  isEntity(v) {
    return v instanceof Entity;
  }
  /**
   * Domain events
   */
  addDomainEvent(domainEvent) {
    this._domainEvents.push(domainEvent);
  }
  clearEvents() {
    this._domainEvents = [];
  }
  get domainEvents() {
    return this._domainEvents;
  }
  getDomainEvents() {
    return this._domainEvents;
  }
  clearDomainEvents() {
    this._domainEvents = [];
  }
};

// src/domain/entities/Asset.ts
var Asset = class extends Entity {
  constructor(props) {
    super(props);
  }
  static create(params) {
    if (!params.label || params.label.trim().length === 0) {
      return Result.fail("Asset label cannot be empty");
    }
    const props = {
      id: params.id,
      title: params.label,
      className: params.className,
      ontology: params.ontology,
      label: params.label,
      description: params.description,
      properties: new Map(Object.entries(params.properties || {})),
      createdAt: new Date(),
      updatedAt: new Date()
    };
    return Result.ok(new Asset(props));
  }
  // Getters
  getId() {
    return this.props.id;
  }
  getTitle() {
    return this.props.title;
  }
  getClassName() {
    return this.props.className;
  }
  getOntologyPrefix() {
    return this.props.ontology;
  }
  getProperties() {
    return new Map(this.props.properties);
  }
  getProperty(key) {
    return this.props.properties.get(key);
  }
  getCreatedAt() {
    return this.props.createdAt;
  }
  getUpdatedAt() {
    return this.props.updatedAt;
  }
  // Business methods
  updateTitle(title) {
    if (!title || title.trim().length === 0) {
      throw new Error("Asset title cannot be empty");
    }
    this.props.title = title;
    this.props.updatedAt = new Date();
  }
  setProperty(key, value) {
    this.props.properties.set(key, value);
    this.props.updatedAt = new Date();
  }
  removeProperty(key) {
    this.props.properties.delete(key);
    this.props.updatedAt = new Date();
  }
  changeClass(className) {
    this.props.className = className;
    this.props.updatedAt = new Date();
  }
  toFrontmatter() {
    const frontmatter = {
      "exo__Asset_uid": this.props.id.toString(),
      "exo__Asset_label": this.props.title,
      "exo__Asset_isDefinedBy": `[[!${this.props.ontology.toString()}]]`,
      "exo__Asset_createdAt": this.props.createdAt.toISOString(),
      "exo__Instance_class": [this.props.className.toWikiLink()]
    };
    for (const [key, value] of this.props.properties) {
      if (!frontmatter[key]) {
        frontmatter[key] = value;
      }
    }
    return frontmatter;
  }
  static fromFrontmatter(frontmatter, fileName) {
    var _a;
    try {
      const idResult = AssetId.create(frontmatter["exo__Asset_uid"] || AssetId.generate().toString());
      const id = idResult.isSuccess ? idResult.getValue() : AssetId.generate();
      const label = frontmatter["exo__Asset_label"] || fileName.replace(".md", "");
      const classValue = Array.isArray(frontmatter["exo__Instance_class"]) ? frontmatter["exo__Instance_class"][0] : frontmatter["exo__Instance_class"];
      const classNameResult = ClassName.create(classValue || "exo__Asset");
      const className = classNameResult.isSuccess ? classNameResult.getValue() : ClassName.create("exo__Asset").getValue();
      const ontologyValue = ((_a = frontmatter["exo__Asset_isDefinedBy"]) == null ? void 0 : _a.replace(/\[\[!?|\]\]/g, "")) || "exo";
      const ontologyResult = OntologyPrefix.create(ontologyValue);
      const ontology = ontologyResult.isSuccess ? ontologyResult.getValue() : OntologyPrefix.create("exo").getValue();
      const createdAt = frontmatter["exo__Asset_createdAt"] ? new Date(frontmatter["exo__Asset_createdAt"]) : new Date();
      const properties = {};
      for (const [key, value] of Object.entries(frontmatter)) {
        if (!key.startsWith("exo__Asset_") && !key.startsWith("exo__Instance_")) {
          properties[key] = value;
        }
      }
      const result = Asset.create({
        id,
        label,
        className,
        ontology,
        properties
      });
      if (result.isSuccess) {
        const asset = result.getValue();
        asset.props.createdAt = createdAt;
        return asset;
      } else {
        console.warn("Failed to create asset from frontmatter:", result.error);
      }
      return null;
    } catch (error) {
      console.warn("Failed to create asset from frontmatter:", error);
      return null;
    }
  }
};

// src/infrastructure/repositories/ObsidianAssetRepository.ts
var ObsidianAssetRepository = class {
  constructor(app) {
    this.app = app;
  }
  async findById(id) {
    var _a;
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      const cache = this.app.metadataCache.getFileCache(file);
      if (((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a["exo__Asset_uid"]) === id.toString()) {
        const content = await this.app.vault.read(file);
        return Asset.fromFrontmatter(cache.frontmatter, file.basename);
      }
    }
    return null;
  }
  async findByClass(className) {
    const files = this.app.vault.getMarkdownFiles();
    const assets = [];
    for (const file of files) {
      const cache = this.app.metadataCache.getFileCache(file);
      if (cache == null ? void 0 : cache.frontmatter) {
        const classes = cache.frontmatter["exo__Instance_class"];
        const classArray = Array.isArray(classes) ? classes : [classes];
        if (classArray.some((c) => c === className.toWikiLink() || c === className.toString())) {
          const asset = Asset.fromFrontmatter(cache.frontmatter, file.basename);
          if (asset) {
            assets.push(asset);
          }
        }
      }
    }
    return assets;
  }
  async findByOntology(prefix) {
    const files = this.app.vault.getMarkdownFiles();
    const assets = [];
    for (const file of files) {
      const cache = this.app.metadataCache.getFileCache(file);
      if (cache == null ? void 0 : cache.frontmatter) {
        const ontology = cache.frontmatter["exo__Asset_isDefinedBy"];
        const ontologyValue = ontology == null ? void 0 : ontology.replace(/\[\[!?|\]\]/g, "");
        if (ontologyValue === prefix.toString()) {
          const asset = Asset.fromFrontmatter(cache.frontmatter, file.basename);
          if (asset) {
            assets.push(asset);
          }
        }
      }
    }
    return assets;
  }
  async save(asset) {
    var _a, _b;
    const frontmatter = asset.toFrontmatter();
    let targetFile = null;
    const storedPath = (_a = asset.props) == null ? void 0 : _a.filePath;
    if (storedPath) {
      const file = this.app.vault.getAbstractFileByPath(storedPath);
      if (file instanceof import_obsidian6.TFile) {
        targetFile = file;
      }
    }
    if (!targetFile) {
      const assetId = frontmatter["exo__Asset_uid"];
      if (assetId) {
        const files = this.app.vault.getMarkdownFiles();
        for (const file of files) {
          const cache = this.app.metadataCache.getFileCache(file);
          if (((_b = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _b["exo__Asset_uid"]) === assetId) {
            targetFile = file;
            break;
          }
        }
      }
    }
    if (!targetFile) {
      const fileName = `${asset.getTitle()}.md`;
      const file = this.app.vault.getAbstractFileByPath(fileName);
      if (file instanceof import_obsidian6.TFile) {
        targetFile = file;
      }
    }
    const yamlLines = ["---"];
    for (const [key, value] of Object.entries(frontmatter)) {
      if (Array.isArray(value)) {
        yamlLines.push(`${key}:`);
        for (const item of value) {
          const itemStr = String(item);
          if (itemStr.includes("[[") && itemStr.includes("]]")) {
            yamlLines.push(`  - "${itemStr}"`);
          } else {
            yamlLines.push(`  - ${itemStr}`);
          }
        }
      } else if (typeof value === "object" && value !== null) {
        yamlLines.push(`${key}: ${JSON.stringify(value)}`);
      } else {
        const valueStr = String(value);
        if (valueStr.includes("[[") && valueStr.includes("]]")) {
          yamlLines.push(`${key}: "${valueStr}"`);
        } else {
          yamlLines.push(`${key}: ${valueStr}`);
        }
      }
    }
    yamlLines.push("---");
    if (targetFile) {
      const existingContent = await this.app.vault.read(targetFile);
      const contentMatch = existingContent.match(/^---\n[\s\S]*?\n---\n([\s\S]*)$/);
      const bodyContent = contentMatch ? contentMatch[1] : "";
      const newContent = yamlLines.join("\n") + "\n" + bodyContent;
      await this.app.vault.modify(targetFile, newContent);
    } else {
      const fileName = `${asset.getTitle()}.md`;
      const content = yamlLines.join("\n") + "\n";
      await this.app.vault.create(fileName, content);
    }
  }
  async delete(id) {
    const asset = await this.findById(id);
    if (asset) {
      const fileName = `${asset.getTitle()}.md`;
      const file = this.app.vault.getAbstractFileByPath(fileName);
      if (file) {
        await this.app.vault.delete(file);
      }
    }
  }
  async exists(id) {
    const asset = await this.findById(id);
    return asset !== null;
  }
  async findAll() {
    var _a;
    const files = this.app.vault.getMarkdownFiles();
    const assets = [];
    for (const file of files) {
      const cache = this.app.metadataCache.getFileCache(file);
      if ((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a["exo__Asset_uid"]) {
        const asset = Asset.fromFrontmatter(cache.frontmatter, file.basename);
        if (asset) {
          assets.push(asset);
        }
      }
    }
    return assets;
  }
  async findByFilename(filename) {
    let searchPath = filename;
    if (!searchPath.endsWith(".md")) {
      searchPath = `${searchPath}.md`;
    }
    let file = this.app.vault.getAbstractFileByPath(searchPath);
    if (!file) {
      const files = this.app.vault.getMarkdownFiles();
      file = files.find((f) => f.path === searchPath || f.name === searchPath) || null;
    }
    if (file instanceof import_obsidian6.TFile) {
      const cache = this.app.metadataCache.getFileCache(file);
      if (cache == null ? void 0 : cache.frontmatter) {
        const asset = Asset.fromFrontmatter(cache.frontmatter, file.basename);
        if (asset) {
          asset.props.filePath = file.path;
          return asset;
        }
      }
    }
    return null;
  }
  /**
   * Update only the frontmatter of a file by path
   */
  async updateFrontmatterByPath(filePath, updates) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian6.TFile)) {
      throw new Error(`File not found: ${filePath}`);
    }
    const content = await this.app.vault.read(file);
    const cache = this.app.metadataCache.getFileCache(file);
    const currentFrontmatter = (cache == null ? void 0 : cache.frontmatter) || {};
    const newFrontmatter = { ...currentFrontmatter, ...updates };
    const yamlLines = ["---"];
    for (const [key, value] of Object.entries(newFrontmatter)) {
      if (value === void 0 || value === null)
        continue;
      if (Array.isArray(value)) {
        yamlLines.push(`${key}:`);
        for (const item of value) {
          const itemStr = String(item);
          if (itemStr.includes("[[") && itemStr.includes("]]")) {
            yamlLines.push(`  - "${itemStr}"`);
          } else {
            yamlLines.push(`  - ${itemStr}`);
          }
        }
      } else if (typeof value === "object" && value !== null) {
        yamlLines.push(`${key}: ${JSON.stringify(value)}`);
      } else if (typeof value === "boolean") {
        yamlLines.push(`${key}: ${value}`);
      } else if (typeof value === "number") {
        yamlLines.push(`${key}: ${value}`);
      } else {
        const valueStr = String(value);
        if (valueStr.includes(":") || valueStr.includes("#") || valueStr.includes("[") || valueStr.includes("]") || valueStr.includes("{") || valueStr.includes("}") || valueStr.includes("|") || valueStr.includes(">") || valueStr.includes("@") || valueStr.includes("`") || valueStr.includes('"') || valueStr.includes("'") || valueStr.startsWith(" ") || valueStr.endsWith(" ")) {
          yamlLines.push(`${key}: "${valueStr.replace(/"/g, '\\"')}"`);
        } else {
          yamlLines.push(`${key}: ${valueStr}`);
        }
      }
    }
    yamlLines.push("---");
    let bodyContent = "";
    if (content.startsWith("---\n")) {
      const endOfFrontmatter = content.indexOf("\n---\n", 4);
      if (endOfFrontmatter !== -1) {
        bodyContent = content.substring(endOfFrontmatter + 5);
      } else {
        bodyContent = content;
      }
    } else {
      bodyContent = content;
    }
    const newContent = yamlLines.join("\n") + "\n" + bodyContent;
    await this.app.vault.modify(file, newContent);
  }
};

// src/infrastructure/repositories/ObsidianOntologyRepository.ts
var import_obsidian7 = require("obsidian");

// src/domain/entities/Ontology.ts
var Ontology = class {
  constructor(params) {
    this.prefix = params.prefix;
    this.label = params.label;
    this.fileName = params.fileName;
    this.namespace = params.namespace;
    this.description = params.description;
  }
  getPrefix() {
    return this.prefix;
  }
  getLabel() {
    return this.label;
  }
  getFileName() {
    return this.fileName;
  }
  getNamespace() {
    return this.namespace;
  }
  getDescription() {
    return this.description;
  }
  getDisplayName() {
    return `${this.prefix.toString()} - ${this.label}`;
  }
  isInternal() {
    return this.fileName.startsWith("!");
  }
  equals(other) {
    return this.prefix.equals(other.prefix);
  }
  toFrontmatter() {
    return {
      "exo__Ontology_prefix": this.prefix.toString(),
      "exo__Ontology_label": this.label,
      "exo__Ontology_namespace": this.namespace || "",
      "exo__Ontology_description": this.description || ""
    };
  }
  static fromFrontmatter(frontmatter) {
    const prefixResult = OntologyPrefix.create(frontmatter["exo__Ontology_prefix"] || "exo");
    const prefix = prefixResult.isSuccess ? prefixResult.getValue() : OntologyPrefix.create("exo").getValue();
    return new Ontology({
      prefix,
      label: frontmatter["exo__Ontology_label"] || prefix.toString(),
      fileName: `!${prefix.toString()}.md`,
      namespace: frontmatter["exo__Ontology_namespace"],
      description: frontmatter["exo__Ontology_description"]
    });
  }
};

// src/infrastructure/repositories/ObsidianOntologyRepository.ts
var ObsidianOntologyRepository = class {
  constructor(app) {
    this.app = app;
  }
  async findByPrefix(prefix) {
    const fileName = `!${prefix.toString()}.md`;
    const file = this.app.vault.getAbstractFileByPath(fileName);
    if (file instanceof import_obsidian7.TFile) {
      const cache = this.app.metadataCache.getFileCache(file);
      if (cache == null ? void 0 : cache.frontmatter) {
        return Ontology.fromFrontmatter(cache.frontmatter);
      }
    }
    return null;
  }
  async findAll() {
    var _a;
    const files = this.app.vault.getMarkdownFiles();
    const ontologies = [];
    for (const file of files) {
      if (file.name.startsWith("!")) {
        const cache = this.app.metadataCache.getFileCache(file);
        if ((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a["exo__Ontology_prefix"]) {
          ontologies.push(Ontology.fromFrontmatter(cache.frontmatter));
        }
      }
    }
    return ontologies;
  }
  async save(ontology) {
    const fileName = `!${ontology.getPrefix().toString()}.md`;
    const frontmatter = ontology.toFrontmatter();
    const yamlLines = ["---"];
    for (const [key, value] of Object.entries(frontmatter)) {
      if (Array.isArray(value)) {
        yamlLines.push(`${key}:`);
        for (const item of value) {
          yamlLines.push(`  - ${item}`);
        }
      } else {
        yamlLines.push(`${key}: ${value}`);
      }
    }
    yamlLines.push("---", "");
    const content = yamlLines.join("\n");
    const existingFile = this.app.vault.getAbstractFileByPath(fileName);
    if (existingFile instanceof import_obsidian7.TFile) {
      await this.app.vault.modify(existingFile, content);
    } else {
      await this.app.vault.create(fileName, content);
    }
  }
  async exists(prefix) {
    const fileName = `!${prefix.toString()}.md`;
    const file = this.app.vault.getAbstractFileByPath(fileName);
    return file instanceof import_obsidian7.TFile;
  }
};

// src/infrastructure/repositories/ObsidianClassViewRepository.ts
var import_obsidian8 = require("obsidian");

// src/domain/core/AggregateRoot.ts
var AggregateRoot = class extends Entity {
  constructor(props) {
    super(props);
  }
  /**
   * Get all domain events (inherits from Entity)
   */
  getUncommittedEvents() {
    return this.getDomainEvents();
  }
  /**
   * Mark domain event for dispatch
   */
  markDomainEventForDispatch(domainEvent) {
    const markedEvent = {
      ...domainEvent,
      dateTimeOccurred: new Date(),
      aggregateId: this._id
    };
    console.log("Domain event marked for dispatch:", markedEvent);
  }
  /**
   * Commit events
   */
  markEventsAsCommitted() {
    this.clearDomainEvents();
  }
};

// src/domain/aggregates/ClassView.ts
var _ClassView = class extends AggregateRoot {
  constructor(props) {
    super(props);
  }
  /**
   * Factory method with business rules validation
   */
  static create(props) {
    if (!props.className) {
      return Result.fail("Class view must be associated with a class");
    }
    if (props.buttons.length > _ClassView.MAX_BUTTONS_PER_VIEW) {
      return Result.fail(
        `Class view cannot have more than ${_ClassView.MAX_BUTTONS_PER_VIEW} buttons`
      );
    }
    const orders = props.buttons.map((b) => b.order);
    const uniqueOrders = new Set(orders);
    if (uniqueOrders.size !== orders.length) {
      return Result.fail("Buttons cannot have duplicate order values");
    }
    const defaultDisplayOptions = {
      showProperties: true,
      showRelations: true,
      showBacklinks: true,
      showButtons: true,
      buttonPosition: "top"
    };
    return Result.ok(new _ClassView({
      ...props,
      displayOptions: props.displayOptions || defaultDisplayOptions
    }));
  }
  // Getters
  get id() {
    return this.props.id;
  }
  get className() {
    return this.props.className;
  }
  get buttons() {
    return [...this.props.buttons].sort((a, b) => a.order - b.order);
  }
  get displayOptions() {
    return this.props.displayOptions || {
      showProperties: true,
      showRelations: true,
      showBacklinks: true,
      showButtons: true,
      buttonPosition: "top"
    };
  }
  /**
   * Add a button to the view
   */
  addButton(button) {
    if (this.props.buttons.length >= _ClassView.MAX_BUTTONS_PER_VIEW) {
      return Result.fail(
        `Cannot add more buttons. Maximum of ${_ClassView.MAX_BUTTONS_PER_VIEW} reached`
      );
    }
    if (this.props.buttons.some((b) => b.id.equals(button.id))) {
      return Result.fail("Button already exists in this view");
    }
    if (this.props.buttons.some((b) => b.order === button.order)) {
      return Result.fail(`Button with order ${button.order} already exists`);
    }
    this.props.buttons.push(button);
    this.addDomainEvent({
      aggregateId: this.id.toString(),
      eventType: "ButtonAddedToClassView",
      eventData: {
        classViewId: this.id.toString(),
        className: this.className.value,
        buttonId: button.id.toString(),
        buttonLabel: button.label
      }
    });
    return Result.ok();
  }
  /**
   * Remove a button from the view
   */
  removeButton(buttonId) {
    const buttonIndex = this.props.buttons.findIndex((b) => b.id.equals(buttonId));
    if (buttonIndex === -1) {
      return Result.fail("Button not found in this view");
    }
    const removedButton = this.props.buttons.splice(buttonIndex, 1)[0];
    this.addDomainEvent({
      aggregateId: this.id.toString(),
      eventType: "ButtonRemovedFromClassView",
      eventData: {
        classViewId: this.id.toString(),
        className: this.className.value,
        buttonId: removedButton.id.toString()
      }
    });
    return Result.ok();
  }
  /**
   * Reorder buttons
   */
  reorderButtons(buttonOrders) {
    for (const button of this.props.buttons) {
      if (!buttonOrders.has(button.id.toString())) {
        return Result.fail(`Missing order for button ${button.id.toString()}`);
      }
    }
    const orders = Array.from(buttonOrders.values());
    const uniqueOrders = new Set(orders);
    if (uniqueOrders.size !== orders.length) {
      return Result.fail("Duplicate order values not allowed");
    }
    for (const button of this.props.buttons) {
      const newOrder = buttonOrders.get(button.id.toString());
      if (newOrder !== void 0) {
        Object.defineProperty(button, "order", { value: newOrder });
      }
    }
    this.addDomainEvent({
      aggregateId: this.id.toString(),
      eventType: "ButtonsReordered",
      eventData: {
        classViewId: this.id.toString(),
        className: this.className.value,
        newOrder: Array.from(buttonOrders.entries())
      }
    });
    return Result.ok();
  }
  /**
   * Update display options
   */
  updateDisplayOptions(options) {
    this.props.displayOptions = {
      ...this.displayOptions,
      ...options
    };
    this.addDomainEvent({
      aggregateId: this.id.toString(),
      eventType: "DisplayOptionsUpdated",
      eventData: {
        classViewId: this.id.toString(),
        className: this.className.value,
        displayOptions: this.props.displayOptions
      }
    });
    return Result.ok();
  }
  /**
   * Get enabled buttons only
   */
  getEnabledButtons() {
    return this.buttons.filter((b) => b.isEnabled);
  }
  /**
   * Check if view has any executable buttons
   */
  hasExecutableButtons() {
    return this.getEnabledButtons().length > 0 && this.displayOptions.showButtons;
  }
  /**
   * Find button by ID
   */
  findButton(buttonId) {
    return this.props.buttons.find((b) => b.id.equals(buttonId));
  }
};
var ClassView = _ClassView;
ClassView.MAX_BUTTONS_PER_VIEW = 20;

// src/domain/entities/UIButton.ts
var UIButton = class extends Entity {
  constructor(props) {
    super(props);
  }
  /**
   * Factory method following DDD pattern
   */
  static create(props) {
    var _a, _b;
    if (!props.label || props.label.trim().length === 0) {
      return Result.fail("Button label cannot be empty");
    }
    if (props.label.length > 100) {
      return Result.fail("Button label cannot exceed 100 characters");
    }
    if (!props.commandId) {
      return Result.fail("Button must have an associated command");
    }
    return Result.ok(new UIButton({
      ...props,
      isEnabled: (_a = props.isEnabled) != null ? _a : true,
      order: (_b = props.order) != null ? _b : 0
    }));
  }
  // Getters following encapsulation principle
  get id() {
    return this.props.id;
  }
  get label() {
    return this.props.label;
  }
  get commandId() {
    return this.props.commandId;
  }
  get order() {
    var _a;
    return (_a = this.props.order) != null ? _a : 0;
  }
  get isEnabled() {
    var _a;
    return (_a = this.props.isEnabled) != null ? _a : true;
  }
  get tooltip() {
    return this.props.tooltip;
  }
  /**
   * Business logic - button can be clicked only if enabled
   */
  canExecute() {
    return this.isEnabled;
  }
  /**
   * Domain event when button is clicked
   */
  click() {
    if (!this.canExecute()) {
      return Result.fail("Button is disabled and cannot be clicked");
    }
    this.addDomainEvent({
      aggregateId: this.id.toString(),
      eventType: "ButtonClicked",
      eventData: {
        buttonId: this.id.toString(),
        commandId: this.commandId.toString(),
        label: this.label
      }
    });
    return Result.ok();
  }
  /**
   * Business logic to update button state
   */
  enable() {
    this.props.isEnabled = true;
  }
  disable() {
    this.props.isEnabled = false;
  }
  updateLabel(newLabel) {
    if (!newLabel || newLabel.trim().length === 0) {
      return Result.fail("Button label cannot be empty");
    }
    if (newLabel.length > 100) {
      return Result.fail("Button label cannot exceed 100 characters");
    }
    this.props.label = newLabel;
    return Result.ok();
  }
};

// src/infrastructure/repositories/ObsidianClassViewRepository.ts
var ObsidianClassViewRepository = class {
  constructor(app) {
    this.app = app;
  }
  async findByClassName(className) {
    try {
      const files = this.app.vault.getMarkdownFiles();
      for (const file of files) {
        const metadata = this.app.metadataCache.getFileCache(file);
        if (!(metadata == null ? void 0 : metadata.frontmatter))
          continue;
        const instanceClass = metadata.frontmatter["exo__Instance_class"];
        if (instanceClass !== "[[ui__ClassView]]")
          continue;
        const targetClass = metadata.frontmatter["ui__ClassView_targetClass"];
        if (!targetClass)
          continue;
        const cleanTargetClass = this.cleanAssetReference(targetClass);
        if (cleanTargetClass !== className.value)
          continue;
        return this.buildClassViewFromFile(file);
      }
      return Result.ok(null);
    } catch (error) {
      return Result.fail(`Failed to find ClassView: ${error.message}`);
    }
  }
  async findById(id) {
    try {
      const file = this.app.vault.getAbstractFileByPath(id.toString() + ".md");
      if (!file || !(file instanceof import_obsidian8.TFile)) {
        return Result.ok(null);
      }
      return this.buildClassViewFromFile(file);
    } catch (error) {
      return Result.fail(`Failed to find ClassView by ID: ${error.message}`);
    }
  }
  async save(classView) {
    try {
      const filePath = `${classView.id.toString()}.md`;
      const content = this.serializeClassView(classView);
      const existingFile = this.app.vault.getAbstractFileByPath(filePath);
      if (existingFile instanceof import_obsidian8.TFile) {
        await this.app.vault.modify(existingFile, content);
      } else {
        await this.app.vault.create(filePath, content);
      }
      return Result.ok();
    } catch (error) {
      return Result.fail(`Failed to save ClassView: ${error.message}`);
    }
  }
  async delete(id) {
    try {
      const file = this.app.vault.getAbstractFileByPath(id.toString() + ".md");
      if (file instanceof import_obsidian8.TFile) {
        await this.app.vault.delete(file);
      }
      return Result.ok();
    } catch (error) {
      return Result.fail(`Failed to delete ClassView: ${error.message}`);
    }
  }
  async findAll() {
    try {
      const classViews = [];
      const files = this.app.vault.getMarkdownFiles();
      for (const file of files) {
        const metadata = this.app.metadataCache.getFileCache(file);
        if (!(metadata == null ? void 0 : metadata.frontmatter))
          continue;
        const instanceClass = metadata.frontmatter["exo__Instance_class"];
        if (instanceClass !== "[[ui__ClassView]]")
          continue;
        const result = await this.buildClassViewFromFile(file);
        if (result.isSuccess && result.getValue()) {
          classViews.push(result.getValue());
        }
      }
      return Result.ok(classViews);
    } catch (error) {
      return Result.fail(`Failed to find all ClassViews: ${error.message}`);
    }
  }
  async exists(className) {
    const result = await this.findByClassName(className);
    if (result.isFailure) {
      return Result.fail(result.error);
    }
    return Result.ok(result.getValue() !== null);
  }
  async buildClassViewFromFile(file) {
    try {
      const metadata = this.app.metadataCache.getFileCache(file);
      if (!(metadata == null ? void 0 : metadata.frontmatter)) {
        return Result.ok(null);
      }
      const fm = metadata.frontmatter;
      const targetClass = fm["ui__ClassView_targetClass"];
      if (!targetClass) {
        return Result.ok(null);
      }
      const classNameResult = ClassName.create(this.cleanAssetReference(targetClass));
      if (classNameResult.isFailure) {
        return Result.fail(classNameResult.error);
      }
      const buttonRefs = fm["ui__ClassView_buttons"] || [];
      const buttons = [];
      for (const buttonRef of this.ensureArray(buttonRefs)) {
        const buttonResult = await this.loadButton(this.cleanAssetReference(buttonRef));
        if (buttonResult.isSuccess && buttonResult.getValue()) {
          buttons.push(buttonResult.getValue());
        }
      }
      const displayOptions = {
        showProperties: fm["ui__ClassView_showProperties"] !== false,
        showRelations: fm["ui__ClassView_showRelations"] !== false,
        showBacklinks: fm["ui__ClassView_showBacklinks"] !== false,
        showButtons: fm["ui__ClassView_showButtons"] !== false,
        buttonPosition: fm["ui__ClassView_buttonPosition"] || "top"
      };
      const idResult = AssetId.create(file.basename);
      if (idResult.isFailure) {
        return Result.fail(idResult.error);
      }
      const classViewResult = ClassView.create({
        id: idResult.getValue(),
        className: classNameResult.getValue(),
        buttons,
        layoutTemplate: fm["ui__ClassView_template"],
        displayOptions
      });
      if (classViewResult.isFailure) {
        return Result.fail(classViewResult.error);
      }
      return Result.ok(classViewResult.getValue());
    } catch (error) {
      return Result.fail(`Failed to build ClassView: ${error.message}`);
    }
  }
  async loadButton(buttonName) {
    try {
      const file = this.app.vault.getAbstractFileByPath(buttonName + ".md");
      if (!file || !(file instanceof import_obsidian8.TFile)) {
        return Result.ok(null);
      }
      const metadata = this.app.metadataCache.getFileCache(file);
      if (!(metadata == null ? void 0 : metadata.frontmatter)) {
        return Result.ok(null);
      }
      const fm = metadata.frontmatter;
      const idResult = AssetId.create(file.basename);
      const commandIdResult = AssetId.create(
        this.cleanAssetReference(fm["ui__Button_command"] || "")
      );
      if (idResult.isFailure || commandIdResult.isFailure) {
        return Result.ok(null);
      }
      const buttonResult = UIButton.create({
        id: idResult.getValue(),
        label: fm["ui__Button_label"] || file.basename,
        commandId: commandIdResult.getValue(),
        order: fm["ui__Button_order"] || 0,
        isEnabled: fm["ui__Button_enabled"] !== false,
        tooltip: fm["ui__Button_tooltip"]
      });
      if (buttonResult.isFailure) {
        return Result.fail(buttonResult.error);
      }
      return Result.ok(buttonResult.getValue());
    } catch (error) {
      return Result.fail(`Failed to load button: ${error.message}`);
    }
  }
  serializeClassView(classView) {
    const frontmatter = {
      "exo__Instance_class": "[[ui__ClassView]]",
      "ui__ClassView_targetClass": `[[${classView.className.value}]]`,
      "ui__ClassView_buttons": classView.buttons.map((b) => `[[${b.id.toString()}]]`),
      "ui__ClassView_showProperties": classView.displayOptions.showProperties,
      "ui__ClassView_showRelations": classView.displayOptions.showRelations,
      "ui__ClassView_showBacklinks": classView.displayOptions.showBacklinks,
      "ui__ClassView_showButtons": classView.displayOptions.showButtons,
      "ui__ClassView_buttonPosition": classView.displayOptions.buttonPosition
    };
    const yamlContent = this.toYaml(frontmatter);
    return `---
${yamlContent}---

# ClassView: ${classView.className.value}
`;
  }
  cleanAssetReference(ref) {
    if (typeof ref !== "string")
      return "";
    return ref.replace(/\[\[|\]\]/g, "").trim();
  }
  ensureArray(value) {
    if (Array.isArray(value))
      return value;
    if (value)
      return [value];
    return [];
  }
  toYaml(obj) {
    return Object.entries(obj).map(([key, value]) => {
      if (Array.isArray(value)) {
        return `${key}:
${value.map((v) => `  - ${v}`).join("\n")}`;
      }
      return `${key}: ${value}`;
    }).join("\n") + "\n";
  }
};

// src/infrastructure/repositories/ObsidianButtonRepository.ts
var import_obsidian9 = require("obsidian");

// src/domain/entities/ButtonCommand.ts
var CommandType = /* @__PURE__ */ ((CommandType2) => {
  CommandType2["CREATE_ASSET"] = "CREATE_ASSET";
  CommandType2["OPEN_ASSET"] = "OPEN_ASSET";
  CommandType2["DELETE_ASSET"] = "DELETE_ASSET";
  CommandType2["RUN_TEMPLATE"] = "RUN_TEMPLATE";
  CommandType2["EXECUTE_SEARCH"] = "EXECUTE_SEARCH";
  CommandType2["TRIGGER_WORKFLOW"] = "TRIGGER_WORKFLOW";
  CommandType2["CUSTOM"] = "CUSTOM";
  return CommandType2;
})(CommandType || {});
var ButtonCommand = class extends Entity {
  constructor(props) {
    super(props);
  }
  /**
   * Factory method with validation
   */
  static create(props) {
    if (!props.name || props.name.trim().length === 0) {
      return Result.fail("Command name cannot be empty");
    }
    if (props.requiresInput && (!props.parameters || props.parameters.length === 0)) {
      return Result.fail("Commands requiring input must define parameters");
    }
    for (const param of props.parameters) {
      if (!param.name || param.name.trim().length === 0) {
        return Result.fail("Parameter name cannot be empty");
      }
      if (param.validation) {
        try {
          new RegExp(param.validation);
        } catch (e) {
          return Result.fail(`Invalid validation regex for parameter ${param.name}`);
        }
      }
    }
    if (props.type === "RUN_TEMPLATE" /* RUN_TEMPLATE */ && !props.template) {
      return Result.fail("Template commands must specify a template");
    }
    if (props.type === "CUSTOM" /* CUSTOM */ && !props.script) {
      return Result.fail("Custom commands must specify a script");
    }
    return Result.ok(new ButtonCommand(props));
  }
  // Getters
  get id() {
    return this.props.id;
  }
  get type() {
    return this.props.type;
  }
  get name() {
    return this.props.name;
  }
  get description() {
    return this.props.description;
  }
  get requiresInput() {
    return this.props.requiresInput;
  }
  get parameters() {
    return this.props.parameters;
  }
  get targetClass() {
    return this.props.targetClass;
  }
  get template() {
    return this.props.template;
  }
  get script() {
    return this.props.script;
  }
  /**
   * Validate input parameters against command definition
   */
  validateInput(input) {
    const validated = {};
    const errors = [];
    for (const param of this.parameters) {
      const value = input[param.name];
      if (param.required && (value === void 0 || value === null || value === "")) {
        errors.push(`Required parameter '${param.name}' is missing`);
        continue;
      }
      if (!param.required && (value === void 0 || value === null)) {
        if (param.defaultValue !== void 0) {
          validated[param.name] = param.defaultValue;
        }
        continue;
      }
      if (!this.validateParameterType(value, param.type)) {
        errors.push(`Parameter '${param.name}' must be of type ${param.type}`);
        continue;
      }
      if (param.validation) {
        const regex = new RegExp(param.validation);
        if (!regex.test(String(value))) {
          errors.push(`Parameter '${param.name}' does not match validation pattern`);
          continue;
        }
      }
      validated[param.name] = value;
    }
    if (errors.length > 0) {
      return Result.fail(errors.join("; "));
    }
    return Result.ok(validated);
  }
  /**
   * Check if command can be executed in current context
   */
  canExecute(context) {
    if (this.targetClass && context.currentClass !== this.targetClass) {
      return false;
    }
    if (this.type === "DELETE_ASSET" /* DELETE_ASSET */ && !context.hasSelection) {
      return false;
    }
    return true;
  }
  /**
   * Build execution context for the command
   */
  buildExecutionContext(input) {
    const validationResult = this.validateInput(input);
    if (validationResult.isFailure) {
      return Result.fail(validationResult.error);
    }
    const context = {
      commandId: this.id.toString(),
      commandType: this.type,
      parameters: validationResult.getValue(),
      timestamp: new Date(),
      template: this.props.template,
      script: this.props.script,
      targetClass: this.props.targetClass
    };
    return Result.ok(context);
  }
  validateParameterType(value, type) {
    switch (type) {
      case "string":
        return typeof value === "string";
      case "number":
        return typeof value === "number" || !isNaN(Number(value));
      case "boolean":
        return typeof value === "boolean" || value === "true" || value === "false";
      case "date":
        return !isNaN(Date.parse(String(value)));
      case "asset":
        return typeof value === "string" && value.startsWith("[[") && value.endsWith("]]");
      case "array":
        return Array.isArray(value) || typeof value === "string";
      default:
        return true;
    }
  }
};

// src/infrastructure/repositories/ObsidianButtonRepository.ts
var ObsidianButtonRepository = class {
  constructor(app) {
    this.app = app;
  }
  async findButtonById(id) {
    try {
      const file = this.app.vault.getAbstractFileByPath(id.toString() + ".md");
      if (!file || !(file instanceof import_obsidian9.TFile)) {
        return Result.ok(null);
      }
      return this.buildButtonFromFile(file);
    } catch (error) {
      return Result.fail(`Failed to find button: ${error.message}`);
    }
  }
  async findCommandById(id) {
    try {
      const file = this.app.vault.getAbstractFileByPath(id.toString() + ".md");
      if (!file || !(file instanceof import_obsidian9.TFile)) {
        return Result.ok(null);
      }
      return this.buildCommandFromFile(file);
    } catch (error) {
      return Result.fail(`Failed to find command: ${error.message}`);
    }
  }
  async findAllButtons() {
    try {
      const buttons = [];
      const files = this.app.vault.getMarkdownFiles();
      for (const file of files) {
        const metadata = this.app.metadataCache.getFileCache(file);
        if (!(metadata == null ? void 0 : metadata.frontmatter))
          continue;
        const instanceClass = metadata.frontmatter["exo__Instance_class"];
        if (instanceClass !== "[[ui__Button]]")
          continue;
        const buttonResult = await this.buildButtonFromFile(file);
        if (buttonResult.isSuccess && buttonResult.getValue()) {
          buttons.push(buttonResult.getValue());
        }
      }
      return Result.ok(buttons);
    } catch (error) {
      return Result.fail(`Failed to find buttons: ${error.message}`);
    }
  }
  async findAllCommands() {
    try {
      const commands = [];
      const files = this.app.vault.getMarkdownFiles();
      for (const file of files) {
        const metadata = this.app.metadataCache.getFileCache(file);
        if (!(metadata == null ? void 0 : metadata.frontmatter))
          continue;
        const instanceClass = metadata.frontmatter["exo__Instance_class"];
        if (instanceClass !== "[[ui__ButtonCommand]]")
          continue;
        const commandResult = await this.buildCommandFromFile(file);
        if (commandResult.isSuccess && commandResult.getValue()) {
          commands.push(commandResult.getValue());
        }
      }
      return Result.ok(commands);
    } catch (error) {
      return Result.fail(`Failed to find commands: ${error.message}`);
    }
  }
  async findButtonsByCommandId(commandId) {
    try {
      const buttons = [];
      const allButtonsResult = await this.findAllButtons();
      if (allButtonsResult.isFailure) {
        return Result.fail(allButtonsResult.error);
      }
      const allButtons = allButtonsResult.getValue();
      for (const button of allButtons) {
        if (button.commandId.equals(commandId)) {
          buttons.push(button);
        }
      }
      return Result.ok(buttons);
    } catch (error) {
      return Result.fail(`Failed to find buttons by command: ${error.message}`);
    }
  }
  async saveButton(button) {
    try {
      const filePath = `${button.id.toString()}.md`;
      const content = this.serializeButton(button);
      const existingFile = this.app.vault.getAbstractFileByPath(filePath);
      if (existingFile instanceof import_obsidian9.TFile) {
        await this.app.vault.modify(existingFile, content);
      } else {
        await this.app.vault.create(filePath, content);
      }
      return Result.ok();
    } catch (error) {
      return Result.fail(`Failed to save button: ${error.message}`);
    }
  }
  async saveCommand(command) {
    try {
      const filePath = `${command.id.toString()}.md`;
      const content = this.serializeCommand(command);
      const existingFile = this.app.vault.getAbstractFileByPath(filePath);
      if (existingFile instanceof import_obsidian9.TFile) {
        await this.app.vault.modify(existingFile, content);
      } else {
        await this.app.vault.create(filePath, content);
      }
      return Result.ok();
    } catch (error) {
      return Result.fail(`Failed to save command: ${error.message}`);
    }
  }
  async deleteButton(id) {
    try {
      const file = this.app.vault.getAbstractFileByPath(id.toString() + ".md");
      if (file instanceof import_obsidian9.TFile) {
        await this.app.vault.delete(file);
      }
      return Result.ok();
    } catch (error) {
      return Result.fail(`Failed to delete button: ${error.message}`);
    }
  }
  async deleteCommand(id) {
    try {
      const file = this.app.vault.getAbstractFileByPath(id.toString() + ".md");
      if (file instanceof import_obsidian9.TFile) {
        await this.app.vault.delete(file);
      }
      return Result.ok();
    } catch (error) {
      return Result.fail(`Failed to delete command: ${error.message}`);
    }
  }
  async buildButtonFromFile(file) {
    try {
      const metadata = this.app.metadataCache.getFileCache(file);
      if (!(metadata == null ? void 0 : metadata.frontmatter)) {
        return Result.ok(null);
      }
      const fm = metadata.frontmatter;
      const idResult = AssetId.create(file.basename);
      const commandIdResult = AssetId.create(
        this.cleanAssetReference(fm["ui__Button_command"] || "")
      );
      if (idResult.isFailure || commandIdResult.isFailure) {
        return Result.ok(null);
      }
      const buttonResult = UIButton.create({
        id: idResult.getValue(),
        label: fm["ui__Button_label"] || file.basename,
        commandId: commandIdResult.getValue(),
        order: fm["ui__Button_order"] || 0,
        isEnabled: fm["ui__Button_enabled"] !== false,
        tooltip: fm["ui__Button_tooltip"]
      });
      if (buttonResult.isFailure) {
        return Result.fail(buttonResult.error);
      }
      return Result.ok(buttonResult.getValue());
    } catch (error) {
      return Result.fail(`Failed to build button: ${error.message}`);
    }
  }
  async buildCommandFromFile(file) {
    try {
      const metadata = this.app.metadataCache.getFileCache(file);
      if (!(metadata == null ? void 0 : metadata.frontmatter)) {
        return Result.ok(null);
      }
      const fm = metadata.frontmatter;
      const idResult = AssetId.create(file.basename);
      if (idResult.isFailure) {
        return Result.ok(null);
      }
      const typeString = fm["ui__Command_type"] || "CUSTOM";
      const type = this.parseCommandType(typeString);
      const parameters = this.parseParameters(fm["ui__Command_parameters"]);
      const commandResult = ButtonCommand.create({
        id: idResult.getValue(),
        type,
        name: fm["ui__Command_name"] || file.basename,
        description: fm["ui__Command_description"],
        requiresInput: fm["ui__Command_requiresInput"] === true,
        parameters,
        targetClass: this.cleanAssetReference(fm["ui__Command_targetClass"]),
        template: fm["ui__Command_template"],
        script: fm["ui__Command_script"]
      });
      if (commandResult.isFailure) {
        return Result.fail(commandResult.error);
      }
      return Result.ok(commandResult.getValue());
    } catch (error) {
      return Result.fail(`Failed to build command: ${error.message}`);
    }
  }
  parseCommandType(typeString) {
    const upperType = typeString.toUpperCase();
    return CommandType[upperType] || "CUSTOM" /* CUSTOM */;
  }
  parseParameters(paramsData) {
    if (!paramsData)
      return [];
    const params = [];
    const paramArray = this.ensureArray(paramsData);
    for (const param of paramArray) {
      if (typeof param === "object" && param.name) {
        params.push({
          name: param.name,
          type: param.type || "string",
          required: param.required === true,
          defaultValue: param.defaultValue,
          label: param.label,
          description: param.description,
          validation: param.validation
        });
      }
    }
    return params;
  }
  serializeButton(button) {
    const frontmatter = {
      "exo__Instance_class": "[[ui__Button]]",
      "ui__Button_label": button.label,
      "ui__Button_command": `[[${button.commandId.toString()}]]`,
      "ui__Button_order": button.order,
      "ui__Button_enabled": button.isEnabled,
      "ui__Button_tooltip": button.tooltip
    };
    const yamlContent = this.toYaml(frontmatter);
    return `---
${yamlContent}---

# Button: ${button.label}
`;
  }
  serializeCommand(command) {
    const frontmatter = {
      "exo__Instance_class": "[[ui__ButtonCommand]]",
      "ui__Command_type": command.type,
      "ui__Command_name": command.name,
      "ui__Command_description": command.description,
      "ui__Command_requiresInput": command.requiresInput,
      "ui__Command_parameters": command.parameters,
      "ui__Command_targetClass": command.targetClass ? `[[${command.targetClass}]]` : null,
      "ui__Command_template": command.template,
      "ui__Command_script": command.script
    };
    const yamlContent = this.toYaml(frontmatter);
    return `---
${yamlContent}---

# Command: ${command.name}
`;
  }
  cleanAssetReference(ref) {
    if (typeof ref !== "string")
      return "";
    return ref.replace(/\[\[|\]\]/g, "").trim();
  }
  ensureArray(value) {
    if (Array.isArray(value))
      return value;
    if (value)
      return [value];
    return [];
  }
  toYaml(obj) {
    return Object.entries(obj).filter(([_, value]) => value !== null && value !== void 0).map(([key, value]) => {
      if (Array.isArray(value)) {
        if (value.length === 0)
          return `${key}: []`;
        return `${key}:
${value.map((v) => `  - ${JSON.stringify(v)}`).join("\n")}`;
      }
      if (typeof value === "object") {
        return `${key}: ${JSON.stringify(value)}`;
      }
      return `${key}: ${value}`;
    }).join("\n") + "\n";
  }
};

// src/domain/entities/ClassLayout.ts
var _ClassLayout = class extends Entity {
  constructor(props) {
    super(props);
  }
  static create(props) {
    if (!props.targetClass) {
      return Result.fail("Target class is required");
    }
    if (props.blocks.length > _ClassLayout.MAX_BLOCKS) {
      return Result.fail(`Cannot have more than ${_ClassLayout.MAX_BLOCKS} blocks`);
    }
    const orders = props.blocks.map((b) => b.order);
    const uniqueOrders = new Set(orders);
    if (uniqueOrders.size !== orders.length) {
      return Result.fail("Blocks cannot have duplicate order values");
    }
    return Result.ok(new _ClassLayout(props));
  }
  get id() {
    return this.props.id;
  }
  get targetClass() {
    return this.props.targetClass;
  }
  get blocks() {
    return [...this.props.blocks].sort((a, b) => a.order - b.order);
  }
  get isEnabled() {
    return this.props.isEnabled;
  }
  get priority() {
    return this.props.priority;
  }
  addBlock(block) {
    if (this.props.blocks.length >= _ClassLayout.MAX_BLOCKS) {
      return Result.fail(`Cannot add more blocks. Maximum of ${_ClassLayout.MAX_BLOCKS} reached`);
    }
    if (this.props.blocks.some((b) => b.id === block.id)) {
      return Result.fail("Block with this ID already exists");
    }
    if (this.props.blocks.some((b) => b.order === block.order)) {
      return Result.fail(`Block with order ${block.order} already exists`);
    }
    this.props.blocks.push(block);
    return Result.ok();
  }
  removeBlock(blockId) {
    const blockIndex = this.props.blocks.findIndex((b) => b.id === blockId);
    if (blockIndex === -1) {
      return Result.fail("Block not found");
    }
    this.props.blocks.splice(blockIndex, 1);
    return Result.ok();
  }
  updateBlock(blockId, updates) {
    const block = this.props.blocks.find((b) => b.id === blockId);
    if (!block) {
      return Result.fail("Block not found");
    }
    if (updates.order !== void 0 && updates.order !== block.order) {
      if (this.props.blocks.some((b) => b.id !== blockId && b.order === updates.order)) {
        return Result.fail(`Block with order ${updates.order} already exists`);
      }
    }
    Object.assign(block, updates);
    return Result.ok();
  }
  getVisibleBlocks() {
    return this.blocks.filter((b) => b.isVisible);
  }
  enable() {
    this.props.isEnabled = true;
  }
  disable() {
    this.props.isEnabled = false;
  }
};
var ClassLayout = _ClassLayout;
ClassLayout.MAX_BLOCKS = 20;

// src/infrastructure/repositories/ObsidianClassLayoutRepository.ts
var ObsidianClassLayoutRepository = class {
  // 30 seconds
  constructor(app, layoutsFolderPath = "layouts") {
    this.app = app;
    this.layoutsFolderPath = layoutsFolderPath;
    this.cache = /* @__PURE__ */ new Map();
    this.lastCacheUpdate = 0;
    this.CACHE_TTL = 3e4;
  }
  async findByClass(className) {
    await this.refreshCacheIfNeeded();
    const allLayouts = Array.from(this.cache.values()).flat();
    const matchingLayouts = allLayouts.filter(
      (layout) => layout.targetClass.equals(className) && layout.isEnabled
    );
    return matchingLayouts.sort((a, b) => b.priority - a.priority);
  }
  async findById(id) {
    await this.refreshCacheIfNeeded();
    const allLayouts = Array.from(this.cache.values()).flat();
    return allLayouts.find((layout) => layout.id.equals(id)) || null;
  }
  async findAll() {
    await this.refreshCacheIfNeeded();
    return Array.from(this.cache.values()).flat();
  }
  async findEnabledByClass(className) {
    const layouts = await this.findByClass(className);
    return layouts.filter((l) => l.isEnabled);
  }
  async save(layout) {
    const className = layout.targetClass.value;
    const existing = this.cache.get(className) || [];
    const index = existing.findIndex((l) => l.id.equals(layout.id));
    if (index >= 0) {
      existing[index] = layout;
    } else {
      existing.push(layout);
    }
    this.cache.set(className, existing);
  }
  async delete(id) {
    for (const [className, layouts] of this.cache.entries()) {
      const filtered = layouts.filter((l) => !l.id.equals(id));
      if (filtered.length !== layouts.length) {
        this.cache.set(className, filtered);
      }
    }
  }
  async refreshCacheIfNeeded() {
    const now = Date.now();
    if (now - this.lastCacheUpdate < this.CACHE_TTL) {
      return;
    }
    await this.loadLayoutsFromFiles();
    this.lastCacheUpdate = now;
  }
  async loadLayoutsFromFiles() {
    this.cache.clear();
    const files = this.app.vault.getFiles();
    const layoutFiles = files.filter(
      (file) => file.path.startsWith(this.layoutsFolderPath + "/") || this.isLayoutFile(file)
    );
    for (const file of layoutFiles) {
      const layout = await this.parseLayoutFile(file);
      if (layout) {
        const className = layout.targetClass.value;
        const existing = this.cache.get(className) || [];
        existing.push(layout);
        this.cache.set(className, existing);
      }
    }
  }
  isLayoutFile(file) {
    const metadata = this.app.metadataCache.getFileCache(file);
    if (!(metadata == null ? void 0 : metadata.frontmatter))
      return false;
    const instanceClass = metadata.frontmatter["exo__Instance_class"];
    const cleanClass = this.cleanClassName(instanceClass);
    return cleanClass === "ui__ClassLayout";
  }
  async parseLayoutFile(file) {
    const metadata = this.app.metadataCache.getFileCache(file);
    if (!(metadata == null ? void 0 : metadata.frontmatter))
      return null;
    const frontmatter = metadata.frontmatter;
    const instanceClass = frontmatter["exo__Instance_class"];
    if (this.cleanClassName(instanceClass) !== "ui__ClassLayout") {
      return null;
    }
    const targetClass = frontmatter["ui__ClassLayout_targetClass"];
    if (!targetClass)
      return null;
    const cleanTargetClass = this.cleanClassName(targetClass);
    const targetClassName = ClassName.create(cleanTargetClass);
    if (targetClassName.isFailure)
      return null;
    const blocks = this.parseBlocks(frontmatter["ui__ClassLayout_blocks"] || []);
    const priority = frontmatter["ui__ClassLayout_priority"] || 0;
    const isEnabled = frontmatter["ui__ClassLayout_enabled"] !== false;
    const assetId = AssetId.create(
      frontmatter["exo__Asset_uid"] || file.path
    );
    if (assetId.isFailure)
      return null;
    const layoutResult = ClassLayout.create({
      id: assetId.getValue(),
      targetClass: targetClassName.getValue(),
      blocks,
      isEnabled,
      priority
    });
    return layoutResult.isSuccess ? layoutResult.getValue() : null;
  }
  parseBlocks(blocksData) {
    if (!Array.isArray(blocksData))
      return [];
    return blocksData.map((blockData, index) => {
      var _a;
      const block = {
        id: blockData.id || `block-${index}`,
        type: blockData.type || "properties",
        title: blockData.title || "Untitled Block",
        order: (_a = blockData.order) != null ? _a : index,
        config: this.parseBlockConfig(blockData.type, blockData.config || {}),
        isVisible: blockData.isVisible !== false
      };
      return block;
    }).filter((b) => b !== null);
  }
  parseBlockConfig(type, config) {
    const baseConfig = { type, ...config };
    switch (type) {
      case "query":
        return {
          type: "query",
          query: config.query || "",
          className: config.className,
          propertyFilters: this.parsePropertyFilters(config.propertyFilters),
          relationProperty: config.relationProperty,
          maxResults: config.maxResults || 50,
          sortBy: config.sortBy,
          sortOrder: config.sortOrder || "asc",
          displayAs: config.displayAs || "list"
        };
      case "properties":
        return {
          type: "properties",
          includedProperties: config.includedProperties || [],
          excludedProperties: config.excludedProperties || [],
          editableProperties: config.editableProperties || [],
          groupBy: config.groupBy
        };
      case "relations":
        return {
          type: "relations",
          relationProperty: config.relationProperty || "",
          showBacklinks: config.showBacklinks !== false,
          showForwardLinks: config.showForwardLinks !== false,
          maxDepth: config.maxDepth || 1
        };
      case "backlinks":
        return {
          type: "backlinks",
          filterByClass: config.filterByClass,
          groupByClass: config.groupByClass || false,
          maxResults: config.maxResults || 50
        };
      case "custom":
        return {
          type: "custom",
          templatePath: config.templatePath,
          dataviewQuery: config.dataviewQuery,
          customScript: config.customScript
        };
      default:
        return baseConfig;
    }
  }
  parsePropertyFilters(filters) {
    if (!Array.isArray(filters))
      return [];
    return filters.map((filter) => ({
      property: filter.property || "",
      operator: filter.operator || "equals",
      value: filter.value || ""
    }));
  }
  cleanClassName(className) {
    if (!className)
      return "";
    const str = Array.isArray(className) ? className[0] : className;
    return (str == null ? void 0 : str.toString().replace(/\[\[|\]\]/g, "")) || "";
  }
};

// src/application/use-cases/CreateAssetUseCase.ts
var CreateAssetUseCase = class {
  constructor(assetRepository, ontologyRepository) {
    this.assetRepository = assetRepository;
    this.ontologyRepository = ontologyRepository;
  }
  async execute(request) {
    this.validateRequest(request);
    const ontologyPrefixResult = OntologyPrefix.create(request.ontologyPrefix);
    if (ontologyPrefixResult.isFailure) {
      throw new Error(ontologyPrefixResult.error);
    }
    const ontologyPrefix = ontologyPrefixResult.getValue();
    const ontology = await this.ontologyRepository.findByPrefix(ontologyPrefix);
    if (!ontology) {
      throw new Error(`Ontology ${request.ontologyPrefix} not found`);
    }
    const classNameResult = ClassName.create(request.className);
    if (classNameResult.isFailure) {
      throw new Error(classNameResult.error);
    }
    const className = classNameResult.getValue();
    const assetResult = Asset.create({
      id: AssetId.generate(),
      label: request.title,
      className,
      ontology: ontologyPrefix,
      properties: request.properties || {}
    });
    if (assetResult.isFailure) {
      throw new Error(assetResult.error);
    }
    const asset = assetResult.getValue();
    await this.assetRepository.save(asset);
    return {
      success: true,
      assetId: asset.getId().toString(),
      message: `Created asset: ${asset.getTitle()}`
    };
  }
  validateRequest(request) {
    if (!request.title || request.title.trim().length === 0) {
      throw new Error("Asset title is required");
    }
    if (!request.className) {
      throw new Error("Asset class is required");
    }
    if (!request.ontologyPrefix) {
      throw new Error("Ontology prefix is required");
    }
  }
};

// src/application/use-cases/RenderClassButtonsUseCase.ts
var RenderClassButtonsUseCase = class {
  constructor(classViewRepository, buttonRepository) {
    this.classViewRepository = classViewRepository;
    this.buttonRepository = buttonRepository;
  }
  async execute(request) {
    var _a;
    if (!request.className) {
      return Result.fail("Class name is required");
    }
    const classNameResult = ClassName.create(request.className);
    if (classNameResult.isFailure) {
      return Result.fail(classNameResult.error);
    }
    const className = classNameResult.getValue();
    const classViewResult = await this.classViewRepository.findByClassName(className);
    if (classViewResult.isFailure) {
      return Result.fail(
        `Failed to load class view: ${classViewResult.error}`
      );
    }
    const classView = classViewResult.getValue();
    if (!classView) {
      return Result.ok({
        buttons: [],
        displayOptions: {
          position: "top",
          showButtons: false
        }
      });
    }
    if (!classView.displayOptions.showButtons) {
      return Result.ok({
        buttons: [],
        displayOptions: {
          position: classView.displayOptions.buttonPosition,
          showButtons: false
        }
      });
    }
    const enabledButtons = classView.getEnabledButtons();
    const buttonRenderData = [];
    for (const button of enabledButtons) {
      const commandResult = await this.buttonRepository.findCommandById(button.commandId);
      if (commandResult.isFailure) {
        console.warn(`Failed to load command for button ${button.id}: ${commandResult.error}`);
        continue;
      }
      const command = commandResult.getValue();
      if (!command) {
        console.warn(`Command not found for button ${button.id}`);
        continue;
      }
      const canExecute = command.canExecute({
        currentClass: request.className,
        hasSelection: ((_a = request.context) == null ? void 0 : _a.hasSelection) || false
      });
      if (canExecute) {
        buttonRenderData.push({
          buttonId: button.id.toString(),
          label: button.label,
          tooltip: button.tooltip,
          isEnabled: button.isEnabled,
          order: button.order,
          command: {
            id: command.id.toString(),
            type: command.type,
            requiresInput: command.requiresInput,
            parameters: command.parameters
          }
        });
      }
    }
    buttonRenderData.sort((a, b) => a.order - b.order);
    return Result.ok({
      buttons: buttonRenderData,
      displayOptions: {
        position: classView.displayOptions.buttonPosition,
        showButtons: true
      }
    });
  }
};

// src/application/use-cases/ExecuteButtonCommandUseCase.ts
var ExecuteButtonCommandUseCase = class {
  constructor(buttonRepository, commandExecutor) {
    this.buttonRepository = buttonRepository;
    this.commandExecutor = commandExecutor;
  }
  async execute(request) {
    var _a, _b, _c;
    if (!request.buttonId) {
      return Result.fail("Button ID is required");
    }
    const buttonIdResult = AssetId.create(request.buttonId);
    if (buttonIdResult.isFailure) {
      return Result.fail("Invalid button ID");
    }
    const buttonId = buttonIdResult.getValue();
    const buttonResult = await this.buttonRepository.findButtonById(buttonId);
    if (buttonResult.isFailure) {
      return Result.fail(
        `Failed to load button: ${buttonResult.error}`
      );
    }
    const button = buttonResult.getValue();
    if (!button) {
      return Result.fail("Button not found");
    }
    if (!button.canExecute()) {
      return Result.fail("Button is disabled");
    }
    const commandResult = await this.buttonRepository.findCommandById(button.commandId);
    if (commandResult.isFailure) {
      return Result.fail(
        `Failed to load command: ${commandResult.error}`
      );
    }
    const command = commandResult.getValue();
    if (!command) {
      return Result.fail("Command not found");
    }
    if (command.requiresInput && !request.inputParameters) {
      return Result.ok({
        success: false,
        requiresInput: true,
        inputSchema: {
          title: command.name,
          description: command.description,
          parameters: command.parameters
        }
      });
    }
    const contextResult = command.buildExecutionContext(
      request.inputParameters || {}
    );
    if (contextResult.isFailure) {
      return Result.fail(
        `Invalid parameters: ${contextResult.error}`
      );
    }
    const executionContext = contextResult.getValue();
    try {
      const executionResult = await this.commandExecutor.execute({
        command,
        context: {
          ...executionContext,
          assetId: request.assetId,
          currentView: (_a = request.context) == null ? void 0 : _a.currentView,
          currentClass: (_b = request.context) == null ? void 0 : _b.currentClass,
          selection: (_c = request.context) == null ? void 0 : _c.selection
        }
      });
      if (executionResult.isFailure) {
        return Result.fail(
          `Command execution failed: ${executionResult.error}`
        );
      }
      const result = executionResult.getValue();
      button.click();
      return Result.ok({
        success: true,
        message: `Command '${command.name}' executed successfully`,
        result
      });
    } catch (error) {
      return Result.fail(
        `Unexpected error during command execution: ${error.message}`
      );
    }
  }
};

// src/application/use-cases/PropertyEditingUseCase.ts
var PropertyEditingUseCase = class {
  constructor(assetRepository, plugin) {
    this.assetRepository = assetRepository;
    this.plugin = plugin;
  }
  async execute(request) {
    if (!request.assetId) {
      return Result.fail("Asset ID is required");
    }
    if (!request.propertyName) {
      return Result.fail("Property name is required");
    }
    const validationResult = this.validatePropertyValue(
      request.value,
      request.propertyDefinition
    );
    if (validationResult.isFailure) {
      return Result.fail(validationResult.error);
    }
    try {
      if (request.assetId.includes("/") || request.assetId.endsWith(".md")) {
        const repo = this.assetRepository;
        if (repo.updateFrontmatterByPath) {
          console.log(`Updating property ${request.propertyName} to ${request.value} for file ${request.assetId}`);
          await repo.updateFrontmatterByPath(request.assetId, {
            [request.propertyName]: request.value
          });
          return Result.ok({
            success: true,
            updatedValue: request.value
          });
        }
      }
      let asset = null;
      const assetIdResult = AssetId.create(request.assetId);
      if (assetIdResult.isSuccess) {
        asset = await this.assetRepository.findById(assetIdResult.getValue());
      }
      if (!asset) {
        asset = await this.assetRepository.findByFilename(request.assetId);
      }
      if (!asset) {
        return Result.fail(`Asset not found: ${request.assetId}`);
      }
      asset.setProperty(request.propertyName, request.value);
      await this.assetRepository.save(asset);
      return Result.ok({
        success: true,
        updatedValue: request.value
      });
    } catch (error) {
      return Result.fail(`Failed to update property: ${error}`);
    }
  }
  /**
   * Validate property value based on its definition
   */
  validatePropertyValue(value, definition) {
    var _a;
    if (definition.isRequired && (value === null || value === void 0 || value === "")) {
      return Result.fail(`${definition.label} is required`);
    }
    if (!definition.isRequired && (value === null || value === void 0 || value === "")) {
      return Result.ok();
    }
    if (definition.range === "number") {
      if (isNaN(Number(value))) {
        return Result.fail(`${definition.label} must be a number`);
      }
    }
    if (definition.range === "date") {
      if (isNaN(Date.parse(value))) {
        return Result.fail(`${definition.label} must be a valid date`);
      }
    }
    if (definition.range === "boolean") {
      if (typeof value !== "boolean") {
        return Result.fail(`${definition.label} must be true or false`);
      }
    }
    if ((_a = definition.range) == null ? void 0 : _a.startsWith("enum:")) {
      const allowedValues = definition.range.substring(5).split(",").map((v) => v.trim());
      if (!allowedValues.includes(value)) {
        return Result.fail(`${definition.label} must be one of: ${allowedValues.join(", ")}`);
      }
    }
    if (definition.validation) {
      try {
        const regex = new RegExp(definition.validation);
        if (!regex.test(String(value))) {
          return Result.fail(`${definition.label} format is invalid`);
        }
      } catch (e) {
      }
    }
    return Result.ok();
  }
  /**
   * Get properties for a class (delegating to plugin for now)
   */
  async getPropertiesForClass(className) {
    try {
      const properties = await this.plugin.findPropertiesForClass(className);
      return Result.ok(properties);
    } catch (error) {
      return Result.fail(`Failed to get properties: ${error.message}`);
    }
  }
  /**
   * Get assets for a class (for dropdowns)
   */
  async getAssetsForClass(className) {
    try {
      const assets = await this.plugin.findAssetsByClass(className, true);
      return Result.ok(assets);
    } catch (error) {
      return Result.fail(`Failed to get assets: ${error.message}`);
    }
  }
};

// src/domain/visual/QueryTemplate.ts
var QueryTemplate = class {
  constructor(params) {
    this.parameterValues = /* @__PURE__ */ new Map();
    this.id = params.id;
    this.metadata = params.metadata;
    this.layout = params.layout;
    this.parameters = (params.parameters || []).map((p) => ({
      ...p,
      id: p.id || `param_${p.name}_${Math.random().toString(36).substr(2, 9)}`
    }));
    this.sparqlTemplate = params.sparqlTemplate || "SELECT * WHERE { ?s ?p ?o }";
    this.isBuiltIn = params.isBuiltIn || false;
    Object.defineProperty(this, "id", {
      value: params.id,
      writable: false,
      configurable: false
    });
    Object.freeze(this.isBuiltIn);
  }
  getId() {
    return this.id;
  }
  getName() {
    return this.metadata.name;
  }
  getDescription() {
    return this.metadata.description;
  }
  getCategory() {
    return this.metadata.category;
  }
  getDifficulty() {
    return this.metadata.difficulty;
  }
  getTags() {
    return [...this.metadata.tags];
  }
  getParameters() {
    return this.parameters.map((p) => ({
      ...p,
      id: p.id || `param_${p.name}`
      // Ensure id exists
    }));
  }
  getLayout() {
    return {
      nodes: this.layout.nodes.map((n) => ({ ...n })),
      edges: this.layout.edges.map((e) => ({ ...e })),
      viewport: this.layout.viewport ? { ...this.layout.viewport } : void 0
    };
  }
  getSparqlTemplate() {
    return this.sparqlTemplate;
  }
  getMetadata() {
    return { ...this.metadata };
  }
  isBuiltInTemplate() {
    return this.isBuiltIn;
  }
  hasParameters() {
    return this.parameters.length > 0;
  }
  getRequiredParameters() {
    return this.parameters.filter((p) => p.required);
  }
  getParameter(id) {
    return this.parameters.find((p) => (p.id || `param_${p.name}`) === id);
  }
  getParameterValues() {
    const values = /* @__PURE__ */ new Map();
    this.parameters.forEach((param) => {
      if (param.defaultValue) {
        values.set(param.id || `param_${param.name}`, param.defaultValue);
      }
    });
    return values;
  }
  validateParameters() {
    const errors = [];
    for (const param of this.getRequiredParameters()) {
      const hasValue = this.parameterValues.has(param.name) || param.defaultValue;
      if (!hasValue) {
        errors.push(`Parameter ${param.name} is required`);
      }
    }
    for (const param of this.parameters) {
      const value = this.parameterValues.get(param.name);
      if (value && param.constraints) {
        if (param.constraints.pattern) {
          const regex = new RegExp(param.constraints.pattern);
          if (!regex.test(value)) {
            errors.push(`Parameter '${param.name}' does not match required pattern`);
          }
        }
        if (param.constraints.minLength && value.length < param.constraints.minLength) {
          errors.push(`Parameter '${param.name}' is too short (min: ${param.constraints.minLength})`);
        }
        if (param.constraints.maxLength && value.length > param.constraints.maxLength) {
          errors.push(`Parameter '${param.name}' is too long (max: ${param.constraints.maxLength})`);
        }
        if (param.constraints.allowedValues && !param.constraints.allowedValues.includes(value)) {
          errors.push(`Parameter '${param.name}' must be one of: ${param.constraints.allowedValues.join(", ")}`);
        }
      }
    }
    return {
      isValid: errors.length === 0,
      errors
    };
  }
  clone(customId) {
    return new QueryTemplate({
      id: customId || `${this.id}_clone_${Date.now()}`,
      metadata: {
        ...this.metadata,
        name: `${this.metadata.name} (Copy)`,
        createdAt: new Date(),
        updatedAt: new Date()
      },
      layout: this.layout,
      parameters: this.parameters,
      sparqlTemplate: this.sparqlTemplate,
      isBuiltIn: false
    });
  }
  instantiate(parameterValues) {
    const errors = [];
    const values = parameterValues || {};
    const allValues = { ...values };
    for (const [key, value] of this.parameterValues) {
      if (!allValues[key]) {
        allValues[key] = value;
      }
    }
    for (const param of this.getRequiredParameters()) {
      const hasValue = allValues[param.name] || param.defaultValue;
      if (!hasValue) {
        errors.push(`Required parameter '${param.name}' is missing`);
      }
    }
    if (errors.length > 0) {
      throw new Error("Template validation failed: " + errors.join(", "));
    }
    const instantiatedLayout = this.replacePlaceholdersInLayout(allValues);
    const instantiatedSparql = this.replacePlaceholdersInSparql(allValues);
    const nodes = instantiatedLayout.nodes.map((nodeData) => ({
      getId: () => nodeData.id,
      getLabel: () => nodeData.label,
      getType: () => nodeData.type,
      getPosition: () => nodeData.position,
      getDimensions: () => nodeData.dimensions || { width: 100, height: 40 },
      getUri: () => nodeData.uri,
      getVariableName: () => nodeData.variableName
    }));
    const edges = instantiatedLayout.edges.map((edgeData) => ({
      getId: () => edgeData.id,
      getLabel: () => edgeData.label,
      getType: () => edgeData.type,
      getSourceNodeId: () => edgeData.sourceNodeId,
      getTargetNodeId: () => edgeData.targetNodeId,
      getPropertyUri: () => edgeData.propertyUri
    }));
    return {
      nodes,
      edges,
      sparql: instantiatedSparql,
      layout: instantiatedLayout,
      errors: []
    };
  }
  replacePlaceholdersInLayout(values) {
    const layout = this.getLayout();
    layout.nodes = layout.nodes.map((node) => {
      const newNode = { ...node };
      newNode.label = this.replacePlaceholders(node.label, values);
      if (node.variableName) {
        newNode.variableName = this.replacePlaceholders(node.variableName, values);
      }
      if (node.uri) {
        newNode.uri = this.replacePlaceholders(node.uri, values);
      }
      return newNode;
    });
    layout.edges = layout.edges.map((edge) => {
      const newEdge = { ...edge };
      newEdge.label = this.replacePlaceholders(edge.label, values);
      if (edge.propertyUri) {
        newEdge.propertyUri = this.replacePlaceholders(edge.propertyUri, values);
      }
      return newEdge;
    });
    return layout;
  }
  replacePlaceholdersInSparql(values) {
    return this.replacePlaceholders(this.sparqlTemplate, values);
  }
  replacePlaceholders(text, values) {
    if (!text)
      return text || "";
    let result = text;
    for (const [key, value] of Object.entries(values)) {
      const placeholder = `{{${key}}}`;
      result = result.replace(new RegExp(placeholder, "g"), value);
    }
    for (const param of this.parameters) {
      if (param.defaultValue) {
        const placeholder = `{{${param.name}}}`;
        result = result.replace(new RegExp(placeholder, "g"), param.defaultValue);
      }
    }
    return result;
  }
  incrementUsage() {
    const updatedMetadata = {
      ...this.metadata,
      usageCount: (this.metadata.usageCount || 0) + 1,
      lastUsed: new Date(),
      updatedAt: new Date()
    };
    return new QueryTemplate({
      id: this.id,
      metadata: updatedMetadata,
      layout: this.layout,
      parameters: this.parameters,
      sparqlTemplate: this.sparqlTemplate,
      isBuiltIn: this.isBuiltIn
    });
  }
  updateMetadata(updates) {
    if (this.isBuiltIn) {
      throw new Error("Cannot modify built-in templates");
    }
    Object.assign(this.metadata, updates, { updatedAt: new Date() });
    return this;
  }
  // Parameter value management
  setParameterValue(parameterId, value) {
    const param = this.parameters.find((p) => p.name === parameterId || p.id === parameterId);
    if (!param) {
      throw new Error(`Parameter ${parameterId} not found`);
    }
    if (param.constraints) {
      if (param.constraints.pattern) {
        const regex = new RegExp(param.constraints.pattern);
        if (!regex.test(value)) {
          throw new Error(`Invalid value for parameter ${param.name}`);
        }
      }
      if (param.constraints.minLength && value.length < param.constraints.minLength) {
        throw new Error(`Invalid value for parameter ${param.name}`);
      }
      if (param.constraints.maxLength && value.length > param.constraints.maxLength) {
        throw new Error(`Invalid value for parameter ${param.name}`);
      }
      if (param.constraints.allowedValues && !param.constraints.allowedValues.includes(value)) {
        throw new Error(`Invalid value for parameter ${param.name}`);
      }
    }
    this.parameterValues.set(param.name, value);
  }
  getParameterValue(parameterId) {
    const param = this.parameters.find((p) => p.name === parameterId || p.id === parameterId);
    return param ? this.parameterValues.get(param.name) : void 0;
  }
  clearParameterValues() {
    this.parameterValues.clear();
  }
  addParameter(parameter) {
    if (this.isBuiltIn) {
      throw new Error("Cannot modify built-in templates");
    }
    this.parameters.push({
      ...parameter,
      id: parameter.id || `param_${parameter.name}_${Math.random().toString(36).substr(2, 9)}`
    });
  }
  toJSON() {
    return {
      id: this.id,
      metadata: this.metadata,
      layout: this.layout,
      parameters: this.parameters,
      sparqlTemplate: this.sparqlTemplate,
      isBuiltIn: this.isBuiltIn
    };
  }
  static fromJSON(json) {
    return new QueryTemplate({
      id: json.id,
      metadata: {
        ...json.metadata,
        createdAt: new Date(json.metadata.createdAt),
        updatedAt: new Date(json.metadata.updatedAt),
        lastUsed: json.metadata.lastUsed ? new Date(json.metadata.lastUsed) : void 0
      },
      layout: json.layout,
      parameters: json.parameters || [],
      sparqlTemplate: json.sparqlTemplate,
      isBuiltIn: json.isBuiltIn || false
    });
  }
  static fromCanvas(nodes, edges, viewport, metadata) {
    const nodeArray = nodes instanceof Map ? Array.from(nodes.values()) : nodes;
    const edgeArray = edges instanceof Map ? Array.from(edges.values()) : edges;
    const layout = {
      nodes: nodeArray.map((node) => ({
        id: node.getId(),
        type: node.getType(),
        label: node.getLabel(),
        position: node.getPosition(),
        variableName: node.getVariableName(),
        uri: node.getUri(),
        dimensions: node.getDimensions()
      })),
      edges: edgeArray.map((edge) => ({
        id: edge.getId(),
        sourceNodeId: edge.getSourceNodeId(),
        targetNodeId: edge.getTargetNodeId(),
        type: edge.getType(),
        label: edge.getLabel(),
        propertyUri: edge.getPropertyUri()
      })),
      viewport
    };
    const fullMetadata = {
      name: metadata.name || "Untitled Template",
      description: metadata.description || "",
      category: metadata.category || "custom" /* CUSTOM */,
      difficulty: metadata.difficulty || "intermediate" /* INTERMEDIATE */,
      tags: metadata.tags || [],
      createdAt: new Date(),
      updatedAt: new Date(),
      ...metadata
    };
    const sparql = "SELECT * WHERE { ?s ?p ?o }";
    return new QueryTemplate({
      id: `template_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      metadata: fullMetadata,
      layout,
      parameters: [],
      sparqlTemplate: sparql,
      isBuiltIn: false
    });
  }
  static createFromCanvas(name, description, nodes, edges, sparql, category = "custom" /* CUSTOM */, tags = []) {
    const layout = {
      nodes: nodes.map((node) => ({
        id: node.getId(),
        type: node.getType(),
        label: node.getLabel(),
        position: node.getPosition(),
        variableName: node.getVariableName(),
        uri: node.getUri(),
        dimensions: node.getDimensions()
      })),
      edges: edges.map((edge) => ({
        id: edge.getId(),
        sourceNodeId: edge.getSourceNodeId(),
        targetNodeId: edge.getTargetNodeId(),
        type: edge.getType(),
        label: edge.getLabel(),
        propertyUri: edge.getPropertyUri()
      }))
    };
    const metadata = {
      name,
      description,
      category,
      difficulty: "intermediate" /* INTERMEDIATE */,
      tags,
      sparqlPattern: sparql,
      usageCount: 0,
      createdAt: new Date(),
      updatedAt: new Date()
    };
    return new QueryTemplate({
      id: `template_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      metadata,
      layout,
      parameters: [],
      sparqlTemplate: sparql,
      isBuiltIn: false
    });
  }
};

// src/domain/visual/VisualQueryNode.ts
var VisualQueryNode = class {
  constructor(params) {
    this.selected = false;
    this.valid = true;
    this.errors = [];
    this.id = params.id;
    this.type = params.type;
    this.label = params.label;
    this.position = params.position;
    this.variableName = params.variableName;
    this.uri = params.uri;
    this.dimensions = params.dimensions || { width: 150, height: 60 };
    Object.freeze(this.id);
    Object.freeze(this.type);
  }
  getId() {
    return this.id;
  }
  getType() {
    return this.type;
  }
  getLabel() {
    return this.label;
  }
  setLabel(label) {
    this.label = label;
  }
  getVariableName() {
    return this.variableName;
  }
  setVariableName(name) {
    this.variableName = name;
  }
  getUri() {
    return this.uri;
  }
  setUri(uri) {
    this.uri = uri;
  }
  getPosition() {
    return { ...this.position };
  }
  setPosition(position) {
    this.position = { ...position };
  }
  getDimensions() {
    return { ...this.dimensions };
  }
  setDimensions(dimensions) {
    this.dimensions = { ...dimensions };
  }
  isSelected() {
    return this.selected;
  }
  setSelected(selected) {
    this.selected = selected;
  }
  isValid() {
    return this.valid;
  }
  setValid(valid, errors) {
    this.valid = valid;
    this.errors = errors || [];
  }
  getErrors() {
    return [...this.errors];
  }
  containsPoint(x, y) {
    return x >= this.position.x && x <= this.position.x + this.dimensions.width && y >= this.position.y && y <= this.position.y + this.dimensions.height;
  }
  getConnectionPoints() {
    return {
      top: {
        x: this.position.x + this.dimensions.width / 2,
        y: this.position.y
      },
      right: {
        x: this.position.x + this.dimensions.width,
        y: this.position.y + this.dimensions.height / 2
      },
      bottom: {
        x: this.position.x + this.dimensions.width / 2,
        y: this.position.y + this.dimensions.height
      },
      left: {
        x: this.position.x,
        y: this.position.y + this.dimensions.height / 2
      }
    };
  }
  toSPARQLElement() {
    switch (this.type) {
      case "entity" /* ENTITY */:
        if (this.uri) {
          return `<${this.uri}>`;
        } else if (this.variableName) {
          return `?${this.variableName}`;
        } else {
          return `?${this.label.toLowerCase().replace(/\s+/g, "_")}`;
        }
      case "variable" /* VARIABLE */:
        return `?${this.variableName || this.label.toLowerCase().replace(/\s+/g, "_")}`;
      case "literal" /* LITERAL */:
        return `"${this.label}"`;
      case "filter" /* FILTER */:
        return this.label;
      default:
        return "?unknown";
    }
  }
  clone() {
    return new VisualQueryNode({
      id: `${this.id}_clone_${Date.now()}`,
      type: this.type,
      label: this.label,
      position: { ...this.position },
      variableName: this.variableName,
      uri: this.uri,
      dimensions: { ...this.dimensions }
    });
  }
  static createEntity(label, uri, position) {
    return new VisualQueryNode({
      id: `entity_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: "entity" /* ENTITY */,
      label,
      uri,
      position: position || { x: 0, y: 0 }
    });
  }
  static createVariable(name, position) {
    return new VisualQueryNode({
      id: `var_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: "variable" /* VARIABLE */,
      label: name,
      variableName: name,
      position: position || { x: 0, y: 0 }
    });
  }
  static createLiteral(value, position) {
    return new VisualQueryNode({
      id: `literal_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: "literal" /* LITERAL */,
      label: value,
      position: position || { x: 0, y: 0 }
    });
  }
  static createFilter(expression, position) {
    return new VisualQueryNode({
      id: `filter_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: "filter" /* FILTER */,
      label: expression,
      position: position || { x: 0, y: 0 },
      dimensions: { width: 200, height: 80 }
    });
  }
};

// src/domain/visual/VisualQueryEdge.ts
var VisualQueryEdge = class {
  constructor(params) {
    this.selected = false;
    this.valid = true;
    this.errors = [];
    this.id = params.id;
    this.sourceNodeId = params.sourceNodeId;
    this.targetNodeId = params.targetNodeId;
    this.type = params.type;
    this.label = params.label;
    this.propertyUri = params.propertyUri;
    Object.freeze(this.id);
    Object.freeze(this.sourceNodeId);
    Object.freeze(this.targetNodeId);
    Object.freeze(this.type);
  }
  getId() {
    return this.id;
  }
  getSourceNodeId() {
    return this.sourceNodeId;
  }
  getTargetNodeId() {
    return this.targetNodeId;
  }
  getType() {
    return this.type;
  }
  getLabel() {
    return this.label;
  }
  setLabel(label) {
    this.label = label;
  }
  getPropertyUri() {
    return this.propertyUri;
  }
  setPropertyUri(uri) {
    this.propertyUri = uri;
  }
  isSelected() {
    return this.selected;
  }
  setSelected(selected) {
    this.selected = selected;
  }
  isValid() {
    return this.valid;
  }
  setValid(valid, errors) {
    this.valid = valid;
    this.errors = errors || [];
  }
  getErrors() {
    return [...this.errors];
  }
  isOptional() {
    return this.type === "optional" /* OPTIONAL */;
  }
  toSPARQLPredicate() {
    if (this.propertyUri) {
      return `<${this.propertyUri}>`;
    }
    if (this.label.startsWith("?")) {
      return this.label;
    }
    if (this.label.includes(":")) {
      return this.label;
    }
    return `?${this.label.toLowerCase().replace(/\s+/g, "_")}`;
  }
  calculatePath(sourceNode, targetNode) {
    const sourcePoint = sourceNode.getConnectionPoints();
    const targetPoint = targetNode.getConnectionPoints();
    const sx = sourcePoint.right.x;
    const sy = sourcePoint.right.y;
    const tx = targetPoint.left.x;
    const ty = targetPoint.left.y;
    const dx = tx - sx;
    const dy = ty - sy;
    const cx1 = sx + dx * 0.5;
    const cy1 = sy;
    const cx2 = sx + dx * 0.5;
    const cy2 = ty;
    return `M ${sx} ${sy} C ${cx1} ${cy1}, ${cx2} ${cy2}, ${tx} ${ty}`;
  }
  getLabelPosition(sourceNode, targetNode) {
    const sourcePoint = sourceNode.getConnectionPoints().right;
    const targetPoint = targetNode.getConnectionPoints().left;
    return {
      x: (sourcePoint.x + targetPoint.x) / 2,
      y: (sourcePoint.y + targetPoint.y) / 2
    };
  }
  clone() {
    return new VisualQueryEdge({
      id: `${this.id}_clone_${Date.now()}`,
      sourceNodeId: this.sourceNodeId,
      targetNodeId: this.targetNodeId,
      type: this.type,
      label: this.label,
      propertyUri: this.propertyUri
    });
  }
  static createProperty(sourceNodeId, targetNodeId, label, propertyUri) {
    return new VisualQueryEdge({
      id: `edge_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      sourceNodeId,
      targetNodeId,
      type: "property" /* PROPERTY */,
      label,
      propertyUri
    });
  }
  static createOptional(sourceNodeId, targetNodeId, label, propertyUri) {
    return new VisualQueryEdge({
      id: `optional_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      sourceNodeId,
      targetNodeId,
      type: "optional" /* OPTIONAL */,
      label,
      propertyUri
    });
  }
  static createFilterCondition(sourceNodeId, targetNodeId, label) {
    return new VisualQueryEdge({
      id: `filter_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      sourceNodeId,
      targetNodeId,
      type: "filter_condition" /* FILTER_CONDITION */,
      label
    });
  }
};

// src/application/use-cases/QueryTemplateUseCase.ts
var QueryTemplateUseCase = class {
  constructor(templateRepository) {
    this.templateRepository = templateRepository;
  }
  getTemplateRepository() {
    return this.templateRepository;
  }
  async getAllTemplates() {
    return await this.templateRepository.findAll();
  }
  async getTemplateById(id) {
    return await this.templateRepository.findById(id);
  }
  async searchTemplates(criteria) {
    return await this.templateRepository.findByCriteria(criteria);
  }
  async getTemplatesByCategory(category) {
    return await this.templateRepository.findByCategory(category);
  }
  async getBuiltInTemplates() {
    return await this.templateRepository.getBuiltInTemplates();
  }
  async getCustomTemplates() {
    return await this.templateRepository.getCustomTemplates();
  }
  async getRecentTemplates(limit) {
    return await this.templateRepository.getRecentlyUsed(limit);
  }
  async saveTemplate(template) {
    if (template.isBuiltInTemplate()) {
      throw new Error("Cannot save built-in templates");
    }
    return await this.templateRepository.save(template);
  }
  async createCustomTemplate(nodes, edges, viewport, name, description, category = "custom" /* CUSTOM */, tags = []) {
    const metadata = {
      name,
      description,
      category,
      tags: [...tags, "custom"],
      difficulty: "intermediate",
      createdAt: new Date(),
      updatedAt: new Date(),
      version: "1.0.0"
    };
    const template = QueryTemplate.fromCanvas(nodes, edges, viewport, {
      name,
      description,
      category,
      difficulty: "intermediate" /* INTERMEDIATE */,
      tags
    });
    return await this.templateRepository.create(template);
  }
  async cloneTemplate(templateId, newName) {
    const template = await this.templateRepository.findById(templateId);
    if (!template) {
      throw new Error(`Template with ID ${templateId} not found`);
    }
    let cloned = template.clone();
    if (newName) {
      cloned = cloned.updateMetadata({
        name: newName
      });
    }
    return await this.templateRepository.create(cloned);
  }
  async deleteTemplate(id) {
    const template = await this.templateRepository.findById(id);
    if (!template) {
      return false;
    }
    if (template.isBuiltInTemplate()) {
      throw new Error("Cannot delete built-in templates");
    }
    return await this.templateRepository.delete(id);
  }
  async instantiateTemplate(template) {
    var _a, _b, _c, _d;
    const validation = template.validateParameters();
    if (!validation.isValid) {
      throw new Error(`Template parameters are invalid: ${validation.errors.join(", ")}`);
    }
    await this.templateRepository.recordUsage(template.getId());
    const instantiated = template.instantiate({});
    return {
      nodes: ((_b = (_a = instantiated.layout) == null ? void 0 : _a.nodes) == null ? void 0 : _b.map((node) => {
        return new VisualQueryNode({
          id: node.id,
          type: node.type,
          label: node.label,
          position: node.position,
          variableName: node.variableName,
          uri: node.uri,
          dimensions: node.dimensions
        });
      })) || [],
      edges: ((_d = (_c = instantiated.layout) == null ? void 0 : _c.edges) == null ? void 0 : _d.map((edge) => {
        return new VisualQueryEdge({
          id: edge.id,
          sourceNodeId: edge.sourceNodeId,
          targetNodeId: edge.targetNodeId,
          type: edge.type,
          label: edge.label,
          propertyUri: edge.propertyUri
        });
      })) || []
    };
  }
  async exportTemplates(templateIds) {
    const templates = await this.templateRepository.exportTemplates(templateIds);
    return JSON.stringify(templates, null, 2);
  }
  async importTemplates(jsonData) {
    try {
      const templatesData = JSON.parse(jsonData);
      if (!Array.isArray(templatesData)) {
        throw new Error("Invalid JSON format: expected array of templates");
      }
      return await this.templateRepository.importTemplates(templatesData);
    } catch (error) {
      throw new Error(`Failed to import templates: ${error.message}`);
    }
  }
  async getUsageStatistics(templateId) {
    return await this.templateRepository.getUsageStats(templateId);
  }
  async updateTemplateMetadata(templateId, updates) {
    const template = await this.templateRepository.findById(templateId);
    if (!template) {
      throw new Error(`Template with ID ${templateId} not found`);
    }
    if (template.isBuiltInTemplate()) {
      throw new Error("Cannot modify built-in templates");
    }
    const updatedTemplate = template.updateMetadata(updates);
    return await this.templateRepository.update(updatedTemplate);
  }
  async validateTemplateParameters(template) {
    const validation = template.validateParameters();
    const parameters = template.getParameters();
    const parameterValues = template.getParameterValues();
    const missingParameters = [];
    const invalidParameters = [];
    parameters.forEach((param) => {
      const paramId = param.id || `param_${param.name}`;
      if (param.required && !parameterValues.has(paramId)) {
        missingParameters.push(param.name);
      }
      const value = parameterValues.get(paramId);
      if (value && param.constraints) {
      }
    });
    return {
      isValid: validation.isValid,
      errors: validation.errors,
      missingParameters,
      invalidParameters
    };
  }
  async getTemplatePreview(templateId) {
    const template = await this.templateRepository.findById(templateId);
    if (!template) {
      throw new Error(`Template with ID ${templateId} not found`);
    }
    const layout = template.getLayout();
    const parameters = template.getParameters();
    const nodeCount = layout.nodes.length;
    const edgeCount = layout.edges.length;
    let complexity = "simple";
    const totalElements = nodeCount + edgeCount + parameters.length;
    if (totalElements <= 5) {
      complexity = "simple";
    } else if (totalElements <= 10) {
      complexity = "moderate";
    } else {
      complexity = "complex";
    }
    let sparqlQuery = template.getMetadata().sparqlPattern || "";
    parameters.forEach((param) => {
      const paramId = param.id || `param_${param.name}`;
      const placeholder = `{${paramId.toUpperCase()}}`;
      const exampleValue = param.defaultValue || `{${param.name}}`;
      sparqlQuery = sparqlQuery.replace(new RegExp(placeholder, "g"), exampleValue);
    });
    return {
      sparqlQuery,
      nodeCount,
      edgeCount,
      parameterCount: parameters.length,
      complexity
    };
  }
  async refreshTemplateCache() {
    await this.templateRepository.refresh();
  }
};

// src/infrastructure/services/ObsidianCommandExecutor.ts
var import_obsidian10 = require("obsidian");
var ObsidianCommandExecutor = class {
  constructor(app, assetRepository) {
    this.app = app;
    this.assetRepository = assetRepository;
    this.handlers = /* @__PURE__ */ new Map();
    this.registerDefaultHandlers();
  }
  async execute(request) {
    const startTime = Date.now();
    try {
      const validationResult = this.validate(request);
      if (validationResult.isFailure) {
        return Result.fail(validationResult.error);
      }
      const handler = this.handlers.get(request.command.type);
      if (!handler) {
        return Result.fail(
          `No handler registered for command type: ${request.command.type}`
        );
      }
      const executionResult = await handler(request);
      const executionTime = Date.now() - startTime;
      if (executionResult.isFailure) {
        return Result.ok({
          commandId: request.context.commandId,
          status: "failure",
          error: executionResult.error,
          executionTime
        });
      }
      return Result.ok({
        commandId: request.context.commandId,
        status: "success",
        output: executionResult.getValue(),
        executionTime
      });
    } catch (error) {
      const executionTime = Date.now() - startTime;
      return Result.ok({
        commandId: request.context.commandId,
        status: "failure",
        error: `Unexpected error: ${error.message}`,
        executionTime
      });
    }
  }
  registerHandler(type, handler) {
    this.handlers.set(type, handler);
  }
  isSupported(type) {
    return this.handlers.has(type);
  }
  validate(request) {
    if (!request.command) {
      return Result.fail("Command is required");
    }
    if (!request.context) {
      return Result.fail("Execution context is required");
    }
    const command = request.command;
    if (command.requiresInput && (!request.context.parameters || Object.keys(request.context.parameters).length === 0)) {
      return Result.fail("Command requires input parameters");
    }
    return Result.ok();
  }
  registerDefaultHandlers() {
    this.registerHandler("CREATE_ASSET" /* CREATE_ASSET */, async (request) => {
      const params = request.context.parameters;
      const title = params.title || "Untitled";
      const className = params.className || request.context.targetClass || "exo__Asset";
      const ontology = params.ontology || "exo";
      const properties = params.properties || {};
      const idResult = AssetId.create(this.sanitizeFileName(title));
      if (idResult.isFailure) {
        return Result.fail(idResult.error);
      }
      const classNameResult = ClassName.create(className);
      if (classNameResult.isFailure) {
        return Result.fail(classNameResult.error);
      }
      const ontologyResult = OntologyPrefix.create(ontology);
      if (ontologyResult.isFailure) {
        return Result.fail(ontologyResult.error);
      }
      const assetResult = Asset.create({
        id: idResult.getValue(),
        className: classNameResult.getValue(),
        ontology: ontologyResult.getValue(),
        label: title,
        description: params.description || "",
        properties
      });
      if (assetResult.isFailure) {
        return Result.fail(assetResult.error);
      }
      await this.assetRepository.save(assetResult.getValue());
      const file = this.app.vault.getAbstractFileByPath(`${title}.md`);
      if (file instanceof import_obsidian10.TFile) {
        await this.app.workspace.getLeaf().openFile(file);
      }
      new import_obsidian10.Notice(`Asset "${title}" created successfully`);
      return Result.ok({ assetId: idResult.getValue().toString() });
    });
    this.registerHandler("OPEN_ASSET" /* OPEN_ASSET */, async (request) => {
      const assetId = request.context.assetId || request.context.parameters.assetId;
      if (!assetId) {
        return Result.fail("Asset ID is required for OPEN_ASSET command");
      }
      const file = this.app.vault.getAbstractFileByPath(`${assetId}.md`);
      if (!(file instanceof import_obsidian10.TFile)) {
        return Result.fail(`Asset not found: ${assetId}`);
      }
      await this.app.workspace.getLeaf(true).openFile(file);
      return Result.ok({ opened: assetId });
    });
    this.registerHandler("DELETE_ASSET" /* DELETE_ASSET */, async (request) => {
      const assetId = request.context.assetId || request.context.parameters.assetId;
      if (!assetId) {
        return Result.fail("Asset ID is required for DELETE_ASSET command");
      }
      const file = this.app.vault.getAbstractFileByPath(`${assetId}.md`);
      if (!(file instanceof import_obsidian10.TFile)) {
        return Result.fail(`Asset not found: ${assetId}`);
      }
      const confirmDelete = await this.confirmAction(
        `Delete Asset`,
        `Are you sure you want to delete "${assetId}"? This cannot be undone.`
      );
      if (!confirmDelete) {
        return Result.ok({ cancelled: true });
      }
      await this.app.vault.delete(file);
      new import_obsidian10.Notice(`Asset "${assetId}" deleted`);
      return Result.ok({ deleted: assetId });
    });
    this.registerHandler("RUN_TEMPLATE" /* RUN_TEMPLATE */, async (request) => {
      const templateName = request.context.template || request.context.parameters.template_name;
      const targetAssetId = request.context.assetId;
      if (!templateName) {
        return Result.fail("Template name is required");
      }
      if (!targetAssetId) {
        return Result.fail("Target asset is required for template application");
      }
      const templateFile = this.app.vault.getAbstractFileByPath(`templates/${templateName}.md`);
      if (!(templateFile instanceof import_obsidian10.TFile)) {
        return Result.fail(`Template not found: ${templateName}`);
      }
      const templateContent = await this.app.vault.read(templateFile);
      const targetFile = this.app.vault.getAbstractFileByPath(`${targetAssetId}.md`);
      if (!(targetFile instanceof import_obsidian10.TFile)) {
        return Result.fail(`Target asset not found: ${targetAssetId}`);
      }
      const currentContent = await this.app.vault.read(targetFile);
      const newContent = currentContent + "\n\n" + this.processTemplate(templateContent, request.context.parameters);
      await this.app.vault.modify(targetFile, newContent);
      new import_obsidian10.Notice(`Template "${templateName}" applied successfully`);
      return Result.ok({ template: templateName, target: targetAssetId });
    });
    this.registerHandler("EXECUTE_SEARCH" /* EXECUTE_SEARCH */, async (request) => {
      const query = request.context.parameters.query;
      if (!query) {
        return Result.fail("Search query is required");
      }
      this.app.internalPlugins.getPluginById("global-search").instance.openGlobalSearch(query);
      return Result.ok({ query });
    });
    this.registerHandler("TRIGGER_WORKFLOW" /* TRIGGER_WORKFLOW */, async (request) => {
      const workflowName = request.context.parameters.workflow;
      if (!workflowName) {
        return Result.fail("Workflow name is required");
      }
      console.log(`Triggering workflow: ${workflowName}`, request.context.parameters);
      new import_obsidian10.Notice(`Workflow "${workflowName}" triggered`);
      return Result.ok({ workflow: workflowName });
    });
    this.registerHandler("CUSTOM" /* CUSTOM */, async (request) => {
      const script = request.context.script;
      if (!script) {
        return Result.fail("Script is required for custom commands");
      }
      return Result.fail("Script execution is disabled for security. Use predefined commands instead.");
    });
  }
  sanitizeFileName(name) {
    return name.replace(/[\\/:*?"<>|]/g, "-").trim();
  }
  processTemplate(template, parameters) {
    let processed = template;
    for (const [key, value] of Object.entries(parameters)) {
      const regex = new RegExp(`{{\\s*${key}\\s*}}`, "g");
      processed = processed.replace(regex, String(value));
    }
    const now = new Date();
    processed = processed.replace(/{{date}}/g, now.toISOString().split("T")[0]);
    processed = processed.replace(/{{time}}/g, now.toTimeString().split(" ")[0]);
    processed = processed.replace(/{{datetime}}/g, now.toISOString());
    return processed;
  }
  async confirmAction(title, message) {
    return new Promise((resolve) => {
      const modal = new ConfirmationModal(this.app, title, message, resolve);
      modal.open();
    });
  }
};
var ConfirmationModal = class extends import_obsidian10.Modal {
  constructor(app, title, message, onConfirm) {
    super(app);
    this.title = title;
    this.message = message;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: this.title });
    contentEl.createEl("p", { text: this.message });
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => {
      this.onConfirm(false);
      this.close();
    });
    const confirmBtn = buttonContainer.createEl("button", {
      text: "Confirm",
      cls: "mod-warning"
    });
    confirmBtn.addEventListener("click", () => {
      this.onConfirm(true);
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/domain/errors/ExocortexError.ts
var ErrorBuilder = class {
  constructor() {
    this.error = {};
  }
  static create() {
    return new ErrorBuilder();
  }
  withId(id) {
    this.error.id = id;
    return this;
  }
  withSeverity(severity) {
    this.error.severity = severity;
    return this;
  }
  withCategory(category) {
    this.error.category = category;
    return this;
  }
  withTitle(title) {
    this.error.title = title;
    return this;
  }
  withMessage(message) {
    this.error.message = message;
    return this;
  }
  withContext(context) {
    this.error.context = context;
    return this;
  }
  withLocation(location) {
    if (!this.error.context) {
      this.error.context = {
        operation: "Unknown",
        timestamp: new Date()
      };
    }
    this.error.context.location = location;
    return this;
  }
  withTechnicalDetails(details) {
    this.error.technicalDetails = details;
    return this;
  }
  withSuggestions(suggestions) {
    this.error.suggestions = suggestions;
    return this;
  }
  withRecoverable(recoverable) {
    this.error.recoverable = recoverable;
    return this;
  }
  withStackTrace(stackTrace) {
    this.error.stackTrace = stackTrace;
    return this;
  }
  withInnerError(innerError) {
    this.error.innerError = innerError;
    return this;
  }
  build() {
    if (!this.error.id) {
      this.error.id = `error-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }
    if (!this.error.severity) {
      this.error.severity = "error" /* ERROR */;
    }
    if (!this.error.category) {
      this.error.category = "system" /* SYSTEM */;
    }
    if (!this.error.title) {
      this.error.title = "Error";
    }
    if (!this.error.message) {
      this.error.message = "An error occurred";
    }
    if (!this.error.context) {
      this.error.context = {
        operation: "Unknown",
        timestamp: new Date()
      };
    }
    return this.error;
  }
};

// src/domain/errors/ErrorAnalyzer.ts
var ErrorAnalyzer = class {
  static analyze(error) {
    const errorMessage = typeof error === "string" ? error : error.message;
    const stackTrace = error instanceof Error ? error.stack : void 0;
    for (const pattern of this.patterns) {
      const match = errorMessage.match(pattern.pattern);
      if (match) {
        return ErrorBuilder.create().withSeverity(pattern.severity).withCategory(pattern.category).withTitle(pattern.title).withMessage(pattern.getUserMessage(match)).withContext({
          operation: "Error Analysis",
          timestamp: new Date()
        }).withTechnicalDetails(errorMessage).withSuggestions(pattern.getSuggestions(match)).withRecoverable(pattern.recoverable).withStackTrace(stackTrace || "").build();
      }
    }
    return ErrorBuilder.create().withSeverity("error" /* ERROR */).withCategory("system" /* SYSTEM */).withTitle("Unknown Error").withMessage("An unexpected error occurred. Please check the technical details for more information.").withContext({
      operation: "Error Analysis",
      timestamp: new Date()
    }).withTechnicalDetails(errorMessage).withRecoverable(false).withStackTrace(stackTrace || "").build();
  }
  static getSPARQLErrorLocation(query, errorPosition) {
    if (!errorPosition || errorPosition < 0)
      return void 0;
    const lines = query.split("\n");
    let currentPosition = 0;
    for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
      const lineLength = lines[lineIndex].length;
      if (currentPosition + lineLength >= errorPosition) {
        return {
          line: lineIndex + 1,
          column: errorPosition - currentPosition + 1
        };
      }
      currentPosition += lineLength + 1;
    }
    return void 0;
  }
  static addPattern(pattern) {
    this.patterns.push(pattern);
  }
  static clearPatterns() {
    this.patterns = [];
  }
};
ErrorAnalyzer.patterns = [
  {
    pattern: /Unexpected token '([^']+)' at position (\d+)/i,
    severity: "error" /* ERROR */,
    category: "syntax" /* SYNTAX */,
    title: "SPARQL Syntax Error",
    getUserMessage: (match) => `Unexpected '${match[1]}' at position ${match[2]}. Check for missing brackets or incorrect syntax.`,
    getSuggestions: (match) => [
      {
        title: "Check Syntax",
        description: `The character '${match[1]}' was not expected at this position.`,
        confidence: 0.9
      },
      {
        title: "Common Fixes",
        description: "Ensure all brackets are closed and keywords are spelled correctly.",
        confidence: 0.7,
        learnMore: {
          url: "https://www.w3.org/TR/sparql11-query/",
          title: "SPARQL Syntax Guide"
        }
      }
    ],
    recoverable: true
  },
  {
    pattern: /Unknown prefix: ([^\s]+)/i,
    severity: "error" /* ERROR */,
    category: "semantic" /* SEMANTIC */,
    title: "Unknown Prefix",
    getUserMessage: (match) => `The prefix '${match[1]}' is not defined. Add a PREFIX declaration at the beginning of your query.`,
    getSuggestions: (match) => [
      {
        title: "Add PREFIX Declaration",
        description: `Add: PREFIX ${match[1]} <http://example.org/${match[1].replace(":", "")}#> at the beginning`,
        confidence: 0.95,
        action: {
          label: "Add PREFIX",
          handler: () => console.log("Adding prefix...")
        }
      }
    ],
    recoverable: true
  },
  {
    pattern: /Query timeout after (\d+)ms/i,
    severity: "warning" /* WARNING */,
    category: "system" /* SYSTEM */,
    title: "Query Timeout",
    getUserMessage: (match) => `Your query took longer than ${match[1]}ms and was cancelled. Try simplifying the query or adding limits.`,
    getSuggestions: () => [
      {
        title: "Add LIMIT Clause",
        description: "Restrict the number of results with LIMIT 100",
        confidence: 0.8,
        action: {
          label: "Add LIMIT",
          handler: () => console.log("Adding limit...")
        }
      },
      {
        title: "Optimize Query",
        description: "Simplify triple patterns or reduce the scope",
        confidence: 0.7,
        learnMore: {
          url: "https://docs.exocortex.com/query-optimization",
          title: "Query Optimization Guide"
        }
      }
    ],
    recoverable: true
  },
  {
    pattern: /Invalid IRI: ([^\s]+)/i,
    severity: "error" /* ERROR */,
    category: "validation" /* VALIDATION */,
    title: "Invalid IRI",
    getUserMessage: (match) => `'${match[1]}' is not a valid IRI. IRIs must be absolute URIs enclosed in angle brackets.`,
    getSuggestions: (match) => {
      const suggestions = [];
      if (!match[1].startsWith("<") || !match[1].endsWith(">")) {
        suggestions.push({
          title: "Add Angle Brackets",
          description: `Enclose the IRI in angle brackets: <${match[1]}>`,
          confidence: 0.9
        });
      }
      if (!match[1].includes("://")) {
        suggestions.push({
          title: "Use Absolute IRI",
          description: "IRIs must be absolute URLs, e.g., <http://example.org/resource>",
          confidence: 0.85
        });
      }
      return suggestions;
    },
    recoverable: true
  },
  {
    pattern: /Empty result set/i,
    severity: "info" /* INFO */,
    category: "semantic" /* SEMANTIC */,
    title: "No Results Found",
    getUserMessage: () => "Your query executed successfully but returned no results. This might be expected, or you may need to adjust your query criteria.",
    getSuggestions: () => [
      {
        title: "Check Triple Patterns",
        description: "Ensure your triple patterns match existing data",
        confidence: 0.6
      },
      {
        title: "Broaden Search Criteria",
        description: "Try using more general patterns or OPTIONAL clauses",
        confidence: 0.5
      }
    ],
    recoverable: true
  },
  {
    pattern: /Circular reference detected/i,
    severity: "warning" /* WARNING */,
    category: "semantic" /* SEMANTIC */,
    title: "Circular Reference",
    getUserMessage: () => "A circular reference was detected in your ontology. This may cause infinite loops in reasoning.",
    getSuggestions: () => [
      {
        title: "Review Ontology Structure",
        description: "Check for classes that reference themselves directly or indirectly",
        confidence: 0.7
      },
      {
        title: "Use Reasoning Limits",
        description: "Set maximum inference depth to prevent infinite loops",
        confidence: 0.8
      }
    ],
    recoverable: true
  }
];

// src/domain/core/EnhancedResult.ts
var EnhancedResult = class {
  constructor(result, errorDetails) {
    this._result = result;
    this._errorDetails = errorDetails;
  }
  get isSuccess() {
    return this._result.isSuccess;
  }
  get isFailure() {
    return this._result.isFailure;
  }
  get error() {
    return this._result.error;
  }
  getValue() {
    return this._result.getValue();
  }
  errorValue() {
    return this._result.errorValue();
  }
  getErrorDetails() {
    return this._errorDetails;
  }
  static okEnhanced(value) {
    const result = Result.ok(value);
    return new EnhancedResult(result);
  }
  static failEnhanced(error) {
    let errorMessage;
    let errorDetails;
    if (typeof error === "string") {
      errorMessage = error;
      errorDetails = ErrorBuilder.create().withTitle("Operation Failed").withMessage(error).withSeverity("error" /* ERROR */).withCategory("system" /* SYSTEM */).withContext({
        operation: "Unknown",
        timestamp: new Date()
      }).build();
    } else {
      errorMessage = error.message;
      errorDetails = error;
    }
    const result = Result.fail(errorMessage);
    return new EnhancedResult(result, errorDetails);
  }
  mapError(fn) {
    if (this.isSuccess) {
      return this;
    }
    const currentError = this._errorDetails || ErrorBuilder.create().withMessage(this.error).withSeverity("error" /* ERROR */).withCategory("system" /* SYSTEM */).withContext({
      operation: "Unknown",
      timestamp: new Date()
    }).build();
    const mappedError = fn(currentError);
    return EnhancedResult.failEnhanced(mappedError);
  }
  chain(fn) {
    if (this.isFailure) {
      return EnhancedResult.failEnhanced(this._errorDetails || this.error);
    }
    return fn(this.getValue());
  }
  static combineEnhanced(results) {
    const errors = [];
    for (const result of results) {
      if (result.isFailure) {
        const errorDetails = result.getErrorDetails();
        if (errorDetails) {
          errors.push(errorDetails);
        }
      }
    }
    if (errors.length > 0) {
      const combinedError = ErrorBuilder.create().withTitle("Multiple Errors Occurred").withMessage(`${errors.length} error(s) occurred during operation`).withSeverity("error" /* ERROR */).withCategory("system" /* SYSTEM */).withContext({
        operation: "Combined Operation",
        timestamp: new Date(),
        metadata: {
          errorCount: errors.length,
          errors: errors.map((e) => ({ id: e.id, title: e.title }))
        }
      }).withInnerError(errors[0]).build();
      return EnhancedResult.failEnhanced(combinedError);
    }
    return EnhancedResult.okEnhanced();
  }
  withContext(context) {
    if (this.isSuccess) {
      return this;
    }
    const currentError = this._errorDetails;
    if (!currentError) {
      return this;
    }
    const updatedError = {
      ...currentError,
      context: {
        ...currentError.context,
        ...context
      }
    };
    return EnhancedResult.failEnhanced(updatedError);
  }
};

// src/application/services/ErrorHandlerService.ts
var import_obsidian11 = require("obsidian");
var ErrorHandlerService = class {
  constructor(options = {}) {
    this.options = options;
    this.errorHistory = [];
    this.errorMetrics = {
      totalErrors: 0,
      errorsBySeverity: {
        ["critical" /* CRITICAL */]: 0,
        ["error" /* ERROR */]: 0,
        ["warning" /* WARNING */]: 0,
        ["info" /* INFO */]: 0
      },
      errorsByCategory: {
        ["syntax" /* SYNTAX */]: 0,
        ["semantic" /* SEMANTIC */]: 0,
        ["validation" /* VALIDATION */]: 0,
        ["system" /* SYSTEM */]: 0,
        ["network" /* NETWORK */]: 0,
        ["permission" /* PERMISSION */]: 0
      },
      averageResolutionTime: 0
    };
    this.resolutionTimes = [];
    this.maxHistorySize = 100;
    this.errorStartTimes = /* @__PURE__ */ new Map();
    this.options = {
      showUserNotification: true,
      logToConsole: true,
      trackMetrics: true,
      autoRecover: false,
      ...options
    };
  }
  async handleError(error, context) {
    const startTime = Date.now();
    try {
      let exoError;
      if (typeof error === "string") {
        exoError = ErrorAnalyzer.analyze(error);
      } else if (error instanceof Error) {
        exoError = ErrorAnalyzer.analyze(error);
      } else {
        exoError = error;
      }
      if (context) {
        exoError = {
          ...exoError,
          context: {
            ...exoError.context,
            ...context
          }
        };
      }
      this.errorStartTimes.set(exoError.id, startTime);
      if (this.options.trackMetrics) {
        this.updateMetrics(exoError);
      }
      if (this.options.logToConsole) {
        this.logError(exoError);
      }
      if (this.options.showUserNotification) {
        this.showUserNotification(exoError);
      }
      this.addToHistory(exoError);
      if (this.options.autoRecover && exoError.recoverable) {
        await this.attemptRecovery(exoError);
      }
      return EnhancedResult.okEnhanced();
    } catch (handlingError) {
      console.error("Error in error handler:", handlingError);
      return EnhancedResult.failEnhanced(
        ErrorBuilder.create().withTitle("Error Handler Failed").withMessage("Failed to handle the error properly").withSeverity("critical" /* CRITICAL */).withCategory("system" /* SYSTEM */).withContext({
          operation: "Error Handling",
          timestamp: new Date()
        }).withTechnicalDetails(handlingError instanceof Error ? handlingError.message : String(handlingError)).build()
      );
    }
  }
  markErrorResolved(errorId) {
    const startTime = this.errorStartTimes.get(errorId);
    if (startTime) {
      const resolutionTime = Date.now() - startTime;
      this.resolutionTimes.push(resolutionTime);
      if (this.resolutionTimes.length > 100) {
        this.resolutionTimes.shift();
      }
      this.errorMetrics.averageResolutionTime = this.resolutionTimes.reduce((a, b) => a + b, 0) / this.resolutionTimes.length;
      this.errorStartTimes.delete(errorId);
    }
  }
  updateMetrics(error) {
    this.errorMetrics.totalErrors++;
    this.errorMetrics.errorsBySeverity[error.severity]++;
    this.errorMetrics.errorsByCategory[error.category]++;
    this.errorMetrics.lastError = error;
  }
  logError(error) {
    const logLevel = this.getLogLevel(error.severity);
    const logMessage = this.formatErrorForConsole(error);
    switch (logLevel) {
      case "error":
        console.error(logMessage, error);
        break;
      case "warn":
        console.warn(logMessage, error);
        break;
      case "info":
        console.info(logMessage, error);
        break;
      default:
        console.log(logMessage, error);
    }
  }
  getLogLevel(severity) {
    switch (severity) {
      case "critical" /* CRITICAL */:
      case "error" /* ERROR */:
        return "error";
      case "warning" /* WARNING */:
        return "warn";
      case "info" /* INFO */:
        return "info";
      default:
        return "log";
    }
  }
  formatErrorForConsole(error) {
    const parts = [
      `[${error.severity.toUpperCase()}]`,
      `[${error.category}]`,
      error.title,
      "-",
      error.message
    ];
    if (error.context.location) {
      if (typeof error.context.location === "object" && "line" in error.context.location) {
        parts.push(`(Line ${error.context.location.line}:${error.context.location.column})`);
      }
    }
    return parts.join(" ");
  }
  showUserNotification(error) {
    const duration = this.getNotificationDuration(error.severity);
    const message = this.formatErrorForUser(error);
    new import_obsidian11.Notice(message, duration);
  }
  getNotificationDuration(severity) {
    switch (severity) {
      case "critical" /* CRITICAL */:
        return 1e4;
      case "error" /* ERROR */:
        return 7e3;
      case "warning" /* WARNING */:
        return 5e3;
      case "info" /* INFO */:
        return 3e3;
      default:
        return 5e3;
    }
  }
  formatErrorForUser(error) {
    let message = `${error.title}: ${error.message}`;
    if (error.suggestions && error.suggestions.length > 0) {
      const topSuggestion = error.suggestions[0];
      message += `

\u{1F4A1} ${topSuggestion.title}`;
    }
    return message;
  }
  addToHistory(error) {
    this.errorHistory.unshift(error);
    if (this.errorHistory.length > this.maxHistorySize) {
      this.errorHistory.pop();
    }
  }
  async attemptRecovery(error) {
    if (!error.suggestions || error.suggestions.length === 0) {
      return;
    }
    const autoFixSuggestion = error.suggestions.find(
      (s) => s.confidence && s.confidence > 0.9 && s.action
    );
    if (autoFixSuggestion && autoFixSuggestion.action) {
      try {
        await autoFixSuggestion.action.handler();
        new import_obsidian11.Notice(`Auto-recovery: ${autoFixSuggestion.title}`, 3e3);
      } catch (recoveryError) {
        console.error("Auto-recovery failed:", recoveryError);
      }
    }
  }
  getMetrics() {
    return { ...this.errorMetrics };
  }
  getErrorHistory() {
    return [...this.errorHistory];
  }
  clearHistory() {
    this.errorHistory = [];
    this.errorStartTimes.clear();
  }
  getSuggestions(error) {
    const exoError = ErrorAnalyzer.analyze(error);
    return exoError.suggestions || [];
  }
  analyzeError(error) {
    return ErrorAnalyzer.analyze(error);
  }
};

// src/domain/autocomplete/SPARQLSuggestion.ts
var SPARQLSuggestion = class {
  constructor(id, text, insertText, type, confidence, contextualScore, metadata) {
    this.id = id;
    this.text = text;
    this.insertText = insertText;
    this.type = type;
    this.confidence = confidence;
    this.contextualScore = contextualScore;
    this.metadata = metadata;
    Object.freeze(this);
  }
  getId() {
    return this.id;
  }
  getText() {
    return this.text;
  }
  getInsertText() {
    return this.insertText;
  }
  getType() {
    return this.type;
  }
  getConfidence() {
    return this.confidence;
  }
  getContextualScore() {
    return this.contextualScore;
  }
  getMetadata() {
    return this.metadata;
  }
  calculateFinalScore(boostFactor = 1) {
    return (this.confidence * 0.6 + this.contextualScore * 0.4) * boostFactor;
  }
  static create(params) {
    return new SPARQLSuggestion(
      params.id,
      params.text,
      params.insertText || params.text,
      params.type,
      params.confidence,
      params.contextualScore,
      params.metadata
    );
  }
};

// src/domain/autocomplete/QueryContext.ts
var QueryContext = class {
  constructor(query, cursorPosition, currentToken, previousTokens, queryType, currentClause, clauses) {
    this.query = query;
    this.cursorPosition = cursorPosition;
    this.currentToken = currentToken;
    this.previousTokens = previousTokens;
    this.queryType = queryType;
    this.currentClause = currentClause;
    this.clauses = clauses;
    Object.freeze(this);
  }
  getQuery() {
    return this.query;
  }
  getCursorPosition() {
    return this.cursorPosition;
  }
  getCurrentToken() {
    return this.currentToken;
  }
  getPreviousTokens() {
    return [...this.previousTokens];
  }
  getQueryType() {
    return this.queryType;
  }
  getCurrentClause() {
    return this.currentClause;
  }
  getClauses() {
    return [...this.clauses];
  }
  isInClause(clauseType) {
    return this.currentClause === clauseType;
  }
  isAfterClause(clauseType) {
    const clauseIndex = this.clauses.findIndex((c) => c.type === clauseType);
    if (clauseIndex === -1)
      return false;
    const clause = this.clauses[clauseIndex];
    return this.cursorPosition > clause.endPosition;
  }
  getVariablesInScope() {
    const variables = /* @__PURE__ */ new Set();
    for (const clause of this.clauses) {
      if (clause.endPosition < this.cursorPosition) {
        clause.variables.forEach((v) => variables.add(v));
      }
    }
    return Array.from(variables);
  }
  isStartOfQuery() {
    const trimmedQuery = this.query.substring(0, this.cursorPosition).trim();
    return trimmedQuery.length === 0 || trimmedQuery.length === this.currentToken.length;
  }
  static create(params) {
    return new QueryContext(
      params.query,
      params.cursorPosition,
      params.currentToken || "",
      params.previousTokens || [],
      params.queryType || null,
      params.currentClause || null,
      params.clauses || []
    );
  }
};

// src/application/services/SPARQLAutocompleteService.ts
var SPARQLAutocompleteService = class {
  constructor(suggestionRepository, graph) {
    this.suggestionRepository = suggestionRepository;
    this.graph = graph;
    this.cache = /* @__PURE__ */ new Map();
    this.cacheTTL = 5 * 60 * 1e3;
    // 5 minutes
    this.defaultMaxSuggestions = 20;
  }
  async getSuggestions(query, cursorPosition, options = {}) {
    try {
      if (cursorPosition < 0) {
        return Result.fail("Cursor position cannot be negative");
      }
      if (cursorPosition > query.length) {
        cursorPosition = query.length;
      }
      const context = this.analyzeContext(query, cursorPosition);
      if (options.cacheResults) {
        const cached = this.getCachedSuggestions(context);
        if (cached) {
          return Result.ok(cached);
        }
      }
      const suggestions = await this.collectSuggestions(context, options);
      const rankedSuggestions = this.rankSuggestions(suggestions, context, options);
      const limitedSuggestions = rankedSuggestions.slice(0, options.maxSuggestions || this.defaultMaxSuggestions);
      if (options.cacheResults) {
        this.cacheSuggestions(context, limitedSuggestions);
      }
      return Result.ok(limitedSuggestions);
    } catch (error) {
      return Result.fail(`Failed to get suggestions: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  analyzeContext(query, cursorPosition) {
    const tokens = this.tokenizeQuery(query, cursorPosition);
    const currentToken = this.getCurrentToken(query, cursorPosition);
    const previousTokens = tokens.filter((t) => t.position < cursorPosition).map((t) => t.text);
    const queryType = this.detectQueryType(tokens);
    const currentClause = this.detectCurrentClause(query, cursorPosition);
    const clauses = this.extractClauses(query);
    return QueryContext.create({
      query,
      cursorPosition,
      currentToken,
      previousTokens,
      queryType,
      currentClause,
      clauses
    });
  }
  tokenizeQuery(query, upToCursor) {
    const tokens = [];
    const regex = /\S+/g;
    let match;
    while ((match = regex.exec(query)) !== null) {
      if (match.index >= upToCursor)
        break;
      tokens.push({
        text: match[0],
        position: match.index
      });
    }
    return tokens;
  }
  getCurrentToken(query, cursorPosition) {
    const beforeCursor = query.substring(0, cursorPosition);
    const afterCursor = query.substring(cursorPosition);
    const beforeMatch = beforeCursor.match(/\S+$/);
    const afterMatch = afterCursor.match(/^\S+/);
    const before = beforeMatch ? beforeMatch[0] : "";
    const after = afterMatch ? afterMatch[0] : "";
    return before + after;
  }
  detectQueryType(tokens) {
    if (tokens.length === 0)
      return null;
    const firstToken = tokens[0].text.toUpperCase();
    switch (firstToken) {
      case "SELECT":
        return "SELECT" /* SELECT */;
      case "CONSTRUCT":
        return "CONSTRUCT" /* CONSTRUCT */;
      case "ASK":
        return "ASK" /* ASK */;
      case "DESCRIBE":
        return "DESCRIBE" /* DESCRIBE */;
      case "INSERT":
        return "INSERT" /* INSERT */;
      case "DELETE":
        return "DELETE" /* DELETE */;
      default:
        return null;
    }
  }
  detectCurrentClause(query, cursorPosition) {
    const beforeCursor = query.substring(0, cursorPosition).toUpperCase();
    const clausePatterns = [
      { pattern: /WHERE\s*\{[^}]*$/, type: "WHERE" /* WHERE */ },
      { pattern: /FILTER\s*\([^)]*$/, type: "FILTER" /* FILTER */ },
      { pattern: /OPTIONAL\s*\{[^}]*$/, type: "OPTIONAL" /* OPTIONAL */ },
      { pattern: /UNION\s*\{[^}]*$/, type: "UNION" /* UNION */ },
      { pattern: /ORDER\s+BY\s+[^{]*$/, type: "ORDER_BY" /* ORDER_BY */ },
      { pattern: /GROUP\s+BY\s+[^{]*$/, type: "GROUP_BY" /* GROUP_BY */ },
      { pattern: /SELECT\s+[^{]*$/, type: "SELECT" /* SELECT */ },
      { pattern: /PREFIX\s+\S*:\s*<[^>]*$/, type: "PREFIX" /* PREFIX */ }
    ];
    for (const { pattern, type } of clausePatterns) {
      if (pattern.test(beforeCursor)) {
        return type;
      }
    }
    return null;
  }
  extractClauses(query) {
    const clauses = [];
    const selectMatch = query.match(/SELECT\s+(.*?)(?:WHERE|FROM|$)/si);
    if (selectMatch && selectMatch.index !== void 0) {
      const variables = this.extractVariables(selectMatch[1]);
      clauses.push({
        type: "SELECT" /* SELECT */,
        startPosition: selectMatch.index,
        endPosition: selectMatch.index + selectMatch[0].length,
        variables,
        content: selectMatch[0]
      });
    }
    const whereMatch = query.match(/WHERE\s*\{([^}]*)}/si);
    if (whereMatch && whereMatch.index !== void 0) {
      const variables = this.extractVariables(whereMatch[1]);
      clauses.push({
        type: "WHERE" /* WHERE */,
        startPosition: whereMatch.index,
        endPosition: whereMatch.index + whereMatch[0].length,
        variables,
        content: whereMatch[0]
      });
    }
    return clauses;
  }
  extractVariables(text) {
    const variables = /* @__PURE__ */ new Set();
    const regex = /\?(\w+)/g;
    let match;
    while ((match = regex.exec(text)) !== null) {
      variables.add(match[1]);
    }
    return Array.from(variables);
  }
  async collectSuggestions(context, options) {
    const suggestions = [];
    const promises = [];
    if (this.shouldIncludeKeywords(context)) {
      promises.push(this.suggestionRepository.findKeywordSuggestions(context));
    }
    if (this.shouldIncludeProperties(context)) {
      promises.push(this.suggestionRepository.findPropertySuggestions(context));
    }
    if (this.shouldIncludeClasses(context)) {
      promises.push(this.suggestionRepository.findClassSuggestions(context));
    }
    if (this.shouldIncludeVariables(context)) {
      promises.push(this.suggestionRepository.findVariableSuggestions(context));
    }
    if (this.shouldIncludeFunctions(context)) {
      promises.push(this.suggestionRepository.findFunctionSuggestions(context));
    }
    if (this.shouldIncludeTemplates(context)) {
      promises.push(this.suggestionRepository.findTemplateSuggestions(context));
    }
    const results = await Promise.all(promises);
    for (const result of results) {
      if (result.isSuccess) {
        suggestions.push(...result.getValue());
      }
    }
    return this.deduplicateSuggestions(suggestions);
  }
  shouldIncludeKeywords(context) {
    return true;
  }
  shouldIncludeProperties(context) {
    return context.isInClause("WHERE" /* WHERE */) || context.isInClause("OPTIONAL" /* OPTIONAL */) || context.isInClause("FILTER" /* FILTER */);
  }
  shouldIncludeClasses(context) {
    const previousTokens = context.getPreviousTokens();
    const lastTwo = previousTokens.slice(-2).join(" ");
    return lastTwo.includes("rdf:type") || lastTwo.includes("a ") || context.getCurrentToken().startsWith(":");
  }
  shouldIncludeVariables(context) {
    return context.getQuery().includes("?") || context.getCurrentToken().startsWith("?") || context.isInClause("SELECT" /* SELECT */) || context.isInClause("WHERE" /* WHERE */);
  }
  shouldIncludeFunctions(context) {
    const query = context.getQuery().toUpperCase();
    const cursorPos = context.getCursorPosition();
    if (context.isInClause("FILTER" /* FILTER */)) {
      return true;
    }
    const beforeCursor = query.substring(0, cursorPos);
    if (beforeCursor.includes("FILTER(") && !beforeCursor.includes(")")) {
      return true;
    }
    const currentToken = context.getCurrentToken().toUpperCase();
    return currentToken.startsWith("STR") || currentToken.startsWith("REGEX") || currentToken.startsWith("BOUND") || currentToken.startsWith("LANG");
  }
  shouldIncludeTemplates(context) {
    return context.isStartOfQuery() || !context.getQueryType() && context.getCurrentToken().length < 3;
  }
  deduplicateSuggestions(suggestions) {
    const seen = /* @__PURE__ */ new Set();
    return suggestions.filter((s) => {
      const key = `${s.getType()}-${s.getText()}`;
      if (seen.has(key))
        return false;
      seen.add(key);
      return true;
    });
  }
  rankSuggestions(suggestions, context, options) {
    const currentToken = context.getCurrentToken().toLowerCase();
    return suggestions.map((suggestion) => {
      let score = suggestion.calculateFinalScore();
      if (currentToken && suggestion.getText().toLowerCase().startsWith(currentToken)) {
        score *= 1.5;
      }
      if (options.contextBoost && this.isContextuallyRelevant(suggestion, context)) {
        score *= 1.3;
      }
      return { suggestion, score };
    }).sort((a, b) => b.score - a.score).map((item) => item.suggestion);
  }
  isContextuallyRelevant(suggestion, context) {
    if (suggestion.getType() === "keyword" /* KEYWORD */) {
      if (suggestion.getText() === "WHERE" && !context.getQueryType())
        return false;
      if (suggestion.getText() === "WHERE" && context.isAfterClause("WHERE" /* WHERE */))
        return false;
    }
    if (suggestion.getType() === "variable" /* VARIABLE */) {
      const existingVars = context.getVariablesInScope();
      if (existingVars.includes(suggestion.getText().substring(1))) {
        return true;
      }
    }
    return true;
  }
  getCachedSuggestions(context) {
    const cacheKey = this.getCacheKey(context);
    const cached = this.cache.get(cacheKey);
    if (!cached)
      return null;
    if (Date.now() - cached.timestamp > this.cacheTTL) {
      this.cache.delete(cacheKey);
      return null;
    }
    return cached.suggestions;
  }
  cacheSuggestions(context, suggestions) {
    const cacheKey = this.getCacheKey(context);
    this.cache.set(cacheKey, {
      suggestions,
      timestamp: Date.now()
    });
    if (this.cache.size > 100) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey)
        this.cache.delete(firstKey);
    }
  }
  getCacheKey(context) {
    return `${context.getQuery().substring(0, context.getCursorPosition())}-${context.getCurrentToken()}`;
  }
  clearCache() {
    this.cache.clear();
  }
};

// src/infrastructure/autocomplete/KeywordSuggestionProvider.ts
var KeywordSuggestionProvider = class {
  constructor() {
    this.keywords = [
      {
        text: "SELECT",
        insertText: "SELECT ",
        description: "Retrieve specific variables from the dataset",
        contexts: ["start"],
        confidence: 1,
        examples: ["SELECT ?subject ?predicate ?object", "SELECT DISTINCT ?class", "SELECT *"]
      },
      {
        text: "CONSTRUCT",
        insertText: "CONSTRUCT {\n  \n} WHERE {\n  \n}",
        description: "Create new RDF triples based on query patterns",
        contexts: ["start"],
        confidence: 0.9,
        examples: ["CONSTRUCT { ?s rdfs:label ?label } WHERE { ?s skos:prefLabel ?label }"]
      },
      {
        text: "ASK",
        insertText: "ASK ",
        description: "Test whether a query pattern has a solution",
        contexts: ["start"],
        confidence: 0.8,
        examples: ["ASK { ?s rdf:type ?class }", "ASK WHERE { ?s ?p ?o }"]
      },
      {
        text: "DESCRIBE",
        insertText: "DESCRIBE ",
        description: "Return an RDF graph describing the resources",
        contexts: ["start"],
        confidence: 0.7,
        examples: ["DESCRIBE ?resource", "DESCRIBE <http://example.org/resource>"]
      },
      {
        text: "WHERE",
        insertText: "WHERE {\n  \n}",
        description: "Specify graph patterns to match",
        contexts: ["after_select", "after_construct", "after_ask", "after_describe"],
        confidence: 1
      },
      {
        text: "FILTER",
        insertText: "FILTER(",
        description: "Apply constraints to query results",
        contexts: ["in_where"],
        confidence: 0.9,
        examples: ["FILTER(?age > 18)", 'FILTER(LANG(?label) = "en")', 'FILTER(REGEX(?name, "^John"))']
      },
      {
        text: "OPTIONAL",
        insertText: "OPTIONAL {\n  \n}",
        description: "Include optional graph patterns",
        contexts: ["in_where"],
        confidence: 0.8,
        examples: ["OPTIONAL { ?s rdfs:label ?label }"]
      },
      {
        text: "UNION",
        insertText: "UNION",
        description: "Combine results from alternative patterns",
        contexts: ["in_where"],
        confidence: 0.7,
        examples: ["{ ?s rdf:type :ClassA } UNION { ?s rdf:type :ClassB }"]
      },
      {
        text: "ORDER BY",
        insertText: "ORDER BY ",
        description: "Sort query results",
        contexts: ["after_where"],
        confidence: 0.9,
        examples: ["ORDER BY ?name", "ORDER BY DESC(?count)", "ORDER BY ?lastName ?firstName"]
      },
      {
        text: "GROUP BY",
        insertText: "GROUP BY ",
        description: "Group results by one or more variables",
        contexts: ["after_where"],
        confidence: 0.8,
        examples: ["GROUP BY ?category", "GROUP BY ?year ?month"]
      },
      {
        text: "HAVING",
        insertText: "HAVING(",
        description: "Filter grouped results",
        contexts: ["after_group_by"],
        confidence: 0.7,
        examples: ["HAVING(COUNT(?item) > 5)", "HAVING(SUM(?amount) < 1000)"]
      },
      {
        text: "LIMIT",
        insertText: "LIMIT ",
        description: "Limit the number of results",
        contexts: ["after_where", "after_order_by"],
        confidence: 0.9,
        examples: ["LIMIT 10", "LIMIT 100", "LIMIT 1000"]
      },
      {
        text: "OFFSET",
        insertText: "OFFSET ",
        description: "Skip a number of results",
        contexts: ["after_limit", "after_where"],
        confidence: 0.7,
        examples: ["OFFSET 20", "OFFSET 100"]
      },
      {
        text: "DISTINCT",
        insertText: "DISTINCT ",
        description: "Remove duplicate results",
        contexts: ["after_select"],
        confidence: 0.8,
        examples: ["SELECT DISTINCT ?class", "SELECT DISTINCT ?author ?title"]
      },
      {
        text: "PREFIX",
        insertText: "PREFIX ",
        description: "Define namespace prefix",
        contexts: ["start", "before_select"],
        confidence: 0.95,
        examples: [
          "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>",
          "PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>",
          "PREFIX exo: <http://example.org/exocortex#>"
        ]
      },
      {
        text: "BIND",
        insertText: "BIND(",
        description: "Assign a value to a variable",
        contexts: ["in_where"],
        confidence: 0.7,
        examples: ['BIND(?firstName + " " + ?lastName AS ?fullName)', "BIND(NOW() AS ?currentTime)"]
      },
      {
        text: "VALUES",
        insertText: "VALUES ",
        description: "Provide inline data",
        contexts: ["in_where"],
        confidence: 0.6,
        examples: ["VALUES ?type { :TypeA :TypeB :TypeC }"]
      }
    ];
  }
  getSuggestions(context) {
    const contextType = this.determineContextType(context);
    const currentToken = context.getCurrentToken().toUpperCase();
    return this.keywords.filter((keyword) => this.isKeywordApplicable(keyword, contextType, context)).filter((keyword) => {
      if (!currentToken)
        return true;
      return keyword.text.startsWith(currentToken);
    }).map((keyword) => this.createSuggestion(keyword, context));
  }
  determineContextType(context) {
    if (context.isStartOfQuery()) {
      return "start";
    }
    const queryType = context.getQueryType();
    const currentClause = context.getCurrentClause();
    if (queryType && !currentClause) {
      return `after_${queryType.toLowerCase()}`;
    }
    if (currentClause === "WHERE" /* WHERE */) {
      return "in_where";
    }
    if (currentClause === "GROUP_BY" /* GROUP_BY */) {
      return "after_group_by";
    }
    if (context.isAfterClause("WHERE" /* WHERE */)) {
      return "after_where";
    }
    if (context.isAfterClause("ORDER_BY" /* ORDER_BY */)) {
      return "after_order_by";
    }
    if (context.isAfterClause("LIMIT" /* LIMIT */)) {
      return "after_limit";
    }
    return "general";
  }
  isKeywordApplicable(keyword, contextType, context) {
    if (keyword.contexts.includes("general")) {
      return true;
    }
    if (keyword.contexts.includes(contextType)) {
      if (keyword.text === "WHERE") {
        return !context.isAfterClause("WHERE" /* WHERE */);
      }
      return true;
    }
    const token = context.getCurrentToken().toUpperCase();
    if (token && keyword.text.startsWith(token)) {
      return true;
    }
    return false;
  }
  createSuggestion(keyword, context) {
    const contextualScore = this.calculateContextualScore(keyword, context);
    return SPARQLSuggestion.create({
      id: `keyword_${keyword.text.toLowerCase().replace(/\s+/g, "_")}`,
      text: keyword.text,
      insertText: keyword.insertText,
      type: "keyword" /* KEYWORD */,
      confidence: keyword.confidence,
      contextualScore,
      metadata: {
        description: keyword.description,
        examples: keyword.examples
      }
    });
  }
  calculateContextualScore(keyword, context) {
    let score = 0.5;
    if (context.isStartOfQuery() && keyword.contexts.includes("start")) {
      score = 1;
    } else if (this.isLogicalNext(keyword, context)) {
      score = 0.9;
    } else if (this.isCommonPattern(keyword, context)) {
      score = 0.8;
    }
    return score;
  }
  isLogicalNext(keyword, context) {
    const queryType = context.getQueryType();
    if (queryType && keyword.text === "WHERE" && !context.getCurrentClause()) {
      return true;
    }
    if (context.isInClause("WHERE" /* WHERE */) && (keyword.text === "FILTER" || keyword.text === "OPTIONAL")) {
      return true;
    }
    if (context.isAfterClause("WHERE" /* WHERE */) && (keyword.text === "ORDER BY" || keyword.text === "LIMIT")) {
      return true;
    }
    return false;
  }
  isCommonPattern(keyword, context) {
    const patterns = [
      ["SELECT", "WHERE"],
      ["WHERE", "FILTER"],
      ["ORDER BY", "LIMIT"],
      ["GROUP BY", "HAVING"]
    ];
    const previousTokens = context.getPreviousTokens();
    const lastKeyword = previousTokens.reverse().find((token) => this.keywords.some((k) => k.text === token.toUpperCase()));
    if (!lastKeyword)
      return false;
    return patterns.some((pattern) => {
      const index = pattern.indexOf(lastKeyword.toUpperCase());
      return index >= 0 && index < pattern.length - 1 && pattern[index + 1] === keyword.text;
    });
  }
};

// src/infrastructure/repositories/GraphSuggestionRepository.ts
var GraphSuggestionRepository = class {
  // 1 minute
  constructor(graph) {
    this.graph = graph;
    this.keywordProvider = new KeywordSuggestionProvider();
    this.usageStats = {};
    this.propertyCache = /* @__PURE__ */ new Map();
    this.classCache = /* @__PURE__ */ new Map();
    this.cacheTimestamp = 0;
    this.cacheTTL = 6e4;
  }
  async findKeywordSuggestions(context) {
    try {
      const suggestions = this.keywordProvider.getSuggestions(context);
      return Result.ok(suggestions);
    } catch (error) {
      return Result.fail(`Failed to get keyword suggestions: ${error}`);
    }
  }
  async findPropertySuggestions(context) {
    try {
      if (this.shouldRefreshCache()) {
        this.refreshPropertyCache();
      }
      const cachedSuggestions = this.propertyCache.get(context.getCurrentToken());
      if (cachedSuggestions) {
        return Result.ok(cachedSuggestions);
      }
      const properties = this.extractPropertiesFromGraph();
      const suggestions = properties.map((prop) => this.createPropertySuggestion(prop, context));
      this.propertyCache.set(context.getCurrentToken(), suggestions);
      return Result.ok(suggestions);
    } catch (error) {
      return Result.fail(`Failed to get property suggestions: ${error}`);
    }
  }
  async findClassSuggestions(context) {
    try {
      if (this.shouldRefreshCache()) {
        this.refreshClassCache();
      }
      const cachedSuggestions = this.classCache.get(context.getCurrentToken());
      if (cachedSuggestions) {
        return Result.ok(cachedSuggestions);
      }
      const classes = this.extractClassesFromGraph();
      const suggestions = classes.map((cls) => this.createClassSuggestion(cls, context));
      this.classCache.set(context.getCurrentToken(), suggestions);
      return Result.ok(suggestions);
    } catch (error) {
      return Result.fail(`Failed to get class suggestions: ${error}`);
    }
  }
  async findVariableSuggestions(context) {
    try {
      const suggestions = [];
      const existingVariables = context.getVariablesInScope();
      const currentToken = context.getCurrentToken();
      for (const variable of existingVariables) {
        const varName = `?${variable}`;
        if (!currentToken || varName.startsWith(currentToken)) {
          suggestions.push(SPARQLSuggestion.create({
            id: `var_existing_${variable}`,
            text: varName,
            insertText: varName,
            type: "variable" /* VARIABLE */,
            confidence: 0.9,
            contextualScore: 0.95,
            metadata: {
              description: "Existing variable in query",
              usage: "Reuse this variable to join patterns"
            }
          }));
        }
      }
      const commonVariables = [
        { name: "subject", desc: "Subject of a triple" },
        { name: "predicate", desc: "Predicate/property" },
        { name: "object", desc: "Object value" },
        { name: "type", desc: "RDF type/class" },
        { name: "label", desc: "Human-readable label" },
        { name: "value", desc: "Generic value" },
        { name: "name", desc: "Name property" },
        { name: "id", desc: "Identifier" },
        { name: "date", desc: "Date/time value" },
        { name: "count", desc: "Count aggregate" }
      ];
      for (const { name, desc } of commonVariables) {
        const varName = `?${name}`;
        if (!existingVariables.includes(name) && (!currentToken || varName.startsWith(currentToken))) {
          suggestions.push(SPARQLSuggestion.create({
            id: `var_common_${name}`,
            text: varName,
            insertText: varName,
            type: "variable" /* VARIABLE */,
            confidence: 0.7,
            contextualScore: 0.6,
            metadata: {
              description: desc,
              usage: `Common variable name for ${desc.toLowerCase()}`
            }
          }));
        }
      }
      return Result.ok(suggestions);
    } catch (error) {
      return Result.fail(`Failed to get variable suggestions: ${error}`);
    }
  }
  async findNamespaceSuggestions(context) {
    try {
      const namespaces = [
        { prefix: "rdf:", uri: "http://www.w3.org/1999/02/22-rdf-syntax-ns#" },
        { prefix: "rdfs:", uri: "http://www.w3.org/2000/01/rdf-schema#" },
        { prefix: "owl:", uri: "http://www.w3.org/2002/07/owl#" },
        { prefix: "xsd:", uri: "http://www.w3.org/2001/XMLSchema#" },
        { prefix: "skos:", uri: "http://www.w3.org/2004/02/skos/core#" },
        { prefix: "foaf:", uri: "http://xmlns.com/foaf/0.1/" },
        { prefix: "dc:", uri: "http://purl.org/dc/elements/1.1/" },
        { prefix: "exo:", uri: "http://example.org/exocortex#" }
      ];
      const suggestions = namespaces.filter((ns) => !context.getCurrentToken() || ns.prefix.startsWith(context.getCurrentToken())).map((ns) => SPARQLSuggestion.create({
        id: `namespace_${ns.prefix}`,
        text: ns.prefix,
        insertText: `PREFIX ${ns.prefix} <${ns.uri}>`,
        type: "namespace" /* NAMESPACE */,
        confidence: 0.85,
        contextualScore: 0.8,
        metadata: {
          description: `Namespace: ${ns.uri}`,
          namespace: ns.uri
        }
      }));
      return Result.ok(suggestions);
    } catch (error) {
      return Result.fail(`Failed to get namespace suggestions: ${error}`);
    }
  }
  async findFunctionSuggestions(context) {
    try {
      const functions = [
        { name: "STR", desc: "Convert to string", example: "STR(?value)" },
        { name: "LANG", desc: "Get language tag", example: "LANG(?label)" },
        { name: "DATATYPE", desc: "Get datatype IRI", example: "DATATYPE(?literal)" },
        { name: "BOUND", desc: "Test if variable is bound", example: "BOUND(?var)" },
        { name: "REGEX", desc: "Regular expression match", example: 'REGEX(?text, "pattern")' },
        { name: "CONTAINS", desc: "String contains", example: 'CONTAINS(?str, "substring")' },
        { name: "STRSTARTS", desc: "String starts with", example: 'STRSTARTS(?str, "prefix")' },
        { name: "STRENDS", desc: "String ends with", example: 'STRENDS(?str, "suffix")' },
        { name: "STRLEN", desc: "String length", example: "STRLEN(?str)" },
        { name: "SUBSTR", desc: "Substring", example: "SUBSTR(?str, 1, 10)" },
        { name: "UCASE", desc: "Convert to uppercase", example: "UCASE(?str)" },
        { name: "LCASE", desc: "Convert to lowercase", example: "LCASE(?str)" },
        { name: "COUNT", desc: "Count aggregate", example: "COUNT(?item)" },
        { name: "SUM", desc: "Sum aggregate", example: "SUM(?value)" },
        { name: "AVG", desc: "Average aggregate", example: "AVG(?value)" },
        { name: "MIN", desc: "Minimum value", example: "MIN(?value)" },
        { name: "MAX", desc: "Maximum value", example: "MAX(?value)" },
        { name: "NOW", desc: "Current date/time", example: "NOW()" },
        { name: "YEAR", desc: "Extract year", example: "YEAR(?date)" },
        { name: "MONTH", desc: "Extract month", example: "MONTH(?date)" }
      ];
      const currentToken = context.getCurrentToken().toUpperCase();
      const suggestions = functions.filter((fn) => !currentToken || fn.name.startsWith(currentToken)).map((fn) => SPARQLSuggestion.create({
        id: `function_${fn.name.toLowerCase()}`,
        text: fn.name,
        insertText: fn.name + "(",
        type: "function" /* FUNCTION */,
        confidence: 0.8,
        contextualScore: context.isInClause("FILTER" /* FILTER */) ? 0.9 : 0.6,
        metadata: {
          description: fn.desc,
          examples: [fn.example]
        }
      }));
      return Result.ok(suggestions);
    } catch (error) {
      return Result.fail(`Failed to get function suggestions: ${error}`);
    }
  }
  async findTemplateSuggestions(context) {
    try {
      const templates = [
        {
          name: "Basic SELECT Query",
          template: "SELECT ?subject ?predicate ?object\nWHERE {\n  ?subject ?predicate ?object .\n}\nLIMIT 100",
          description: "Simple triple pattern query"
        },
        {
          name: "Find All Classes",
          template: "SELECT DISTINCT ?class\nWHERE {\n  ?instance rdf:type ?class .\n}\nORDER BY ?class",
          description: "List all classes in the graph"
        },
        {
          name: "Find All Properties",
          template: "SELECT DISTINCT ?property\nWHERE {\n  ?subject ?property ?object .\n}\nORDER BY ?property",
          description: "List all properties used in the graph"
        },
        {
          name: "Get Class Instances",
          template: "SELECT ?instance ?label\nWHERE {\n  ?instance rdf:type <ClassURI> .\n  OPTIONAL { ?instance rdfs:label ?label }\n}",
          description: "Find all instances of a specific class"
        },
        {
          name: "Count by Type",
          template: "SELECT ?type (COUNT(?instance) AS ?count)\nWHERE {\n  ?instance rdf:type ?type .\n}\nGROUP BY ?type\nORDER BY DESC(?count)",
          description: "Count instances per class"
        },
        {
          name: "Search by Label",
          template: 'SELECT ?resource ?label\nWHERE {\n  ?resource rdfs:label ?label .\n  FILTER(CONTAINS(LCASE(?label), "search term"))\n}',
          description: "Find resources by label text"
        }
      ];
      const suggestions = templates.map(
        (template, index) => SPARQLSuggestion.create({
          id: `template_${index}`,
          text: template.name,
          insertText: template.template,
          type: "template" /* TEMPLATE */,
          confidence: 0.75,
          contextualScore: context.isStartOfQuery() ? 0.9 : 0.3,
          metadata: {
            description: template.description,
            documentation: "Query template - customize as needed"
          }
        })
      );
      return Result.ok(suggestions);
    } catch (error) {
      return Result.fail(`Failed to get template suggestions: ${error}`);
    }
  }
  async updateUsageStatistics(suggestionId, selected) {
    try {
      if (!this.usageStats[suggestionId]) {
        this.usageStats[suggestionId] = { count: 0, lastUsed: 0 };
      }
      if (selected) {
        this.usageStats[suggestionId].count++;
        this.usageStats[suggestionId].lastUsed = Date.now();
      }
      return Result.ok();
    } catch (error) {
      return Result.fail(`Failed to update usage statistics: ${error}`);
    }
  }
  async getPopularSuggestions(limit) {
    try {
      const sortedIds = Object.entries(this.usageStats).sort((a, b) => b[1].count - a[1].count).slice(0, limit).map(([id]) => id);
      return Result.ok([]);
    } catch (error) {
      return Result.fail(`Failed to get popular suggestions: ${error}`);
    }
  }
  extractPropertiesFromGraph() {
    const properties = /* @__PURE__ */ new Map();
    try {
      const triples = this.graph.match(void 0, void 0, void 0);
      for (const triple of triples) {
        const predicate = triple.getPredicate().toString();
        properties.set(predicate, (properties.get(predicate) || 0) + 1);
      }
    } catch (error) {
      console.warn("Failed to extract properties from graph:", error);
    }
    return Array.from(properties.entries()).map(([uri, frequency]) => ({ uri, frequency })).sort((a, b) => b.frequency - a.frequency);
  }
  extractClassesFromGraph() {
    const classes = /* @__PURE__ */ new Map();
    const rdfType = "http://www.w3.org/1999/02/22-rdf-syntax-ns#type";
    try {
      const triples = this.graph.match(void 0, void 0, void 0);
      for (const triple of triples) {
        if (triple.getPredicate().toString() === rdfType) {
          const classUri = triple.getObject().toString();
          classes.set(classUri, (classes.get(classUri) || 0) + 1);
        }
      }
    } catch (error) {
      console.warn("Failed to extract classes from graph:", error);
    }
    return Array.from(classes.entries()).map(([uri, instanceCount]) => ({ uri, instanceCount })).sort((a, b) => b.instanceCount - a.instanceCount);
  }
  createPropertySuggestion(property, context) {
    const shortName = this.getShortName(property.uri);
    const confidence = Math.min(0.9, 0.5 + property.frequency / 100);
    return SPARQLSuggestion.create({
      id: `property_${property.uri}`,
      text: shortName,
      insertText: shortName,
      type: "property" /* PROPERTY */,
      confidence,
      contextualScore: context.isInClause("WHERE" /* WHERE */) ? 0.9 : 0.5,
      metadata: {
        description: `Property (used ${property.frequency} times)`,
        namespace: property.uri
      }
    });
  }
  createClassSuggestion(cls, context) {
    const shortName = this.getShortName(cls.uri);
    const confidence = Math.min(0.9, 0.5 + cls.instanceCount / 50);
    return SPARQLSuggestion.create({
      id: `class_${cls.uri}`,
      text: shortName,
      insertText: shortName,
      type: "class" /* CLASS */,
      confidence,
      contextualScore: this.isAfterRdfType(context) ? 0.95 : 0.6,
      metadata: {
        description: `Class (${cls.instanceCount} instances)`,
        namespace: cls.uri
      }
    });
  }
  getShortName(uri) {
    const hashIndex = uri.lastIndexOf("#");
    const slashIndex = uri.lastIndexOf("/");
    const splitIndex = Math.max(hashIndex, slashIndex);
    if (splitIndex > 0 && splitIndex < uri.length - 1) {
      return uri.substring(splitIndex + 1);
    }
    return uri;
  }
  isAfterRdfType(context) {
    const previousTokens = context.getPreviousTokens();
    if (previousTokens.length < 2)
      return false;
    const lastTwo = previousTokens.slice(-2).join(" ").toLowerCase();
    return lastTwo.includes("rdf:type") || lastTwo.includes(" a ");
  }
  shouldRefreshCache() {
    return Date.now() - this.cacheTimestamp > this.cacheTTL;
  }
  refreshPropertyCache() {
    this.propertyCache.clear();
    this.cacheTimestamp = Date.now();
  }
  refreshClassCache() {
    this.classCache.clear();
    this.cacheTimestamp = Date.now();
  }
};

// src/infrastructure/repositories/BuiltInQueryTemplates.ts
var BuiltInQueryTemplates = class {
  static getAll() {
    if (this.templates.length === 0) {
      this.templates = this.createBuiltInTemplates();
    }
    return [...this.templates];
  }
  static createBuiltInTemplates() {
    return [
      this.createFindAllRelatedTemplate(),
      this.createPropertyChainTemplate(),
      this.createTypeHierarchyTemplate(),
      this.createEntityPropertiesTemplate(),
      this.createOptionalPropertiesTemplate(),
      this.createFilterByValueTemplate(),
      this.createCountEntitiesTemplate(),
      this.createFindByLabelTemplate(),
      this.createRelationshipPathTemplate(),
      this.createValueComparisonTemplate()
    ];
  }
  static createFindAllRelatedTemplate() {
    const layout = {
      nodes: [
        {
          id: "entity1",
          type: "entity" /* ENTITY */,
          label: "{{entityName}}",
          position: { x: 100, y: 200 },
          uri: "{{entityUri}}"
        },
        {
          id: "var1",
          type: "variable" /* VARIABLE */,
          label: "related",
          position: { x: 400, y: 200 },
          variableName: "related"
        }
      ],
      edges: [
        {
          id: "edge1",
          sourceNodeId: "entity1",
          targetNodeId: "var1",
          type: "property" /* PROPERTY */,
          label: "?property",
          propertyUri: void 0
        }
      ],
      viewport: { x: 0, y: 0, zoom: 1 }
    };
    return new QueryTemplate({
      id: "builtin_find_all_related",
      metadata: {
        name: "Find All Related",
        description: "Find all entities related to a specific entity",
        category: "exploration" /* EXPLORATION */,
        difficulty: "beginner" /* BEGINNER */,
        tags: ["exploration", "relationships", "basic"],
        author: "Exocortex",
        version: "1.0.0",
        createdAt: new Date(),
        updatedAt: new Date()
      },
      layout,
      parameters: [
        {
          name: "entityName",
          type: "entity",
          description: "Name of the entity to explore",
          required: true,
          placeholder: "Entity name"
        },
        {
          name: "entityUri",
          type: "entity",
          description: "URI of the entity",
          required: false,
          placeholder: "Optional entity URI"
        }
      ],
      sparqlTemplate: `SELECT ?property ?related
WHERE {
  <{{entityUri}}> ?property ?related .
}`,
      isBuiltIn: true
    });
  }
  static createPropertyChainTemplate() {
    const layout = {
      nodes: [
        {
          id: "start",
          type: "variable" /* VARIABLE */,
          label: "start",
          position: { x: 100, y: 200 },
          variableName: "start"
        },
        {
          id: "middle",
          type: "variable" /* VARIABLE */,
          label: "middle",
          position: { x: 300, y: 200 },
          variableName: "middle"
        },
        {
          id: "end",
          type: "variable" /* VARIABLE */,
          label: "end",
          position: { x: 500, y: 200 },
          variableName: "end"
        }
      ],
      edges: [
        {
          id: "edge1",
          sourceNodeId: "start",
          targetNodeId: "middle",
          type: "property" /* PROPERTY */,
          label: "{{property1}}",
          propertyUri: void 0
        },
        {
          id: "edge2",
          sourceNodeId: "middle",
          targetNodeId: "end",
          type: "property" /* PROPERTY */,
          label: "{{property2}}",
          propertyUri: void 0
        }
      ]
    };
    return new QueryTemplate({
      id: "builtin_property_chain",
      metadata: {
        name: "Property Chain",
        description: "Follow a chain of properties between entities",
        category: "relationship" /* RELATIONSHIP */,
        difficulty: "intermediate" /* INTERMEDIATE */,
        tags: ["path", "chain", "relationship"],
        author: "Exocortex",
        version: "1.0.0",
        createdAt: new Date(),
        updatedAt: new Date()
      },
      layout,
      parameters: [
        {
          name: "property1",
          type: "property",
          description: "First property in the chain",
          required: true,
          defaultValue: "hasParent"
        },
        {
          name: "property2",
          type: "property",
          description: "Second property in the chain",
          required: true,
          defaultValue: "hasChild"
        }
      ],
      sparqlTemplate: `SELECT ?start ?middle ?end
WHERE {
  ?start {{property1}} ?middle .
  ?middle {{property2}} ?end .
}`,
      isBuiltIn: true
    });
  }
  static createTypeHierarchyTemplate() {
    const layout = {
      nodes: [
        {
          id: "instance",
          type: "variable" /* VARIABLE */,
          label: "instance",
          position: { x: 100, y: 200 },
          variableName: "instance"
        },
        {
          id: "type",
          type: "entity" /* ENTITY */,
          label: "{{typeClass}}",
          position: { x: 400, y: 200 }
        }
      ],
      edges: [
        {
          id: "edge1",
          sourceNodeId: "instance",
          targetNodeId: "type",
          type: "property" /* PROPERTY */,
          label: "rdf:type",
          propertyUri: "http://www.w3.org/1999/02/22-rdf-syntax-ns#type"
        }
      ]
    };
    return new QueryTemplate({
      id: "builtin_type_hierarchy",
      metadata: {
        name: "Type Hierarchy",
        description: "Find all instances of a specific type or class",
        category: "analysis" /* ANALYSIS */,
        difficulty: "beginner" /* BEGINNER */,
        tags: ["type", "class", "hierarchy", "rdf"],
        author: "Exocortex",
        version: "1.0.0",
        createdAt: new Date(),
        updatedAt: new Date()
      },
      layout,
      parameters: [
        {
          name: "typeClass",
          type: "entity",
          description: "The type/class to search for",
          required: true,
          defaultValue: "Person"
        }
      ],
      sparqlTemplate: `SELECT ?instance
WHERE {
  ?instance rdf:type {{typeClass}} .
}`,
      isBuiltIn: true
    });
  }
  static createEntityPropertiesTemplate() {
    const layout = {
      nodes: [
        {
          id: "entity",
          type: "entity" /* ENTITY */,
          label: "{{entityName}}",
          position: { x: 100, y: 200 }
        },
        {
          id: "value",
          type: "variable" /* VARIABLE */,
          label: "value",
          position: { x: 400, y: 200 },
          variableName: "value"
        }
      ],
      edges: [
        {
          id: "edge1",
          sourceNodeId: "entity",
          targetNodeId: "value",
          type: "property" /* PROPERTY */,
          label: "?property",
          propertyUri: void 0
        }
      ]
    };
    return new QueryTemplate({
      id: "builtin_entity_properties",
      metadata: {
        name: "Entity Properties",
        description: "List all properties and values of an entity",
        category: "property" /* PROPERTY */,
        difficulty: "beginner" /* BEGINNER */,
        tags: ["properties", "attributes", "exploration"],
        author: "Exocortex",
        version: "1.0.0",
        createdAt: new Date(),
        updatedAt: new Date()
      },
      layout,
      parameters: [
        {
          name: "entityName",
          type: "entity",
          description: "Entity to explore",
          required: true
        }
      ],
      sparqlTemplate: `SELECT ?property ?value
WHERE {
  {{entityName}} ?property ?value .
}`,
      isBuiltIn: true
    });
  }
  static createOptionalPropertiesTemplate() {
    const layout = {
      nodes: [
        {
          id: "subject",
          type: "variable" /* VARIABLE */,
          label: "subject",
          position: { x: 100, y: 200 },
          variableName: "subject"
        },
        {
          id: "name",
          type: "variable" /* VARIABLE */,
          label: "name",
          position: { x: 400, y: 100 },
          variableName: "name"
        },
        {
          id: "description",
          type: "variable" /* VARIABLE */,
          label: "description",
          position: { x: 400, y: 300 },
          variableName: "description"
        }
      ],
      edges: [
        {
          id: "edge1",
          sourceNodeId: "subject",
          targetNodeId: "name",
          type: "property" /* PROPERTY */,
          label: "rdfs:label",
          propertyUri: "http://www.w3.org/2000/01/rdf-schema#label"
        },
        {
          id: "edge2",
          sourceNodeId: "subject",
          targetNodeId: "description",
          type: "optional" /* OPTIONAL */,
          label: "rdfs:comment",
          propertyUri: "http://www.w3.org/2000/01/rdf-schema#comment"
        }
      ]
    };
    return new QueryTemplate({
      id: "builtin_optional_properties",
      metadata: {
        name: "Optional Properties",
        description: "Query with optional properties that may or may not exist",
        category: "property" /* PROPERTY */,
        difficulty: "intermediate" /* INTERMEDIATE */,
        tags: ["optional", "properties", "flexible"],
        author: "Exocortex",
        version: "1.0.0",
        createdAt: new Date(),
        updatedAt: new Date()
      },
      layout,
      parameters: [],
      sparqlTemplate: `SELECT ?subject ?name ?description
WHERE {
  ?subject rdfs:label ?name .
  OPTIONAL { ?subject rdfs:comment ?description }
}`,
      isBuiltIn: true
    });
  }
  static createFilterByValueTemplate() {
    const layout = {
      nodes: [
        {
          id: "entity",
          type: "variable" /* VARIABLE */,
          label: "entity",
          position: { x: 100, y: 200 },
          variableName: "entity"
        },
        {
          id: "value",
          type: "variable" /* VARIABLE */,
          label: "value",
          position: { x: 400, y: 200 },
          variableName: "value"
        },
        {
          id: "filter",
          type: "filter" /* FILTER */,
          label: "?value > {{threshold}}",
          position: { x: 250, y: 350 }
        }
      ],
      edges: [
        {
          id: "edge1",
          sourceNodeId: "entity",
          targetNodeId: "value",
          type: "property" /* PROPERTY */,
          label: "{{property}}",
          propertyUri: void 0
        }
      ]
    };
    return new QueryTemplate({
      id: "builtin_filter_by_value",
      metadata: {
        name: "Filter by Value",
        description: "Find entities with property values matching a condition",
        category: "analysis" /* ANALYSIS */,
        difficulty: "intermediate" /* INTERMEDIATE */,
        tags: ["filter", "condition", "comparison"],
        author: "Exocortex",
        version: "1.0.0",
        createdAt: new Date(),
        updatedAt: new Date()
      },
      layout,
      parameters: [
        {
          name: "property",
          type: "property",
          description: "Property to filter on",
          required: true,
          defaultValue: "hasAge"
        },
        {
          name: "threshold",
          type: "literal",
          description: "Threshold value",
          required: true,
          defaultValue: "18",
          constraints: {
            pattern: "^\\d+$"
          }
        }
      ],
      sparqlTemplate: `SELECT ?entity ?value
WHERE {
  ?entity {{property}} ?value .
  FILTER (?value > {{threshold}})
}`,
      isBuiltIn: true
    });
  }
  static createCountEntitiesTemplate() {
    const layout = {
      nodes: [
        {
          id: "entity",
          type: "variable" /* VARIABLE */,
          label: "entity",
          position: { x: 100, y: 200 },
          variableName: "entity"
        },
        {
          id: "type",
          type: "entity" /* ENTITY */,
          label: "{{entityType}}",
          position: { x: 400, y: 200 }
        }
      ],
      edges: [
        {
          id: "edge1",
          sourceNodeId: "entity",
          targetNodeId: "type",
          type: "property" /* PROPERTY */,
          label: "rdf:type",
          propertyUri: "http://www.w3.org/1999/02/22-rdf-syntax-ns#type"
        }
      ]
    };
    return new QueryTemplate({
      id: "builtin_count_entities",
      metadata: {
        name: "Count Entities",
        description: "Count the number of entities of a specific type",
        category: "analysis" /* ANALYSIS */,
        difficulty: "beginner" /* BEGINNER */,
        tags: ["count", "aggregate", "statistics"],
        author: "Exocortex",
        version: "1.0.0",
        createdAt: new Date(),
        updatedAt: new Date()
      },
      layout,
      parameters: [
        {
          name: "entityType",
          type: "entity",
          description: "Type of entities to count",
          required: true,
          defaultValue: "Person"
        }
      ],
      sparqlTemplate: `SELECT (COUNT(?entity) AS ?count)
WHERE {
  ?entity rdf:type {{entityType}} .
}`,
      isBuiltIn: true
    });
  }
  static createFindByLabelTemplate() {
    const layout = {
      nodes: [
        {
          id: "entity",
          type: "variable" /* VARIABLE */,
          label: "entity",
          position: { x: 100, y: 200 },
          variableName: "entity"
        },
        {
          id: "label",
          type: "variable" /* VARIABLE */,
          label: "label",
          position: { x: 400, y: 200 },
          variableName: "label"
        },
        {
          id: "filter",
          type: "filter" /* FILTER */,
          label: 'regex(?label, "{{searchTerm}}", "i")',
          position: { x: 250, y: 350 }
        }
      ],
      edges: [
        {
          id: "edge1",
          sourceNodeId: "entity",
          targetNodeId: "label",
          type: "property" /* PROPERTY */,
          label: "rdfs:label",
          propertyUri: "http://www.w3.org/2000/01/rdf-schema#label"
        }
      ]
    };
    return new QueryTemplate({
      id: "builtin_find_by_label",
      metadata: {
        name: "Find by Label",
        description: "Search for entities by their label text",
        category: "exploration" /* EXPLORATION */,
        difficulty: "intermediate" /* INTERMEDIATE */,
        tags: ["search", "text", "label", "regex"],
        author: "Exocortex",
        version: "1.0.0",
        createdAt: new Date(),
        updatedAt: new Date()
      },
      layout,
      parameters: [
        {
          name: "searchTerm",
          type: "literal",
          description: "Text to search for in labels",
          required: true,
          placeholder: "Search term"
        }
      ],
      sparqlTemplate: `SELECT ?entity ?label
WHERE {
  ?entity rdfs:label ?label .
  FILTER (regex(?label, "{{searchTerm}}", "i"))
}`,
      isBuiltIn: true
    });
  }
  static createRelationshipPathTemplate() {
    const layout = {
      nodes: [
        {
          id: "source",
          type: "entity" /* ENTITY */,
          label: "{{sourceEntity}}",
          position: { x: 100, y: 200 }
        },
        {
          id: "target",
          type: "entity" /* ENTITY */,
          label: "{{targetEntity}}",
          position: { x: 500, y: 200 }
        }
      ],
      edges: [
        {
          id: "edge1",
          sourceNodeId: "source",
          targetNodeId: "target",
          type: "property" /* PROPERTY */,
          label: "{{relationship}}+",
          propertyUri: void 0
        }
      ]
    };
    return new QueryTemplate({
      id: "builtin_relationship_path",
      metadata: {
        name: "Relationship Path",
        description: "Find paths between two specific entities",
        category: "relationship" /* RELATIONSHIP */,
        difficulty: "advanced" /* ADVANCED */,
        tags: ["path", "connection", "graph", "traversal"],
        author: "Exocortex",
        version: "1.0.0",
        createdAt: new Date(),
        updatedAt: new Date()
      },
      layout,
      parameters: [
        {
          name: "sourceEntity",
          type: "entity",
          description: "Starting entity",
          required: true
        },
        {
          name: "targetEntity",
          type: "entity",
          description: "Target entity",
          required: true
        },
        {
          name: "relationship",
          type: "property",
          description: "Relationship type to follow",
          required: false,
          defaultValue: "knows"
        }
      ],
      sparqlTemplate: `SELECT ?path
WHERE {
  {{sourceEntity}} {{relationship}}+ {{targetEntity}} .
  BIND({{relationship}} AS ?path)
}`,
      isBuiltIn: true
    });
  }
  static createValueComparisonTemplate() {
    const layout = {
      nodes: [
        {
          id: "entity",
          type: "variable" /* VARIABLE */,
          label: "entity",
          position: { x: 250, y: 100 },
          variableName: "entity"
        },
        {
          id: "value1",
          type: "variable" /* VARIABLE */,
          label: "value1",
          position: { x: 100, y: 250 },
          variableName: "value1"
        },
        {
          id: "value2",
          type: "variable" /* VARIABLE */,
          label: "value2",
          position: { x: 400, y: 250 },
          variableName: "value2"
        },
        {
          id: "filter",
          type: "filter" /* FILTER */,
          label: "?value1 > ?value2",
          position: { x: 250, y: 400 }
        }
      ],
      edges: [
        {
          id: "edge1",
          sourceNodeId: "entity",
          targetNodeId: "value1",
          type: "property" /* PROPERTY */,
          label: "{{property1}}",
          propertyUri: void 0
        },
        {
          id: "edge2",
          sourceNodeId: "entity",
          targetNodeId: "value2",
          type: "property" /* PROPERTY */,
          label: "{{property2}}",
          propertyUri: void 0
        }
      ]
    };
    return new QueryTemplate({
      id: "builtin_value_comparison",
      metadata: {
        name: "Value Comparison",
        description: "Compare values of different properties on the same entity",
        category: "analysis" /* ANALYSIS */,
        difficulty: "advanced" /* ADVANCED */,
        tags: ["comparison", "analysis", "filter"],
        author: "Exocortex",
        version: "1.0.0",
        createdAt: new Date(),
        updatedAt: new Date()
      },
      layout,
      parameters: [
        {
          name: "property1",
          type: "property",
          description: "First property to compare",
          required: true,
          defaultValue: "hasIncome"
        },
        {
          name: "property2",
          type: "property",
          description: "Second property to compare",
          required: true,
          defaultValue: "hasExpenses"
        }
      ],
      sparqlTemplate: `SELECT ?entity ?value1 ?value2
WHERE {
  ?entity {{property1}} ?value1 .
  ?entity {{property2}} ?value2 .
  FILTER (?value1 > ?value2)
}`,
      isBuiltIn: true
    });
  }
};
BuiltInQueryTemplates.templates = [];

// src/infrastructure/repositories/ObsidianQueryTemplateRepository.ts
var ObsidianQueryTemplateRepository = class {
  constructor(app, templatesPath = ".exocortex/templates", usageDataPath = ".exocortex/template-usage.json") {
    this.app = app;
    this.templateCache = /* @__PURE__ */ new Map();
    this.usageData = /* @__PURE__ */ new Map();
    this.cacheLoaded = false;
    this.templatesPath = templatesPath;
    this.usageDataPath = usageDataPath;
  }
  async findAll() {
    await this.ensureCacheLoaded();
    const templates = Array.from(this.templateCache.values());
    return templates.sort((a, b) => {
      var _a, _b;
      const usageA = ((_a = this.usageData.get(a.getId())) == null ? void 0 : _a.usageCount) || 0;
      const usageB = ((_b = this.usageData.get(b.getId())) == null ? void 0 : _b.usageCount) || 0;
      if (usageA !== usageB) {
        return usageB - usageA;
      }
      return a.getMetadata().name.localeCompare(b.getMetadata().name);
    });
  }
  async findByCriteria(criteria) {
    await this.ensureCacheLoaded();
    let templates = Array.from(this.templateCache.values());
    if (criteria.category) {
      templates = templates.filter((t) => t.getMetadata().category === criteria.category);
    }
    if (criteria.difficulty) {
      templates = templates.filter((t) => t.getMetadata().difficulty === criteria.difficulty);
    }
    if (criteria.nameContains) {
      const searchTerm = criteria.nameContains.toLowerCase();
      templates = templates.filter(
        (t) => t.getMetadata().name.toLowerCase().includes(searchTerm) || t.getMetadata().description.toLowerCase().includes(searchTerm)
      );
    }
    if (criteria.tags && criteria.tags.length > 0) {
      templates = templates.filter((t) => {
        const templateTags = t.getMetadata().tags;
        return criteria.tags.some((tag) => templateTags.includes(tag));
      });
    }
    if (criteria.includeBuiltIn !== void 0) {
      templates = templates.filter((t) => t.isBuiltInTemplate() === criteria.includeBuiltIn);
    }
    if (criteria.includeCustom !== void 0) {
      templates = templates.filter((t) => !t.isBuiltInTemplate() === criteria.includeCustom);
    }
    return templates;
  }
  async findById(id) {
    await this.ensureCacheLoaded();
    return this.templateCache.get(id);
  }
  async findByCategory(category) {
    return this.findByCriteria({ category });
  }
  async findByTags(tags) {
    return this.findByCriteria({ tags });
  }
  async save(template) {
    if (template.isBuiltInTemplate()) {
      throw new Error("Cannot modify built-in templates");
    }
    const exists = await this.exists(template.getId());
    if (exists) {
      return this.update(template);
    } else {
      return this.create(template);
    }
  }
  async create(template) {
    if (template.isBuiltInTemplate()) {
      throw new Error("Cannot create built-in templates through repository");
    }
    const exists = await this.exists(template.getId());
    if (exists) {
      throw new Error(`Template with ID ${template.getId()} already exists`);
    }
    await this.ensureTemplatesDirectoryExists();
    const fileName = `${this.sanitizeFileName(template.getMetadata().name)}-${template.getId()}.json`;
    const filePath = `${this.templatesPath}/${fileName}`;
    const data = {
      id: template.getId(),
      metadata: template.getMetadata(),
      layout: template.getLayout(),
      parameters: template.getParameters(),
      sparqlTemplate: template.getSparqlTemplate(),
      isBuiltIn: template.isBuiltInTemplate()
    };
    await this.app.vault.create(filePath, JSON.stringify(data, null, 2));
    this.templateCache.set(template.getId(), template);
    return template;
  }
  async update(template) {
    if (template.isBuiltInTemplate()) {
      throw new Error("Cannot modify built-in templates");
    }
    const exists = await this.exists(template.getId());
    if (!exists) {
      throw new Error(`Template with ID ${template.getId()} not found`);
    }
    await this.ensureTemplatesDirectoryExists();
    const fileName = await this.findTemplateFile(template.getId());
    if (!fileName) {
      throw new Error(`Template file not found for ID ${template.getId()}`);
    }
    const filePath = `${this.templatesPath}/${fileName}`;
    const file = this.app.vault.getAbstractFileByPath(filePath);
    const data = {
      id: template.getId(),
      metadata: template.getMetadata(),
      layout: template.getLayout(),
      parameters: template.getParameters(),
      sparqlTemplate: template.getSparqlTemplate(),
      isBuiltIn: template.isBuiltInTemplate()
    };
    await this.app.vault.modify(file, JSON.stringify(data, null, 2));
    this.templateCache.set(template.getId(), template);
    return template;
  }
  async delete(id) {
    const template = await this.findById(id);
    if (!template) {
      return false;
    }
    if (template.isBuiltInTemplate()) {
      throw new Error("Cannot delete built-in templates");
    }
    const fileName = await this.findTemplateFile(id);
    if (!fileName) {
      return false;
    }
    const filePath = `${this.templatesPath}/${fileName}`;
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (file) {
      await this.app.vault.delete(file);
      this.templateCache.delete(id);
      this.usageData.delete(id);
      await this.saveUsageData();
      return true;
    }
    return false;
  }
  async exists(id) {
    await this.ensureCacheLoaded();
    return this.templateCache.has(id);
  }
  async importTemplates(templatesData) {
    const imported = [];
    for (const templateData of templatesData) {
      try {
        const data = templateData;
        const existing = this.templateCache.get(data.id);
        if (existing && existing.isBuiltInTemplate()) {
          continue;
        }
        const template = this.createTemplateFromData(data);
        await this.save(template);
        imported.push(template);
      } catch (error) {
        console.warn("Failed to import template:", error);
      }
    }
    return imported;
  }
  async exportTemplates(templateIds) {
    await this.ensureCacheLoaded();
    let templates;
    if (templateIds) {
      templates = templateIds.map((id) => this.templateCache.get(id)).filter((t) => t !== void 0);
    } else {
      templates = Array.from(this.templateCache.values());
    }
    return templates.map((template) => template.toJSON());
  }
  async getBuiltInTemplates() {
    return this.findByCriteria({ includeBuiltIn: true, includeCustom: false });
  }
  async getCustomTemplates() {
    return this.findByCriteria({ includeBuiltIn: false, includeCustom: true });
  }
  async getRecentlyUsed(limit = 10) {
    await this.ensureCacheLoaded();
    const templateUsage = Array.from(this.usageData.entries()).sort((a, b) => b[1].lastUsed.getTime() - a[1].lastUsed.getTime()).slice(0, limit);
    return templateUsage.map(([id]) => this.templateCache.get(id)).filter((t) => t !== void 0);
  }
  async recordUsage(templateId) {
    await this.ensureCacheLoaded();
    const existing = this.usageData.get(templateId);
    if (existing) {
      existing.usageCount++;
      existing.lastUsed = new Date();
    } else {
      this.usageData.set(templateId, {
        templateId,
        usageCount: 1,
        lastUsed: new Date(),
        parametersFilled: []
      });
    }
    await this.saveUsageData();
  }
  async getUsageStats(templateId) {
    await this.ensureCacheLoaded();
    const usage = this.usageData.get(templateId);
    if (!usage) {
      return { usageCount: 0 };
    }
    const averageParametersFilled = usage.parametersFilled.length > 0 ? usage.parametersFilled.reduce((sum, count) => sum + count, 0) / usage.parametersFilled.length : void 0;
    return {
      usageCount: usage.usageCount,
      lastUsed: usage.lastUsed,
      averageParametersFilled
    };
  }
  async refresh() {
    this.templateCache.clear();
    this.usageData.clear();
    this.cacheLoaded = false;
    await this.loadBuiltInTemplates();
    await this.loadCustomTemplates();
    await this.loadUsageData();
    this.cacheLoaded = true;
  }
  async ensureCacheLoaded() {
    if (!this.cacheLoaded) {
      await this.refresh();
    }
  }
  async ensureTemplatesDirectoryExists() {
    const templatesDir = this.app.vault.getAbstractFileByPath(this.templatesPath);
    if (!templatesDir) {
      await this.app.vault.createFolder(this.templatesPath);
    }
  }
  async loadBuiltInTemplates() {
    const builtInTemplates = BuiltInQueryTemplates.getAll();
    builtInTemplates.forEach((template) => {
      this.templateCache.set(template.getId(), template);
    });
  }
  async loadCustomTemplates() {
    await this.ensureTemplatesDirectoryExists();
    const templatesDir = this.app.vault.getAbstractFileByPath(this.templatesPath);
    if (!templatesDir || !templatesDir.children) {
      return;
    }
    const files = templatesDir.children.filter(
      (file) => file.extension === "json" && file.name.endsWith(".json")
    );
    for (const file of files) {
      try {
        const content = await this.app.vault.read(file);
        const data = JSON.parse(content);
        const template = this.createTemplateFromData(data);
        this.templateCache.set(template.getId(), template);
      } catch (error) {
        console.warn(`Failed to load template from ${file.path}:`, error);
      }
    }
  }
  async loadUsageData() {
    try {
      const file = this.app.vault.getAbstractFileByPath(this.usageDataPath);
      if (file) {
        const content = await this.app.vault.read(file);
        const data = JSON.parse(content);
        this.usageData.clear();
        data.forEach((usage) => {
          usage.lastUsed = new Date(usage.lastUsed);
          this.usageData.set(usage.templateId, usage);
        });
      }
    } catch (error) {
      this.usageData.clear();
    }
  }
  async saveUsageData() {
    const data = Array.from(this.usageData.values());
    const content = JSON.stringify(data, null, 2);
    const file = this.app.vault.getAbstractFileByPath(this.usageDataPath);
    if (file) {
      await this.app.vault.modify(file, content);
    } else {
      await this.app.vault.create(this.usageDataPath, content);
    }
  }
  async findTemplateFile(templateId) {
    await this.ensureTemplatesDirectoryExists();
    const templatesDir = this.app.vault.getAbstractFileByPath(this.templatesPath);
    if (!templatesDir || !templatesDir.children) {
      return null;
    }
    const files = templatesDir.children.filter(
      (file) => file.extension === "json" && file.name.includes(templateId)
    );
    return files.length > 0 ? files[0].name : null;
  }
  createTemplateFromData(data) {
    return new QueryTemplate({
      id: data.id,
      metadata: data.metadata,
      layout: data.layout,
      parameters: data.parameters,
      sparqlTemplate: data.sparqlTemplate || "SELECT * WHERE { ?s ?p ?o }",
      isBuiltIn: data.isBuiltIn
    });
  }
  sanitizeFileName(name) {
    return name.toLowerCase().replace(/[^\w\s-]/g, "").replace(/\s+/g, "-").substring(0, 50);
  }
};

// src/presentation/components/ButtonRenderer.ts
var import_obsidian12 = require("obsidian");
var ButtonRenderer = class {
  constructor(app, renderButtonsUseCase, executeCommandUseCase) {
    this.app = app;
    this.renderButtonsUseCase = renderButtonsUseCase;
    this.executeCommandUseCase = executeCommandUseCase;
  }
  /**
   * Render buttons for a class view
   */
  async render(container, className, assetId, context) {
    const result = await this.renderButtonsUseCase.execute({
      className,
      assetId,
      context
    });
    if (result.isFailure) {
      console.error(`Failed to render buttons: ${result.error}`);
      return;
    }
    const response = result.getValue();
    if (!response.displayOptions.showButtons || response.buttons.length === 0) {
      return;
    }
    const buttonContainer = container.createDiv({
      cls: `exocortex-button-container exocortex-buttons-${response.displayOptions.position}`
    });
    for (const buttonData of response.buttons) {
      this.renderButton(buttonContainer, buttonData, assetId, context);
    }
  }
  /**
   * Render individual button
   */
  renderButton(container, buttonData, assetId, context) {
    const button = new import_obsidian12.ButtonComponent(container).setButtonText(buttonData.label).onClick(async () => {
      await this.handleButtonClick(buttonData, assetId, context);
    });
    if (buttonData.tooltip) {
      button.setTooltip(buttonData.tooltip);
    }
    if (!buttonData.isEnabled) {
      button.setDisabled(true);
    }
    button.buttonEl.addClass("exocortex-ui-button");
    button.buttonEl.setAttribute("data-button-id", buttonData.buttonId);
    button.buttonEl.setAttribute("data-order", buttonData.order.toString());
  }
  /**
   * Handle button click
   */
  async handleButtonClick(buttonData, assetId, context) {
    const result = await this.executeCommandUseCase.execute({
      buttonId: buttonData.buttonId,
      assetId,
      context
    });
    if (result.isFailure) {
      console.error(`Button execution failed: ${result.error}`);
      this.showNotification(`Error: ${result.error}`, "error");
      return;
    }
    const response = result.getValue();
    if (response.requiresInput && response.inputSchema) {
      const modal = new CommandInputModal(
        this.app,
        response.inputSchema,
        async (inputValues) => {
          const execResult = await this.executeCommandUseCase.execute({
            buttonId: buttonData.buttonId,
            assetId,
            inputParameters: inputValues,
            context
          });
          if (execResult.isFailure) {
            this.showNotification(`Error: ${execResult.error}`, "error");
          } else {
            const execResponse = execResult.getValue();
            if (execResponse.success) {
              this.showNotification(
                execResponse.message || "Command executed successfully",
                "success"
              );
            }
          }
        }
      );
      modal.open();
    } else if (response.success) {
      this.showNotification(
        response.message || "Command executed successfully",
        "success"
      );
    }
  }
  /**
   * Show notification to user
   */
  showNotification(message, type) {
    new Notice(message, type === "error" ? 5e3 : 3e3);
  }
};
var CommandInputModal = class extends import_obsidian12.Modal {
  constructor(app, schema, onSubmit) {
    super(app);
    this.schema = schema;
    this.onSubmit = onSubmit;
    this.inputValues = {};
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: this.schema.title });
    if (this.schema.description) {
      contentEl.createEl("p", {
        text: this.schema.description,
        cls: "exocortex-modal-description"
      });
    }
    const formEl = contentEl.createDiv({ cls: "exocortex-command-form" });
    for (const param of this.schema.parameters) {
      this.createParameterInput(formEl, param);
    }
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    new import_obsidian12.Setting(buttonContainer).addButton((btn) => btn.setButtonText("Cancel").onClick(() => this.close())).addButton((btn) => btn.setButtonText("Execute").setCta().onClick(() => {
      const errors = this.validateInputs();
      if (errors.length > 0) {
        this.showErrors(errors);
        return;
      }
      this.onSubmit(this.inputValues);
      this.close();
    }));
  }
  createParameterInput(container, param) {
    const setting = new import_obsidian12.Setting(container).setName(param.label || param.name).setDesc(param.description || "");
    if (param.required) {
      setting.nameEl.createSpan({ text: " *", cls: "required-indicator" });
    }
    switch (param.type) {
      case "string":
        setting.addText((text) => {
          text.setPlaceholder(param.label || param.name);
          if (param.defaultValue) {
            text.setValue(param.defaultValue);
            this.inputValues[param.name] = param.defaultValue;
          }
          text.onChange((value) => {
            this.inputValues[param.name] = value;
          });
        });
        break;
      case "number":
        setting.addText((text) => {
          text.inputEl.type = "number";
          if (param.defaultValue !== void 0) {
            text.setValue(String(param.defaultValue));
            this.inputValues[param.name] = param.defaultValue;
          }
          text.onChange((value) => {
            this.inputValues[param.name] = Number(value);
          });
        });
        break;
      case "boolean":
        setting.addToggle((toggle) => {
          if (param.defaultValue !== void 0) {
            toggle.setValue(param.defaultValue);
            this.inputValues[param.name] = param.defaultValue;
          }
          toggle.onChange((value) => {
            this.inputValues[param.name] = value;
          });
        });
        break;
      case "date":
        setting.addText((text) => {
          text.inputEl.type = "date";
          if (param.defaultValue) {
            text.setValue(param.defaultValue);
            this.inputValues[param.name] = param.defaultValue;
          }
          text.onChange((value) => {
            this.inputValues[param.name] = value;
          });
        });
        break;
      case "asset":
        setting.addText((text) => {
          text.setPlaceholder("[[Asset Name]]");
          if (param.defaultValue) {
            text.setValue(param.defaultValue);
            this.inputValues[param.name] = param.defaultValue;
          }
          text.onChange((value) => {
            if (value && !value.startsWith("[[")) {
              value = `[[${value}]]`;
            }
            this.inputValues[param.name] = value;
          });
        });
        break;
      case "array":
        setting.addTextArea((textarea) => {
          textarea.setPlaceholder("One item per line");
          if (param.defaultValue) {
            const defaultText = Array.isArray(param.defaultValue) ? param.defaultValue.join("\n") : param.defaultValue;
            textarea.setValue(defaultText);
            this.inputValues[param.name] = param.defaultValue;
          }
          textarea.onChange((value) => {
            this.inputValues[param.name] = value.split("\n").filter((v) => v.trim());
          });
        });
        break;
      default:
        setting.addText((text) => {
          text.onChange((value) => {
            this.inputValues[param.name] = value;
          });
        });
    }
  }
  validateInputs() {
    const errors = [];
    for (const param of this.schema.parameters) {
      if (param.required) {
        const value = this.inputValues[param.name];
        if (value === void 0 || value === null || value === "") {
          errors.push(`${param.label || param.name} is required`);
        }
      }
      if (param.validation && this.inputValues[param.name]) {
        try {
          const regex = new RegExp(param.validation);
          if (!regex.test(String(this.inputValues[param.name]))) {
            errors.push(`${param.label || param.name} format is invalid`);
          }
        } catch (e) {
        }
      }
    }
    return errors;
  }
  showErrors(errors) {
    const errorMessage = "Please fix the following errors:\n" + errors.join("\n");
    new Notice(errorMessage, 5e3);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/presentation/components/PropertyRenderer.ts
var import_obsidian13 = require("obsidian");
var PropertyRenderer = class {
  constructor(app, propertyEditingUseCase) {
    this.app = app;
    this.propertyEditingUseCase = propertyEditingUseCase;
    this.editingProperty = null;
    this.originalValues = /* @__PURE__ */ new Map();
    this.propertyInputs = /* @__PURE__ */ new Map();
  }
  /**
   * Render properties block with inline editing capability
   */
  async renderPropertiesBlock(container, assetId, className, currentProperties) {
    const propertiesResult = await this.propertyEditingUseCase.getPropertiesForClass(className);
    if (propertiesResult.isFailure) {
      container.createEl("div", {
        text: "Failed to load properties",
        cls: "exocortex-error-message"
      });
      return;
    }
    const properties = propertiesResult.getValue();
    const propertiesEl = container.createDiv({ cls: "exocortex-properties-editable" });
    for (const prop of properties) {
      this.renderProperty(
        propertiesEl,
        assetId,
        prop,
        currentProperties[prop.propertyName]
      );
    }
    const schemaPropertyNames = new Set(properties.map((p) => p.propertyName));
    for (const [key, value] of Object.entries(currentProperties)) {
      if (!schemaPropertyNames.has(key) && !key.startsWith("exo__")) {
        this.renderCustomProperty(propertiesEl, assetId, key, value);
      }
    }
  }
  /**
   * Render individual property with edit capability
   */
  renderProperty(container, assetId, property, currentValue) {
    const propertyEl = container.createDiv({ cls: "exocortex-property-item" });
    const labelEl = propertyEl.createDiv({ cls: "exocortex-property-label" });
    labelEl.createSpan({ text: property.label || property.propertyName });
    if (property.isRequired) {
      labelEl.createSpan({ text: " *", cls: "required-indicator" });
    }
    const valueContainer = propertyEl.createDiv({ cls: "exocortex-property-value" });
    if (this.editingProperty === property.propertyName) {
      this.renderEditControl(
        valueContainer,
        assetId,
        property,
        currentValue
      );
    } else {
      this.renderReadOnlyValue(
        valueContainer,
        assetId,
        property,
        currentValue
      );
    }
    if (property.description) {
      propertyEl.createDiv({
        text: property.description,
        cls: "exocortex-property-description"
      });
    }
  }
  /**
   * Render read-only value that becomes editable on click
   */
  renderReadOnlyValue(container, assetId, property, value) {
    const valueEl = container.createDiv({
      cls: "exocortex-property-value-readonly"
    });
    const displayValue = this.formatDisplayValue(value, property.type || property.range);
    valueEl.createSpan({ text: displayValue || "(empty)" });
    const editIcon = valueEl.createSpan({
      cls: "exocortex-edit-icon",
      text: "\u270F\uFE0F"
    });
    valueEl.addEventListener("click", () => {
      this.enterEditMode(container, assetId, property, value);
    });
    valueEl.tabIndex = 0;
    valueEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        this.enterEditMode(container, assetId, property, value);
      }
    });
  }
  /**
   * Enter edit mode for a property
   */
  enterEditMode(container, assetId, property, currentValue) {
    this.originalValues.set(property.propertyName, currentValue);
    this.editingProperty = property.propertyName;
    container.empty();
    this.renderEditControl(container, assetId, property, currentValue);
  }
  /**
   * Render appropriate edit control based on property type
   */
  renderEditControl(container, assetId, property, currentValue) {
    var _a;
    const controlContainer = container.createDiv({ cls: "exocortex-edit-control" });
    if (property.isObjectProperty) {
      this.renderObjectPropertyDropdown(controlContainer, assetId, property, currentValue);
    } else if ((_a = property.range) == null ? void 0 : _a.startsWith("enum:")) {
      this.renderEnumDropdown(controlContainer, assetId, property, currentValue);
    } else if (property.range === "boolean") {
      this.renderBooleanToggle(controlContainer, assetId, property, currentValue);
    } else if (property.range === "date") {
      this.renderDateInput(controlContainer, assetId, property, currentValue);
    } else if (property.range === "number") {
      this.renderNumberInput(controlContainer, assetId, property, currentValue);
    } else if (property.range === "text" || property.range === "description") {
      this.renderTextArea(controlContainer, assetId, property, currentValue);
    } else if (property.range === "array") {
      this.renderArrayInput(controlContainer, assetId, property, currentValue);
    } else {
      this.renderTextInput(controlContainer, assetId, property, currentValue);
    }
    this.renderEditActions(controlContainer, assetId, property);
  }
  /**
   * Render dropdown for object properties
   */
  async renderObjectPropertyDropdown(container, assetId, property, currentValue) {
    var _a;
    const dropdown = new import_obsidian13.DropdownComponent(container);
    const rangeClass = (_a = property.range) == null ? void 0 : _a.replace(/\[\[|\]\]/g, "");
    if (rangeClass) {
      const assetsResult = await this.propertyEditingUseCase.getAssetsForClass(rangeClass);
      if (assetsResult.isSuccess) {
        const assets = assetsResult.getValue();
        dropdown.addOption("", "-- Select --");
        for (const asset of assets) {
          const wikiLink = `[[${asset.fileName}]]`;
          const displayName = asset.label !== asset.fileName ? `${asset.label} (${asset.fileName})` : asset.fileName;
          dropdown.addOption(wikiLink, displayName);
        }
      }
    }
    if (currentValue) {
      dropdown.setValue(currentValue);
    }
    this.propertyInputs.set(property.propertyName, dropdown);
    dropdown.selectEl.focus();
  }
  /**
   * Render enum dropdown
   */
  renderEnumDropdown(container, assetId, property, currentValue) {
    const dropdown = new import_obsidian13.DropdownComponent(container);
    const options = property.range.substring(5).split(",");
    dropdown.addOption("", "-- Select --");
    for (const option of options) {
      dropdown.addOption(option.trim(), option.trim());
    }
    if (currentValue) {
      dropdown.setValue(currentValue);
    }
    this.propertyInputs.set(property.propertyName, dropdown);
    dropdown.selectEl.focus();
  }
  /**
   * Render text input
   */
  renderTextInput(container, assetId, property, currentValue) {
    const textInput = new import_obsidian13.TextComponent(container);
    textInput.setValue(currentValue || "");
    this.propertyInputs.set(property.propertyName, textInput);
    textInput.inputEl.focus();
    textInput.inputEl.select();
    textInput.inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        this.saveProperty(assetId, property);
      } else if (e.key === "Escape") {
        e.preventDefault();
        this.cancelEdit(container, assetId, property);
      }
    });
  }
  /**
   * Render edit action buttons
   */
  renderEditActions(container, assetId, property) {
    const actionsEl = container.createDiv({ cls: "exocortex-edit-actions" });
    new import_obsidian13.ButtonComponent(actionsEl).setIcon("check").setTooltip("Save (Enter)").onClick(() => this.saveProperty(assetId, property));
    new import_obsidian13.ButtonComponent(actionsEl).setIcon("x").setTooltip("Cancel (Escape)").onClick(() => this.cancelEdit(container, assetId, property));
  }
  /**
   * Save property value
   */
  async saveProperty(assetId, property) {
    const input = this.propertyInputs.get(property.propertyName);
    if (!input)
      return;
    let value;
    if (input instanceof import_obsidian13.TextComponent) {
      value = input.getValue();
    } else if (input instanceof import_obsidian13.DropdownComponent) {
      value = input.getValue();
    } else if (input instanceof import_obsidian13.ToggleComponent) {
      value = input.getValue();
    }
    const result = await this.propertyEditingUseCase.execute({
      assetId,
      propertyName: property.propertyName,
      value,
      propertyDefinition: property
    });
    if (result.isSuccess) {
      this.editingProperty = null;
      this.propertyInputs.delete(property.propertyName);
      this.originalValues.delete(property.propertyName);
      new import_obsidian13.Notice("Property updated", 1e3);
    } else {
      new import_obsidian13.Notice(`Error: ${result.error}`, 3e3);
    }
  }
  /**
   * Cancel edit and restore original value
   */
  cancelEdit(container, assetId, property) {
    const originalValue = this.originalValues.get(property.propertyName);
    this.editingProperty = null;
    this.propertyInputs.delete(property.propertyName);
    this.originalValues.delete(property.propertyName);
    container.empty();
    this.renderReadOnlyValue(container, assetId, property, originalValue);
  }
  /**
   * Format value for display
   */
  formatDisplayValue(value, type) {
    if (value === null || value === void 0) {
      return "";
    }
    if (Array.isArray(value)) {
      return value.join(", ");
    }
    if (typeof value === "boolean") {
      return value ? "\u2713" : "\u2717";
    }
    return String(value);
  }
  /**
   * Render custom property not in schema
   */
  renderCustomProperty(container, assetId, propertyName, value) {
    const property = {
      propertyName,
      label: propertyName,
      range: "string",
      isRequired: false,
      description: "Custom property"
    };
    this.renderProperty(container, assetId, property, value);
  }
  // Additional methods for other input types...
  renderBooleanToggle(container, assetId, property, currentValue) {
    const toggle = new import_obsidian13.ToggleComponent(container);
    toggle.setValue(currentValue || false);
    this.propertyInputs.set(property.propertyName, toggle);
  }
  renderDateInput(container, assetId, property, currentValue) {
    const dateInput = new import_obsidian13.TextComponent(container);
    dateInput.inputEl.type = "date";
    dateInput.setValue(currentValue || "");
    this.propertyInputs.set(property.propertyName, dateInput);
    dateInput.inputEl.focus();
  }
  renderNumberInput(container, assetId, property, currentValue) {
    const numberInput = new import_obsidian13.TextComponent(container);
    numberInput.inputEl.type = "number";
    numberInput.setValue(String(currentValue || ""));
    this.propertyInputs.set(property.propertyName, numberInput);
    numberInput.inputEl.focus();
  }
  renderTextArea(container, assetId, property, currentValue) {
    const textArea = new import_obsidian13.TextAreaComponent(container);
    textArea.setValue(currentValue || "");
    this.propertyInputs.set(property.propertyName, textArea);
    textArea.inputEl.focus();
  }
  renderArrayInput(container, assetId, property, currentValue) {
    const arrayContainer = container.createDiv({ cls: "exocortex-array-input" });
    const values = Array.isArray(currentValue) ? currentValue : [];
    values.forEach((val, index) => {
      const itemEl = arrayContainer.createDiv({ cls: "array-item" });
      const input = new import_obsidian13.TextComponent(itemEl);
      input.setValue(val);
      new import_obsidian13.ButtonComponent(itemEl).setIcon("x").onClick(() => {
        values.splice(index, 1);
        this.renderArrayInput(container, assetId, property, values);
      });
    });
    new import_obsidian13.ButtonComponent(arrayContainer).setButtonText("Add item").onClick(() => {
      values.push("");
      this.renderArrayInput(container, assetId, property, values);
    });
    this.propertyInputs.set(property.propertyName, { values });
  }
};

// src/application/use-cases/ExecuteQueryBlockUseCase.ts
var ExecuteQueryBlockUseCase = class {
  constructor(app) {
    this.app = app;
  }
  async execute(request) {
    const startTime = Date.now();
    try {
      let files = this.app.vault.getFiles();
      if (request.blockConfig.className) {
        files = this.filterByClass(files, request.blockConfig.className);
      }
      if (request.blockConfig.propertyFilters && request.blockConfig.propertyFilters.length > 0) {
        files = this.applyPropertyFilters(
          files,
          request.blockConfig.propertyFilters,
          request.currentAssetPath,
          request.currentAssetFrontmatter
        );
      }
      if (request.blockConfig.relationProperty) {
        files = this.filterByRelation(
          files,
          request.blockConfig.relationProperty,
          request.currentAssetPath
        );
      }
      const totalCount = files.length;
      if (request.blockConfig.sortBy) {
        files = this.sortFiles(
          files,
          request.blockConfig.sortBy,
          request.blockConfig.sortOrder || "asc"
        );
      }
      if (request.blockConfig.maxResults && request.blockConfig.maxResults > 0) {
        files = files.slice(0, request.blockConfig.maxResults);
      }
      const executionTime = Date.now() - startTime;
      return Result.ok({
        results: files,
        totalCount,
        executionTime
      });
    } catch (error) {
      return Result.fail(
        `Failed to execute query block: ${error}`
      );
    }
  }
  filterByClass(files, className) {
    const cleanClassName = this.cleanClassName(className);
    return files.filter((file) => {
      const metadata = this.app.metadataCache.getFileCache(file);
      if (!(metadata == null ? void 0 : metadata.frontmatter))
        return false;
      const instanceClass = metadata.frontmatter["exo__Instance_class"];
      const fileClassName = this.cleanClassName(instanceClass);
      return fileClassName === cleanClassName;
    });
  }
  applyPropertyFilters(files, filters, currentAssetPath, currentAssetFrontmatter) {
    return files.filter((file) => {
      const metadata = this.app.metadataCache.getFileCache(file);
      if (!(metadata == null ? void 0 : metadata.frontmatter))
        return false;
      for (const filter of filters) {
        if (!this.evaluateFilter(
          metadata.frontmatter,
          filter,
          currentAssetPath,
          currentAssetFrontmatter,
          file
        )) {
          return false;
        }
      }
      return true;
    });
  }
  evaluateFilter(frontmatter, filter, currentAssetPath, currentAssetFrontmatter, file) {
    const propertyValue = frontmatter[filter.property];
    let filterValue = filter.value;
    if (typeof filterValue === "string") {
      filterValue = filterValue.replace("{{current_asset}}", `[[${currentAssetPath}]]`).replace("{{current_file}}", `[[${currentAssetPath}]]`);
      const varMatch = filterValue.match(/\{\{fm\.(.+?)\}\}/g);
      if (varMatch) {
        varMatch.forEach((match) => {
          const prop = match.replace(/\{\{fm\.|}\}/g, "");
          const value = currentAssetFrontmatter[prop];
          if (value) {
            filterValue = filterValue.replace(match, value);
          }
        });
      }
    }
    const cleanPropValue = this.cleanValue(propertyValue);
    const cleanFilterValue = this.cleanValue(filterValue);
    switch (filter.operator) {
      case "equals":
        return this.valuesEqual(cleanPropValue, cleanFilterValue);
      case "notEquals":
        return !this.valuesEqual(cleanPropValue, cleanFilterValue);
      case "contains":
        return this.valueContains(cleanPropValue, cleanFilterValue);
      case "startsWith":
        return this.valueStartsWith(cleanPropValue, cleanFilterValue);
      case "endsWith":
        return this.valueEndsWith(cleanPropValue, cleanFilterValue);
      case "exists":
        return propertyValue !== void 0 && propertyValue !== null;
      case "notExists":
        return propertyValue === void 0 || propertyValue === null;
      default:
        return false;
    }
  }
  valuesEqual(value1, value2) {
    if (Array.isArray(value1)) {
      return value1.some((v) => this.valuesEqual(v, value2));
    }
    const clean1 = this.cleanClassName(value1);
    const clean2 = this.cleanClassName(value2);
    return clean1 === clean2;
  }
  valueContains(value, searchValue) {
    if (Array.isArray(value)) {
      return value.some((v) => this.valueContains(v, searchValue));
    }
    const str = this.cleanClassName(value).toLowerCase();
    const search = this.cleanClassName(searchValue).toLowerCase();
    return str.includes(search);
  }
  valueStartsWith(value, searchValue) {
    if (Array.isArray(value)) {
      return value.some((v) => this.valueStartsWith(v, searchValue));
    }
    const str = this.cleanClassName(value).toLowerCase();
    const search = this.cleanClassName(searchValue).toLowerCase();
    return str.startsWith(search);
  }
  valueEndsWith(value, searchValue) {
    if (Array.isArray(value)) {
      return value.some((v) => this.valueEndsWith(v, searchValue));
    }
    const str = this.cleanClassName(value).toLowerCase();
    const search = this.cleanClassName(searchValue).toLowerCase();
    return str.endsWith(search);
  }
  filterByRelation(files, relationProperty, currentAssetPath) {
    const currentLink = `[[${currentAssetPath}]]`;
    return files.filter((file) => {
      const metadata = this.app.metadataCache.getFileCache(file);
      if (!(metadata == null ? void 0 : metadata.frontmatter))
        return false;
      const relationValue = metadata.frontmatter[relationProperty];
      if (!relationValue)
        return false;
      if (Array.isArray(relationValue)) {
        return relationValue.some(
          (v) => this.cleanClassName(v) === this.cleanClassName(currentLink)
        );
      }
      return this.cleanClassName(relationValue) === this.cleanClassName(currentLink);
    });
  }
  sortFiles(files, sortBy, order) {
    return files.sort((a, b) => {
      var _a, _b;
      const aMetadata = this.app.metadataCache.getFileCache(a);
      const bMetadata = this.app.metadataCache.getFileCache(b);
      const aValue = ((_a = aMetadata == null ? void 0 : aMetadata.frontmatter) == null ? void 0 : _a[sortBy]) || "";
      const bValue = ((_b = bMetadata == null ? void 0 : bMetadata.frontmatter) == null ? void 0 : _b[sortBy]) || "";
      let comparison = 0;
      if (aValue < bValue)
        comparison = -1;
      if (aValue > bValue)
        comparison = 1;
      return order === "asc" ? comparison : -comparison;
    });
  }
  cleanClassName(value) {
    if (!value)
      return "";
    const str = Array.isArray(value) ? value[0] : value;
    return (str == null ? void 0 : str.toString().replace(/\[\[|\]\]/g, "").trim()) || "";
  }
  cleanValue(value) {
    if (Array.isArray(value)) {
      return value.map((v) => this.cleanValue(v));
    }
    if (typeof value === "string") {
      return value.replace(/\[\[|\]\]/g, "").trim();
    }
    return value;
  }
};

// src/presentation/renderers/QueryBlockRenderer.ts
var QueryBlockRenderer = class {
  constructor(app) {
    this.app = app;
    this.executeQueryUseCase = new ExecuteQueryBlockUseCase(app);
  }
  async render(container, config, file, frontmatter, dv) {
    const queryConfig = config;
    const result = await this.executeQueryUseCase.execute({
      blockConfig: queryConfig,
      currentAssetPath: file.path,
      currentAssetFrontmatter: frontmatter
    });
    if (result.isFailure) {
      container.createEl("p", {
        text: `Query failed: ${result.error}`,
        cls: "exocortex-error"
      });
      return;
    }
    const { results, totalCount, executionTime } = result.getValue();
    const info = container.createDiv({ cls: "exocortex-query-info" });
    info.createEl("span", {
      text: `Found ${totalCount} items${results.length < totalCount ? `, showing ${results.length}` : ""} (${executionTime}ms)`,
      cls: "exocortex-query-count"
    });
    if (results.length === 0) {
      container.createEl("p", {
        text: "No items found",
        cls: "exocortex-empty"
      });
      return;
    }
    switch (queryConfig.displayAs) {
      case "table":
        this.renderTable(container, results, dv);
        break;
      case "cards":
        this.renderCards(container, results);
        break;
      case "list":
      default:
        this.renderList(container, results);
        break;
    }
  }
  renderList(container, files) {
    const list = container.createEl("ul", { cls: "exocortex-query-list" });
    files.forEach((file) => {
      const metadata = this.app.metadataCache.getFileCache(file);
      const frontmatter = (metadata == null ? void 0 : metadata.frontmatter) || {};
      const item = list.createEl("li");
      const link = item.createEl("a", {
        text: frontmatter["exo__Asset_label"] || file.basename,
        href: file.path,
        cls: "internal-link"
      });
      const status = frontmatter["ems__Effort_status"];
      if (status) {
        const statusSpan = item.createEl("span", {
          text: ` - ${this.cleanValue(status)}`,
          cls: "exocortex-status"
        });
      }
    });
  }
  renderTable(container, files, dv) {
    const allProps = /* @__PURE__ */ new Set();
    files.forEach((file) => {
      const metadata = this.app.metadataCache.getFileCache(file);
      if (metadata == null ? void 0 : metadata.frontmatter) {
        Object.keys(metadata.frontmatter).forEach((key) => {
          if (!key.startsWith("exo__Instance")) {
            allProps.add(key);
          }
        });
      }
    });
    const relevantProps = Array.from(allProps).filter((p) => !p.startsWith("exo__Asset_uid")).slice(0, 5);
    const table = container.createEl("table", { cls: "exocortex-query-table" });
    const thead = table.createEl("thead");
    const headerRow = thead.createEl("tr");
    headerRow.createEl("th", { text: "Name" });
    relevantProps.forEach((prop) => {
      const displayName = prop.replace(/_/g, " ").replace(/^\w+__/, "");
      headerRow.createEl("th", { text: displayName });
    });
    const tbody = table.createEl("tbody");
    files.forEach((file) => {
      const metadata = this.app.metadataCache.getFileCache(file);
      const frontmatter = (metadata == null ? void 0 : metadata.frontmatter) || {};
      const row = tbody.createEl("tr");
      const nameCell = row.createEl("td");
      nameCell.createEl("a", {
        text: frontmatter["exo__Asset_label"] || file.basename,
        href: file.path,
        cls: "internal-link"
      });
      relevantProps.forEach((prop) => {
        const cell = row.createEl("td");
        const value = frontmatter[prop];
        if (value) {
          cell.setText(this.formatValue(value));
        }
      });
    });
  }
  renderCards(container, files) {
    const cardsContainer = container.createDiv({ cls: "exocortex-query-cards" });
    files.forEach((file) => {
      const metadata = this.app.metadataCache.getFileCache(file);
      const frontmatter = (metadata == null ? void 0 : metadata.frontmatter) || {};
      const card = cardsContainer.createDiv({ cls: "exocortex-card" });
      const header = card.createDiv({ cls: "exocortex-card-header" });
      header.createEl("a", {
        text: frontmatter["exo__Asset_label"] || file.basename,
        href: file.path,
        cls: "internal-link"
      });
      const body = card.createDiv({ cls: "exocortex-card-body" });
      const status = frontmatter["ems__Effort_status"];
      if (status) {
        body.createEl("div", {
          text: `Status: ${this.cleanValue(status)}`,
          cls: "exocortex-card-status"
        });
      }
      const description = frontmatter["exo__Asset_description"];
      if (description) {
        body.createEl("div", {
          text: description,
          cls: "exocortex-card-description"
        });
      }
    });
  }
  cleanValue(value) {
    if (!value)
      return "";
    const str = Array.isArray(value) ? value[0] : value;
    return (str == null ? void 0 : str.toString().replace(/\[\[|\]\]/g, "")) || "";
  }
  formatValue(value) {
    if (Array.isArray(value)) {
      return value.map((v) => this.cleanValue(v)).join(", ");
    }
    return this.cleanValue(value);
  }
};

// src/presentation/renderers/PropertiesBlockRenderer.ts
var PropertiesBlockRenderer = class {
  constructor(app, propertyRenderer) {
    this.app = app;
    this.propertyRenderer = propertyRenderer;
  }
  async render(container, config, file, frontmatter, dv) {
    const propsConfig = config;
    let propertiesToShow = Object.keys(frontmatter);
    if (propsConfig.includedProperties && propsConfig.includedProperties.length > 0) {
      propertiesToShow = propertiesToShow.filter(
        (prop) => propsConfig.includedProperties.includes(prop)
      );
    }
    if (propsConfig.excludedProperties && propsConfig.excludedProperties.length > 0) {
      propertiesToShow = propertiesToShow.filter(
        (prop) => !propsConfig.excludedProperties.includes(prop)
      );
    }
    const assetId = frontmatter["exo__Asset_uid"] || file.path;
    const instanceClass = frontmatter["exo__Instance_class"];
    const cleanClassName = this.cleanClassName(instanceClass);
    const editableProps = propsConfig.editableProperties || [];
    if (propsConfig.groupBy) {
      this.renderGroupedProperties(
        container,
        propertiesToShow,
        frontmatter,
        propsConfig.groupBy,
        assetId,
        cleanClassName,
        editableProps
      );
    } else {
      this.renderFlatProperties(
        container,
        propertiesToShow,
        frontmatter,
        assetId,
        cleanClassName,
        editableProps
      );
    }
  }
  async renderFlatProperties(container, properties, frontmatter, assetId, className, editableProps) {
    const editableContainer = container.createDiv({ cls: "exocortex-properties-editable" });
    await this.propertyRenderer.renderPropertiesBlock(
      editableContainer,
      assetId,
      className,
      frontmatter
    );
    const readOnlyProps = properties.filter((p) => !editableProps.includes(p));
    if (readOnlyProps.length > 0) {
      const readOnlyContainer = container.createDiv({ cls: "exocortex-properties-readonly" });
      const table = readOnlyContainer.createEl("table", { cls: "exocortex-properties-table" });
      readOnlyProps.forEach((prop) => {
        const row = table.createEl("tr");
        const nameCell = row.createEl("td", { cls: "property-name" });
        nameCell.setText(this.formatPropertyName(prop));
        const valueCell = row.createEl("td", { cls: "property-value" });
        const value = frontmatter[prop];
        valueCell.setText(this.formatValue(value));
      });
    }
  }
  renderGroupedProperties(container, properties, frontmatter, groupBy, assetId, className, editableProps) {
    const groups = /* @__PURE__ */ new Map();
    properties.forEach((prop) => {
      const group = this.getPropertyGroup(prop, groupBy);
      if (!groups.has(group)) {
        groups.set(group, []);
      }
      groups.get(group).push(prop);
    });
    groups.forEach((props, groupName) => {
      const groupContainer = container.createDiv({ cls: "exocortex-property-group" });
      if (groupName !== "Other") {
        groupContainer.createEl("h4", {
          text: groupName,
          cls: "property-group-header"
        });
      }
      const groupContent = groupContainer.createDiv({ cls: "property-group-content" });
      const groupEditable = props.filter((p) => editableProps.includes(p));
      const groupReadOnly = props.filter((p) => !editableProps.includes(p));
      if (groupEditable.length > 0) {
        this.propertyRenderer.renderPropertiesBlock(
          groupContent,
          assetId,
          className,
          frontmatter
        );
      }
      if (groupReadOnly.length > 0) {
        const table = groupContent.createEl("table", { cls: "exocortex-properties-table" });
        groupReadOnly.forEach((prop) => {
          const row = table.createEl("tr");
          const nameCell = row.createEl("td", { cls: "property-name" });
          nameCell.setText(this.formatPropertyName(prop));
          const valueCell = row.createEl("td", { cls: "property-value" });
          const value = frontmatter[prop];
          valueCell.setText(this.formatValue(value));
        });
      }
    });
  }
  getPropertyGroup(property, groupBy) {
    if (groupBy === "prefix") {
      const match = property.match(/^([^_]+)__/);
      if (match) {
        return match[1].toUpperCase();
      }
    }
    if (groupBy === "category") {
      if (property.includes("status") || property.includes("Status"))
        return "Status";
      if (property.includes("date") || property.includes("Date"))
        return "Dates";
      if (property.includes("relate") || property.includes("link"))
        return "Relations";
    }
    return "Other";
  }
  formatPropertyName(prop) {
    return prop.replace(/^[^_]+__/, "").replace(/_/g, " ").replace(/\b\w/g, (l) => l.toUpperCase());
  }
  formatValue(value) {
    if (value === null || value === void 0)
      return "";
    if (Array.isArray(value)) {
      return value.map((v) => this.cleanValue(v)).join(", ");
    }
    if (typeof value === "boolean") {
      return value ? "\u2713" : "\u2717";
    }
    if (value instanceof Date) {
      return value.toLocaleDateString();
    }
    return this.cleanValue(value);
  }
  cleanValue(value) {
    if (!value)
      return "";
    const str = value.toString();
    return str.replace(/\[\[|\]\]/g, "");
  }
  cleanClassName(className) {
    if (!className)
      return "";
    const str = Array.isArray(className) ? className[0] : className;
    return (str == null ? void 0 : str.toString().replace(/\[\[|\]\]/g, "")) || "";
  }
};

// src/presentation/renderers/BacklinksBlockRenderer.ts
var import_obsidian14 = require("obsidian");
var BacklinksBlockRenderer = class {
  constructor(app) {
    this.app = app;
  }
  async render(container, config, file, dv) {
    const backlinksConfig = config;
    const backlinks = this.app.metadataCache.getBacklinksForFile(file);
    if (!backlinks || !backlinks.data || backlinks.data.size === 0) {
      container.createEl("p", {
        text: "No backlinks found",
        cls: "exocortex-empty"
      });
      return;
    }
    let backlinkFiles = [];
    for (const [path] of backlinks.data) {
      const backlinkFile = this.app.vault.getAbstractFileByPath(path);
      if (backlinkFile instanceof import_obsidian14.TFile) {
        backlinkFiles.push(backlinkFile);
      }
    }
    if (backlinksConfig.filterByClass) {
      const targetClass = this.cleanClassName(backlinksConfig.filterByClass);
      backlinkFiles = backlinkFiles.filter((f) => {
        var _a;
        const metadata = this.app.metadataCache.getFileCache(f);
        const instanceClass = (_a = metadata == null ? void 0 : metadata.frontmatter) == null ? void 0 : _a["exo__Instance_class"];
        return this.cleanClassName(instanceClass) === targetClass;
      });
    }
    const totalCount = backlinkFiles.length;
    if (backlinksConfig.maxResults && backlinksConfig.maxResults > 0) {
      backlinkFiles = backlinkFiles.slice(0, backlinksConfig.maxResults);
    }
    const info = container.createDiv({ cls: "exocortex-backlinks-info" });
    info.createEl("span", {
      text: `${totalCount} backlink${totalCount !== 1 ? "s" : ""}${backlinkFiles.length < totalCount ? `, showing ${backlinkFiles.length}` : ""}`,
      cls: "exocortex-backlinks-count"
    });
    if (backlinkFiles.length === 0) {
      container.createEl("p", {
        text: "No matching backlinks found",
        cls: "exocortex-empty"
      });
      return;
    }
    if (backlinksConfig.groupByClass) {
      this.renderGroupedBacklinks(container, backlinkFiles);
    } else {
      this.renderFlatBacklinks(container, backlinkFiles);
    }
  }
  renderFlatBacklinks(container, files) {
    const list = container.createEl("ul", { cls: "exocortex-backlinks-list" });
    files.forEach((file) => {
      const metadata = this.app.metadataCache.getFileCache(file);
      const frontmatter = (metadata == null ? void 0 : metadata.frontmatter) || {};
      const item = list.createEl("li");
      const link = item.createEl("a", {
        text: frontmatter["exo__Asset_label"] || file.basename,
        href: file.path,
        cls: "internal-link"
      });
      const instanceClass = frontmatter["exo__Instance_class"];
      if (instanceClass) {
        const classSpan = item.createEl("span", {
          text: ` (${this.cleanClassName(instanceClass)})`,
          cls: "exocortex-class-info"
        });
      }
    });
  }
  renderGroupedBacklinks(container, files) {
    const groups = /* @__PURE__ */ new Map();
    files.forEach((file) => {
      var _a;
      const metadata = this.app.metadataCache.getFileCache(file);
      const instanceClass = (_a = metadata == null ? void 0 : metadata.frontmatter) == null ? void 0 : _a["exo__Instance_class"];
      const className = this.cleanClassName(instanceClass) || "Unclassified";
      if (!groups.has(className)) {
        groups.set(className, []);
      }
      groups.get(className).push(file);
    });
    const sortedGroups = Array.from(groups.entries()).sort(([a], [b]) => a.localeCompare(b));
    sortedGroups.forEach(([className, groupFiles]) => {
      const groupContainer = container.createDiv({ cls: "exocortex-backlinks-group" });
      groupContainer.createEl("h4", {
        text: `${className} (${groupFiles.length})`,
        cls: "backlinks-group-header"
      });
      const list = groupContainer.createEl("ul", { cls: "exocortex-backlinks-list" });
      groupFiles.forEach((file) => {
        const metadata = this.app.metadataCache.getFileCache(file);
        const frontmatter = (metadata == null ? void 0 : metadata.frontmatter) || {};
        const item = list.createEl("li");
        item.createEl("a", {
          text: frontmatter["exo__Asset_label"] || file.basename,
          href: file.path,
          cls: "internal-link"
        });
      });
    });
  }
  cleanClassName(className) {
    if (!className)
      return "";
    const str = Array.isArray(className) ? className[0] : className;
    return (str == null ? void 0 : str.toString().replace(/\[\[|\]\]/g, "")) || "";
  }
};

// src/presentation/renderers/CustomBlockRenderer.ts
var import_obsidian15 = require("obsidian");
var CustomBlockRenderer = class {
  constructor(app) {
    this.app = app;
  }
  async render(container, config, file, frontmatter, dv) {
    const customConfig = config;
    try {
      if (customConfig.templatePath) {
        await this.renderTemplate(container, customConfig.templatePath, file, frontmatter, dv);
        return;
      }
      if (customConfig.dataviewQuery && dv) {
        await this.renderDataviewQuery(container, customConfig.dataviewQuery, dv);
        return;
      }
      if (customConfig.customScript) {
        await this.renderCustomScript(container, customConfig.customScript, file, frontmatter, dv);
        return;
      }
      container.createEl("p", {
        text: "Custom block has no content configured",
        cls: "exocortex-empty"
      });
    } catch (error) {
      container.createEl("p", {
        text: `Error rendering custom block: ${error}`,
        cls: "exocortex-error"
      });
      console.error("Custom block error:", error);
    }
  }
  async renderTemplate(container, templatePath, file, frontmatter, dv) {
    const templateFile = this.app.vault.getAbstractFileByPath(templatePath);
    if (!(templateFile instanceof import_obsidian15.TFile)) {
      container.createEl("p", {
        text: `Template not found: ${templatePath}`,
        cls: "exocortex-error"
      });
      return;
    }
    const templateContent = await this.app.vault.read(templateFile);
    const processedContent = this.processTemplateVariables(
      templateContent,
      file,
      frontmatter
    );
    const tempContainer = container.createDiv();
    await this.app.markdown.renderMarkdown(
      processedContent,
      tempContainer,
      file.path,
      null
    );
  }
  async renderDataviewQuery(container, query, dv) {
    if (!dv) {
      container.createEl("p", {
        text: "Dataview is not available",
        cls: "exocortex-error"
      });
      return;
    }
    try {
      const dvContainer = container.createDiv({ cls: "exocortex-dataview-container" });
      const queryLines = query.trim().split("\n");
      if (queryLines[0].startsWith("table")) {
        const tableMatch = query.match(/table\s+(.+?)\s+from/s);
        const fromMatch = query.match(/from\s+(.+?)(?:\s+where|$)/s);
        const whereMatch = query.match(/where\s+(.+?)$/s);
        if (fromMatch) {
          const source = fromMatch[1].trim();
          const fields = tableMatch ? tableMatch[1].split(",").map((f) => f.trim()) : [];
          const pages = dv.pages(source);
          if (whereMatch) {
          }
          dv.table(
            ["File", ...fields],
            pages.map((p) => [
              p.file.link,
              ...fields.map((f) => p[f] || "")
            ])
          );
        }
      } else if (queryLines[0].startsWith("list")) {
        const fromMatch = query.match(/from\s+(.+?)(?:\s+where|$)/s);
        if (fromMatch) {
          const source = fromMatch[1].trim();
          const pages = dv.pages(source);
          dv.list(pages.file.link);
        }
      } else {
        const AsyncFunction = Object.getPrototypeOf(async function() {
        }).constructor;
        const fn = new AsyncFunction("dv", "container", query);
        await fn(dv, dvContainer);
      }
    } catch (error) {
      container.createEl("p", {
        text: `Dataview query error: ${error}`,
        cls: "exocortex-error"
      });
    }
  }
  async renderCustomScript(container, script, file, frontmatter, dv) {
    try {
      const context = {
        app: this.app,
        file,
        frontmatter,
        dv,
        container,
        console: {
          log: (...args) => console.log("[Custom Block]", ...args),
          error: (...args) => console.error("[Custom Block]", ...args)
        }
      };
      const AsyncFunction = Object.getPrototypeOf(async function() {
      }).constructor;
      const fn = new AsyncFunction(
        ...Object.keys(context),
        script
      );
      await fn(...Object.values(context));
    } catch (error) {
      container.createEl("p", {
        text: `Script execution error: ${error}`,
        cls: "exocortex-error"
      });
      console.error("Custom script error:", error);
    }
  }
  processTemplateVariables(template, file, frontmatter) {
    let processed = template;
    processed = processed.replace(/\{\{file\.name\}\}/g, file.basename);
    processed = processed.replace(/\{\{file\.path\}\}/g, file.path);
    Object.keys(frontmatter).forEach((key) => {
      const value = frontmatter[key];
      const regex = new RegExp(`\\{\\{fm\\.${key}\\}\\}`, "g");
      processed = processed.replace(regex, this.formatValue(value));
    });
    const now = new Date();
    processed = processed.replace(/\{\{date\}\}/g, now.toLocaleDateString());
    processed = processed.replace(/\{\{time\}\}/g, now.toLocaleTimeString());
    processed = processed.replace(/\{\{datetime\}\}/g, now.toLocaleString());
    return processed;
  }
  formatValue(value) {
    if (value === null || value === void 0)
      return "";
    if (Array.isArray(value)) {
      return value.map((v) => this.cleanValue(v)).join(", ");
    }
    return this.cleanValue(value);
  }
  cleanValue(value) {
    if (!value)
      return "";
    const str = value.toString();
    return str.replace(/\[\[|\]\]/g, "");
  }
};

// src/application/use-cases/GetLayoutForClassUseCase.ts
var GetLayoutForClassUseCase = class {
  constructor(layoutRepository) {
    this.layoutRepository = layoutRepository;
  }
  async execute(request) {
    try {
      const classNameResult = ClassName.create(request.className);
      if (classNameResult.isFailure) {
        return Result.fail(
          `Invalid class name: ${classNameResult.error}`
        );
      }
      const className = classNameResult.getValue();
      const layouts = request.includeDisabled ? await this.layoutRepository.findByClass(className) : await this.layoutRepository.findEnabledByClass(className);
      if (layouts.length > 0) {
        return Result.ok({
          layout: layouts[0],
          // Already sorted by priority
          fallbackUsed: false
        });
      }
      const parentLayout = await this.findParentClassLayout(className);
      if (parentLayout) {
        return Result.ok({
          layout: parentLayout,
          fallbackUsed: true
        });
      }
      return Result.ok({
        layout: null,
        fallbackUsed: true
      });
    } catch (error) {
      return Result.fail(
        `Failed to get layout for class: ${error}`
      );
    }
  }
  async findParentClassLayout(className) {
    const parentClasses = this.getParentClasses(className.value);
    for (const parentClass of parentClasses) {
      const parentClassName = ClassName.create(parentClass);
      if (parentClassName.isFailure)
        continue;
      const layouts = await this.layoutRepository.findEnabledByClass(
        parentClassName.getValue()
      );
      if (layouts.length > 0) {
        return layouts[0];
      }
    }
    return null;
  }
  getParentClasses(className) {
    const hierarchy = {
      "ems__Project": ["ems__Effort", "exo__Asset"],
      "ems__Task": ["ems__Effort", "exo__Asset"],
      "ems__Area": ["exo__Asset"],
      "ems__Goal": ["exo__Asset"],
      "ems__Effort": ["exo__Asset"]
    };
    return hierarchy[className] || ["exo__Asset"];
  }
};

// src/presentation/renderers/LayoutRenderer.ts
var LayoutRenderer = class {
  constructor(app, layoutRepository, propertyRenderer) {
    this.app = app;
    this.getLayoutUseCase = new GetLayoutForClassUseCase(layoutRepository);
    this.queryRenderer = new QueryBlockRenderer(app);
    this.propertiesRenderer = new PropertiesBlockRenderer(app, propertyRenderer);
    this.backlinksRenderer = new BacklinksBlockRenderer(app);
    this.customRenderer = new CustomBlockRenderer(app);
  }
  async renderLayout(container, file, metadata, dv) {
    const frontmatter = metadata.frontmatter;
    const instanceClass = frontmatter["exo__Instance_class"];
    if (!instanceClass) {
      this.renderError(container, "No instance class defined");
      return;
    }
    const cleanClassName = this.cleanClassName(instanceClass);
    const layoutResult = await this.getLayoutUseCase.execute({
      className: cleanClassName
    });
    if (layoutResult.isFailure) {
      this.renderError(container, layoutResult.error);
      return;
    }
    const { layout, fallbackUsed } = layoutResult.getValue();
    if (!layout) {
      await this.renderDefaultLayout(container, file, metadata, dv);
      return;
    }
    await this.renderCustomLayout(container, file, metadata, layout, dv);
  }
  async renderCustomLayout(container, file, metadata, layout, dv) {
    const frontmatter = metadata.frontmatter;
    const layoutInfo = container.createDiv({ cls: "exocortex-layout-info" });
    layoutInfo.style.display = "none";
    layoutInfo.setAttribute("data-layout-id", layout.id.toString());
    layoutInfo.setAttribute("data-layout-class", layout.targetClass.value);
    const visibleBlocks = layout.getVisibleBlocks();
    for (const block of visibleBlocks) {
      const blockContainer = container.createDiv({
        cls: `exocortex-block exocortex-block-${block.type}`
      });
      blockContainer.setAttribute("data-block-id", block.id);
      if (block.title) {
        const header = blockContainer.createEl("h3", {
          text: block.title,
          cls: "exocortex-block-header"
        });
        if (block.isCollapsible) {
          header.addClass("is-collapsible");
          header.addEventListener("click", () => {
            blockContainer.toggleClass("is-collapsed", !blockContainer.hasClass("is-collapsed"));
          });
        }
      }
      const contentContainer = blockContainer.createDiv({ cls: "exocortex-block-content" });
      try {
        switch (block.type) {
          case "query":
            await this.queryRenderer.render(
              contentContainer,
              block.config,
              file,
              frontmatter,
              dv
            );
            break;
          case "properties":
            await this.propertiesRenderer.render(
              contentContainer,
              block.config,
              file,
              frontmatter,
              dv
            );
            break;
          case "backlinks":
            await this.backlinksRenderer.render(
              contentContainer,
              block.config,
              file,
              dv
            );
            break;
          case "custom":
            await this.customRenderer.render(
              contentContainer,
              block.config,
              file,
              frontmatter,
              dv
            );
            break;
          default:
            contentContainer.createEl("p", {
              text: `Unknown block type: ${block.type}`,
              cls: "exocortex-error"
            });
        }
      } catch (error) {
        contentContainer.createEl("p", {
          text: `Error rendering block: ${error}`,
          cls: "exocortex-error"
        });
        console.error(`Error rendering block ${block.id}:`, error);
      }
    }
  }
  async renderDefaultLayout(container, file, metadata, dv) {
    const frontmatter = metadata.frontmatter;
    const propsContainer = container.createDiv({ cls: "exocortex-block exocortex-block-properties" });
    propsContainer.createEl("h3", { text: "\u{1F4DD} Properties" });
    const propsContent = propsContainer.createDiv({ cls: "exocortex-block-content" });
    await this.propertiesRenderer.render(
      propsContent,
      {
        type: "properties",
        editableProperties: Object.keys(frontmatter).filter((k) => !k.startsWith("exo__"))
      },
      file,
      frontmatter,
      dv
    );
    if (frontmatter["exo__Asset_relates"]) {
      const relContainer = container.createDiv({ cls: "exocortex-block exocortex-block-relations" });
      relContainer.createEl("h3", { text: "\u{1F517} Related Assets" });
      const relContent = relContainer.createDiv({ cls: "exocortex-block-content" });
      const relates = Array.isArray(frontmatter["exo__Asset_relates"]) ? frontmatter["exo__Asset_relates"] : [frontmatter["exo__Asset_relates"]];
      const list = relContent.createEl("ul");
      relates.forEach((rel) => {
        const item = list.createEl("li");
        const link = this.cleanClassName(rel);
        item.createEl("a", {
          text: link,
          href: link,
          cls: "internal-link"
        });
      });
    }
    const backlinksContainer = container.createDiv({ cls: "exocortex-block exocortex-block-backlinks" });
    backlinksContainer.createEl("h3", { text: "\u{1F4CE} Referenced By" });
    const backlinksContent = backlinksContainer.createDiv({ cls: "exocortex-block-content" });
    await this.backlinksRenderer.render(
      backlinksContent,
      { type: "backlinks" },
      file,
      dv
    );
  }
  renderError(container, error) {
    container.createEl("div", {
      text: `Layout Error: ${error}`,
      cls: "exocortex-error notice-error"
    });
  }
  cleanClassName(className) {
    if (!className)
      return "";
    const str = Array.isArray(className) ? className[0] : className;
    return (str == null ? void 0 : str.toString().replace(/\[\[|\]\]/g, "")) || "";
  }
};

// src/infrastructure/container/DIContainer.ts
var DIContainer = class {
  constructor(app) {
    this.app = app;
    this.container = Container.getInstance();
    this.registerDependencies();
  }
  static initialize(app, plugin) {
    if (!DIContainer.instance) {
      DIContainer.instance = new DIContainer(app);
    } else {
      DIContainer.instance.app = app;
      if (plugin) {
        DIContainer.instance.plugin = plugin;
      }
      DIContainer.instance.container.clear();
      DIContainer.instance.registerDependencies();
    }
    if (plugin && !DIContainer.instance.plugin) {
      DIContainer.instance.plugin = plugin;
    }
    return DIContainer.instance;
  }
  static getInstance() {
    if (!DIContainer.instance) {
      throw new Error("DIContainer not initialized. Call initialize(app) first.");
    }
    return DIContainer.instance;
  }
  /**
   * Async initialize method for backward compatibility
   */
  async initialize(app) {
    return Promise.resolve();
  }
  /**
   * Reset the container instance (for testing purposes)
   */
  static reset() {
    DIContainer.instance = null;
  }
  registerDependencies() {
    this.container.register("App", () => this.app);
    this.container.register(
      "IAssetRepository",
      () => new ObsidianAssetRepository(this.app)
    );
    this.container.register(
      "IOntologyRepository",
      () => new ObsidianOntologyRepository(this.app)
    );
    this.container.register(
      "IClassViewRepository",
      () => new ObsidianClassViewRepository(this.app)
    );
    this.container.register(
      "IButtonRepository",
      () => new ObsidianButtonRepository(this.app)
    );
    this.container.register(
      "IClassLayoutRepository",
      () => {
        var _a, _b;
        return new ObsidianClassLayoutRepository(
          this.app,
          ((_b = (_a = this.plugin) == null ? void 0 : _a.settings) == null ? void 0 : _b.layoutsFolderPath) || "layouts"
        );
      }
    );
    this.container.register(
      "IQueryTemplateRepository",
      () => {
        var _a, _b, _c, _d;
        return new ObsidianQueryTemplateRepository(
          this.app,
          ((_b = (_a = this.plugin) == null ? void 0 : _a.settings) == null ? void 0 : _b.templatesPath) || ".exocortex/templates",
          ((_d = (_c = this.plugin) == null ? void 0 : _c.settings) == null ? void 0 : _d.templateUsageDataPath) || ".exocortex/template-usage.json"
        );
      }
    );
    this.container.register(
      "ICommandExecutor",
      () => new ObsidianCommandExecutor(
        this.app,
        this.container.resolve("IAssetRepository")
      )
    );
    this.container.register(
      "ErrorHandlerService",
      () => new ErrorHandlerService({
        showUserNotification: true,
        logToConsole: true,
        trackMetrics: true,
        autoRecover: false
      })
    );
    this.container.register(
      "ISuggestionRepository",
      () => {
        var _a;
        const graph = ((_a = this.plugin) == null ? void 0 : _a.graph) || null;
        return new GraphSuggestionRepository(graph);
      }
    );
    this.container.register(
      "SPARQLAutocompleteService",
      () => {
        var _a;
        return new SPARQLAutocompleteService(
          this.container.resolve("ISuggestionRepository"),
          ((_a = this.plugin) == null ? void 0 : _a.graph) || null
        );
      }
    );
    this.container.register(
      "CreateAssetUseCase",
      () => new CreateAssetUseCase(
        this.container.resolve("IAssetRepository"),
        this.container.resolve("IOntologyRepository")
      )
    );
    this.container.register(
      "RenderClassButtonsUseCase",
      () => new RenderClassButtonsUseCase(
        this.container.resolve("IClassViewRepository"),
        this.container.resolve("IButtonRepository")
      )
    );
    this.container.register(
      "ExecuteButtonCommandUseCase",
      () => new ExecuteButtonCommandUseCase(
        this.container.resolve("IButtonRepository"),
        this.container.resolve("ICommandExecutor")
      )
    );
    this.container.register(
      "PropertyEditingUseCase",
      () => new PropertyEditingUseCase(
        this.container.resolve("IAssetRepository"),
        this.plugin || this.app
        // Use plugin if available, otherwise app
      )
    );
    this.container.register(
      "QueryTemplateUseCase",
      () => new QueryTemplateUseCase(
        this.container.resolve("IQueryTemplateRepository")
      )
    );
    this.container.register(
      "ButtonRenderer",
      () => new ButtonRenderer(
        this.app,
        this.container.resolve("RenderClassButtonsUseCase"),
        this.container.resolve("ExecuteButtonCommandUseCase")
      )
    );
    this.container.register(
      "PropertyRenderer",
      () => new PropertyRenderer(
        this.app,
        this.container.resolve("PropertyEditingUseCase")
      )
    );
    this.container.register(
      "LayoutRenderer",
      () => new LayoutRenderer(
        this.app,
        this.container.resolve("IClassLayoutRepository"),
        this.container.resolve("PropertyRenderer")
      )
    );
  }
  /**
   * Resolve a dependency from the container
   */
  resolve(token) {
    return this.container.resolve(token);
  }
  /**
   * Get specific use cases for common operations
   */
  getCreateAssetUseCase() {
    return this.resolve("CreateAssetUseCase");
  }
  getRenderButtonsUseCase() {
    return this.resolve("RenderClassButtonsUseCase");
  }
  getExecuteButtonCommandUseCase() {
    return this.resolve("ExecuteButtonCommandUseCase");
  }
  getButtonRenderer() {
    return this.resolve("ButtonRenderer");
  }
  getPropertyRenderer() {
    return this.resolve("PropertyRenderer");
  }
  getLayoutRenderer() {
    return this.resolve("LayoutRenderer");
  }
  getPropertyEditingUseCase() {
    return this.resolve("PropertyEditingUseCase");
  }
  getQueryTemplateUseCase() {
    return this.resolve("QueryTemplateUseCase");
  }
  getQueryTemplateRepository() {
    return this.resolve("IQueryTemplateRepository");
  }
  /**
   * Clean up resources
   */
  dispose() {
    this.container.clear();
  }
};

// src/presentation/modals/CreateAssetModal.ts
var CreateAssetModal = class extends import_obsidian16.Modal {
  constructor(app) {
    super(app);
    this.assetTitle = "";
    this.assetClass = "exo__Asset";
    this.assetOntology = "";
    this.propertyValues = /* @__PURE__ */ new Map();
    this.propertiesContainer = null;
    this.properties = [];
    this.container = DIContainer.getInstance();
    this.createAssetUseCase = this.container.getCreateAssetUseCase();
    this.ontologyRepository = this.container.resolve("IOntologyRepository");
    this.classViewRepository = this.container.resolve("IClassViewRepository");
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Create ExoAsset" });
    await this.setupTitleField(contentEl);
    await this.setupClassField(contentEl);
    await this.setupOntologyField(contentEl);
    await this.setupPropertiesSection(contentEl);
    this.setupActionButtons(contentEl);
  }
  async setupTitleField(containerEl) {
    new import_obsidian16.Setting(containerEl).setName("Title").setDesc("Asset title").addText((text) => text.setPlaceholder("Enter asset title").setValue(this.assetTitle).onChange((value) => this.assetTitle = value));
  }
  async setupClassField(containerEl) {
    const files = this.app.vault.getMarkdownFiles();
    const classes = [];
    for (const file of files) {
      const cache = this.app.metadataCache.getFileCache(file);
      if (cache == null ? void 0 : cache.frontmatter) {
        const instanceClass = cache.frontmatter["exo__Instance_class"];
        if (instanceClass === "[[exo__Class]]" || instanceClass === "exo__Class") {
          const className = file.basename;
          const displayName = cache.frontmatter["rdfs__label"] || className;
          classes.push({ className, displayName });
        }
      }
    }
    if (classes.length === 0) {
      classes.push(
        { className: "exo__Asset", displayName: "Asset" },
        { className: "exo__Class", displayName: "Class" },
        { className: "exo__Property", displayName: "Property" }
      );
    }
    new import_obsidian16.Setting(containerEl).setName("Class").setDesc("Select the type of asset").addDropdown((dropdown) => {
      for (const classInfo of classes) {
        dropdown.addOption(classInfo.className, classInfo.displayName);
      }
      dropdown.setValue(this.assetClass);
      dropdown.onChange(async (value) => {
        this.assetClass = value;
        await this.updatePropertiesForClass(value);
      });
    });
  }
  async setupOntologyField(containerEl) {
    const files = this.app.vault.getMarkdownFiles();
    const ontologies = [];
    for (const file of files) {
      if (file.name.startsWith("!")) {
        const cache = this.app.metadataCache.getFileCache(file);
        if (cache == null ? void 0 : cache.frontmatter) {
          const prefix = cache.frontmatter["exo__Ontology_prefix"] || file.basename.substring(1);
          const displayName = cache.frontmatter["rdfs__label"] || prefix;
          ontologies.push({ prefix, displayName });
        }
      }
    }
    if (ontologies.length === 0) {
      ontologies.push(
        { prefix: "exo", displayName: "Exocortex Core" },
        { prefix: "ui", displayName: "User Interface" },
        { prefix: "rdfs", displayName: "RDF Schema" }
      );
    }
    const defaultOntology = "exo";
    new import_obsidian16.Setting(containerEl).setName("Ontology").setDesc("Select which knowledge graph this asset belongs to").addDropdown((dropdown) => {
      for (const ontology of ontologies) {
        dropdown.addOption(ontology.prefix, ontology.displayName);
      }
      if (defaultOntology && ontologies.some((o) => o.prefix === defaultOntology)) {
        this.assetOntology = defaultOntology;
        dropdown.setValue(defaultOntology);
      } else if (ontologies.length > 0) {
        this.assetOntology = ontologies[0].prefix;
        dropdown.setValue(ontologies[0].prefix);
      }
      dropdown.onChange((value) => {
        this.assetOntology = value;
      });
    });
  }
  async setupPropertiesSection(containerEl) {
    containerEl.createEl("h3", {
      text: "Properties",
      cls: "exocortex-properties-header"
    });
    this.propertiesContainer = containerEl.createDiv({
      cls: "exocortex-properties-container"
    });
    await this.updatePropertiesForClass(this.assetClass);
  }
  async updatePropertiesForClass(className) {
    if (!this.propertiesContainer)
      return;
    console.log(`Updating properties for class: ${className}`);
    if ("empty" in this.propertiesContainer && typeof this.propertiesContainer.empty === "function") {
      this.propertiesContainer.empty();
    } else {
      while (this.propertiesContainer.firstChild) {
        this.propertiesContainer.removeChild(this.propertiesContainer.firstChild);
      }
    }
    this.propertyValues.clear();
    this.properties = [];
    const files = this.app.vault.getMarkdownFiles();
    console.log(`Scanning ${files.length} files for properties...`);
    for (const file of files) {
      const cache = this.app.metadataCache.getFileCache(file);
      if (cache == null ? void 0 : cache.frontmatter) {
        const instanceClass = cache.frontmatter["exo__Instance_class"];
        if (instanceClass === "[[exo__Property]]" || instanceClass === "exo__Property") {
          const domain = cache.frontmatter["rdfs__domain"];
          if (domain === `[[${className}]]` || domain === className || Array.isArray(domain) && (domain.includes(className) || domain.includes(`[[${className}]]`))) {
            const propertyName = file.basename;
            const label = cache.frontmatter["rdfs__label"] || propertyName;
            const description = cache.frontmatter["rdfs__comment"] || "";
            const range = cache.frontmatter["rdfs__range"] || "string";
            const isRequired = cache.frontmatter["exo__Property_isRequired"] || false;
            const options = cache.frontmatter["exo__Property_options"] || null;
            console.log(`Found property ${propertyName} for class ${className}`);
            let type = this.mapRangeToType(range);
            if (options && Array.isArray(options)) {
              type = "enum";
            } else if (range === "select" && options) {
              type = "enum";
            }
            this.properties.push({
              name: propertyName,
              label,
              description,
              type,
              isRequired,
              range,
              options
            });
          }
        }
      }
    }
    console.log(`Found ${this.properties.length} properties for class ${className}`);
    if (this.properties.length === 0 && className === "exo__Asset") {
      this.properties.push(
        {
          name: "description",
          label: "Description",
          description: "A brief description of the asset",
          type: "text",
          isRequired: false
        },
        {
          name: "tags",
          label: "Tags",
          description: "Tags for categorization",
          type: "array",
          isRequired: false
        }
      );
    }
    if (this.properties.length === 0) {
      this.propertiesContainer.createEl("p", {
        text: "No specific properties for this class",
        cls: "exocortex-no-properties"
      });
      return;
    }
    for (const prop of this.properties) {
      this.createPropertyField(prop);
    }
  }
  mapRangeToType(range) {
    if (range === "select")
      return "enum";
    if (range.includes("boolean"))
      return "boolean";
    if (range.includes("date") || range.includes("Date"))
      return "date";
    if (range.includes("integer") || range.includes("decimal") || range.includes("float"))
      return "number";
    if (range.includes("string") && range.includes("[]"))
      return "array";
    if (range.includes("text") || range.includes("Text"))
      return "text";
    return "string";
  }
  createPropertyField(property) {
    if (!this.propertiesContainer)
      return;
    const setting = new import_obsidian16.Setting(this.propertiesContainer).setName(property.label + (property.isRequired ? " *" : "")).setDesc(property.description);
    switch (property.type) {
      case "enum":
        this.createEnumField(setting, property);
        break;
      case "boolean":
        this.createBooleanField(setting, property);
        break;
      case "date":
        this.createDateField(setting, property);
        break;
      case "number":
        this.createNumberField(setting, property);
        break;
      case "text":
        this.createTextAreaField(setting, property);
        break;
      case "array":
        this.createArrayField(setting, property);
        break;
      default:
        this.createTextField(setting, property);
    }
  }
  createEnumField(setting, property) {
    setting.addDropdown((dropdown) => {
      dropdown.addOption("", "-- Select --");
      for (const option of property.options) {
        dropdown.addOption(option, option);
      }
      dropdown.onChange((value) => {
        if (value) {
          this.propertyValues.set(property.name, value);
        } else {
          this.propertyValues.delete(property.name);
        }
      });
    });
  }
  createBooleanField(setting, property) {
    setting.addToggle((toggle) => {
      toggle.onChange((value) => {
        this.propertyValues.set(property.name, value);
      });
    });
  }
  createDateField(setting, property) {
    setting.addText((text) => {
      text.setPlaceholder("YYYY-MM-DD").onChange((value) => {
        if (value) {
          this.propertyValues.set(property.name, value);
        } else {
          this.propertyValues.delete(property.name);
        }
      });
      text.inputEl.type = "date";
    });
  }
  createNumberField(setting, property) {
    setting.addText((text) => {
      text.setPlaceholder("Enter number").onChange((value) => {
        if (value) {
          const num = parseFloat(value);
          if (!isNaN(num)) {
            this.propertyValues.set(property.name, num);
          }
        } else {
          this.propertyValues.delete(property.name);
        }
      });
    });
  }
  createTextAreaField(setting, property) {
    setting.addTextArea((text) => {
      text.setPlaceholder("Enter " + property.label.toLowerCase()).onChange((value) => {
        if (value) {
          this.propertyValues.set(property.name, value);
        } else {
          this.propertyValues.delete(property.name);
        }
      });
    });
  }
  createArrayField(setting, property) {
    setting.addText((text) => {
      text.setPlaceholder("Comma-separated values or [[links]]").onChange((value) => {
        if (value) {
          if (value.includes("[[")) {
            const links = value.match(/\[\[([^\]]+)\]\]/g) || [];
            this.propertyValues.set(property.name, links);
          } else {
            const items = value.split(",").map((s) => s.trim()).filter((s) => s);
            this.propertyValues.set(property.name, items);
          }
        } else {
          this.propertyValues.delete(property.name);
        }
      });
    });
  }
  createTextField(setting, property) {
    setting.addText((text) => {
      text.setPlaceholder("Enter " + property.label.toLowerCase()).onChange((value) => {
        if (value) {
          this.propertyValues.set(property.name, value);
        } else {
          this.propertyValues.delete(property.name);
        }
      });
    });
  }
  setupActionButtons(containerEl) {
    new import_obsidian16.Setting(containerEl).addButton((btn) => btn.setButtonText("Create").setCta().onClick(async () => {
      await this.createAsset();
    }));
  }
  async createAsset() {
    try {
      const properties = {};
      for (const [key, value] of this.propertyValues) {
        properties[key] = value;
      }
      const response = await this.createAssetUseCase.execute({
        title: this.assetTitle,
        className: this.assetClass,
        ontologyPrefix: this.assetOntology,
        properties
      });
      if (response.success) {
        new import_obsidian16.Notice(response.message);
        this.close();
      } else {
        new import_obsidian16.Notice(`Failed to create asset`);
      }
    } catch (error) {
      new import_obsidian16.Notice(`Error: ${error.message}`);
    }
  }
  onClose() {
    const { contentEl } = this;
    if ("empty" in contentEl && typeof contentEl.empty === "function") {
      contentEl.empty();
    } else {
      while (contentEl.firstChild) {
        contentEl.removeChild(contentEl.firstChild);
      }
    }
  }
};

// src/presentation/modals/ImportRDFModal.ts
var import_obsidian17 = require("obsidian");
var ImportRDFModal = class extends import_obsidian17.Modal {
  constructor(app, graph, namespaceManager, onImport) {
    super(app);
    this.options = {
      mergeMode: "merge",
      validateInput: true,
      strictMode: false
    };
    this.selectedFile = null;
    this.fileContent = "";
    this.graph = graph;
    this.namespaceManager = namespaceManager || new NamespaceManager();
    this.parser = new RDFParser(this.namespaceManager);
    this.onImport = onImport;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Import RDF Data" });
    const currentStatsEl = contentEl.createDiv("current-stats");
    currentStatsEl.innerHTML = `
            <h3>Current Graph</h3>
            <div class="stats-grid">
                <div class="stat-item">
                    <span class="stat-label">Triples:</span>
                    <span class="stat-value">${this.graph.size()}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Subjects:</span>
                    <span class="stat-value">${this.graph.subjects().size}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Predicates:</span>
                    <span class="stat-value">${this.graph.predicates().size}</span>
                </div>
            </div>
        `;
    const fileSection = contentEl.createDiv("file-selection");
    fileSection.createEl("h3", { text: "Select File" });
    const fileInputContainer = fileSection.createDiv("file-input-container");
    new import_obsidian17.Setting(fileInputContainer).setName("Import from vault").setDesc("Select an RDF file from your vault").addButton((button) => {
      button.setButtonText("Select File").onClick(() => this.openVaultFilePicker());
    });
    const uploadContainer = fileInputContainer.createDiv("upload-container");
    uploadContainer.createEl("span", { text: "Or upload file: " });
    const fileInput = uploadContainer.createEl("input", { type: "file" });
    fileInput.accept = ".ttl,.nt,.jsonld,.rdf,.n3,.xml";
    fileInput.addEventListener("change", (e) => this.handleFileUpload(e));
    const selectedFileEl = fileSection.createDiv("selected-file");
    selectedFileEl.style.display = "none";
    new import_obsidian17.Setting(contentEl).setName("RDF format").setDesc("Specify format (auto-detected if not set)").addDropdown((dropdown) => {
      dropdown.addOption("", "Auto-detect").addOption("turtle", "Turtle (.ttl)").addOption("ntriples", "N-Triples (.nt)").addOption("jsonld", "JSON-LD (.jsonld)").addOption("rdfxml", "RDF/XML (.rdf)").setValue(this.options.format || "").onChange((value) => {
        this.options.format = value ? value : void 0;
        this.updatePreview();
      });
    });
    new import_obsidian17.Setting(contentEl).setName("Import mode").setDesc("How to handle existing data").addDropdown((dropdown) => {
      dropdown.addOption("merge", "Merge with existing graph").addOption("replace", "Replace entire graph").setValue(this.options.mergeMode).onChange((value) => {
        this.options.mergeMode = value;
      });
    });
    new import_obsidian17.Setting(contentEl).setName("Base IRI").setDesc("Optional base IRI for relative URIs").addText((text) => {
      text.setPlaceholder("https://example.org/data/").setValue(this.options.baseIRI || "").onChange((value) => {
        this.options.baseIRI = value || void 0;
        this.updatePreview();
      });
    });
    new import_obsidian17.Setting(contentEl).setName("Validate input").setDesc("Validate RDF data during import").addToggle((toggle) => {
      toggle.setValue(this.options.validateInput).onChange((value) => {
        this.options.validateInput = value;
      });
    });
    new import_obsidian17.Setting(contentEl).setName("Strict mode").setDesc("Fail import on any parsing errors").addToggle((toggle) => {
      toggle.setValue(this.options.strictMode).onChange((value) => {
        this.options.strictMode = value;
      });
    });
    const previewContainer = contentEl.createDiv("import-preview");
    previewContainer.createEl("h3", { text: "Preview" });
    const previewEl = previewContainer.createEl("div", { cls: "preview-content" });
    previewEl.innerHTML = "<em>Select a file to see preview</em>";
    const buttonContainer = contentEl.createDiv("import-buttons");
    buttonContainer.addClass("modal-button-container");
    const importButton = buttonContainer.createEl("button", {
      text: "Import",
      cls: "mod-cta"
    });
    importButton.disabled = true;
    importButton.onclick = () => this.handleImport();
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.onclick = () => this.close();
    this.updateUI();
    this.addStyles();
  }
  /**
   * Open vault file picker
   */
  openVaultFilePicker() {
    const files = this.app.vault.getFiles().filter(
      (file) => /\.(ttl|nt|jsonld|rdf|n3|xml)$/i.test(file.extension)
    );
    if (files.length === 0) {
      new import_obsidian17.Notice("No RDF files found in vault");
      return;
    }
    const picker = document.createElement("select");
    picker.innerHTML = '<option value="">Select file...</option>';
    for (const file of files) {
      const option = document.createElement("option");
      option.value = file.path;
      option.textContent = file.path;
      picker.appendChild(option);
    }
    picker.addEventListener("change", async (e) => {
      const selectedPath = e.target.value;
      if (selectedPath) {
        const file = this.app.vault.getAbstractFileByPath(selectedPath);
        if (file instanceof import_obsidian17.TFile) {
          await this.selectVaultFile(file);
        }
      }
    });
    const container = this.contentEl.querySelector(".file-input-container");
    if (container) {
      container.appendChild(picker);
    }
  }
  /**
   * Handle file upload from computer
   */
  async handleFileUpload(event) {
    var _a;
    const input = event.target;
    const file = (_a = input.files) == null ? void 0 : _a[0];
    if (file) {
      try {
        const content = await this.readFile(file);
        this.selectedFile = file;
        this.fileContent = content;
        this.updateUI();
        this.updatePreview();
      } catch (error) {
        new import_obsidian17.Notice(`Error reading file: ${error.message}`);
      }
    }
  }
  /**
   * Select file from vault
   */
  async selectVaultFile(file) {
    try {
      const content = await this.app.vault.read(file);
      this.selectedFile = file;
      this.fileContent = content;
      this.updateUI();
      this.updatePreview();
    } catch (error) {
      new import_obsidian17.Notice(`Error reading vault file: ${error.message}`);
    }
  }
  /**
   * Read file content
   */
  readFile(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        var _a;
        return resolve((_a = e.target) == null ? void 0 : _a.result);
      };
      reader.onerror = (e) => reject(new Error("Failed to read file"));
      reader.readAsText(file);
    });
  }
  /**
   * Update UI state
   */
  updateUI() {
    const selectedFileEl = this.contentEl.querySelector(".selected-file");
    if (selectedFileEl) {
      if (this.selectedFile) {
        const fileName = this.selectedFile instanceof import_obsidian17.TFile ? this.selectedFile.name : this.selectedFile.name;
        selectedFileEl.innerHTML = `
                    <div class="selected-file-info">
                        <strong>Selected:</strong> ${fileName}
                        <span class="file-size">(${this.formatFileSize(this.fileContent.length)})</span>
                    </div>
                `;
        selectedFileEl.style.display = "block";
      } else {
        selectedFileEl.style.display = "none";
      }
    }
    const importButton = this.contentEl.querySelector("button.mod-cta");
    if (importButton) {
      importButton.disabled = !this.selectedFile;
    }
  }
  /**
   * Update preview content
   */
  updatePreview() {
    var _a;
    const previewEl = this.contentEl.querySelector(".preview-content");
    if (!previewEl || !this.fileContent)
      return;
    try {
      const parseOptions = {
        format: this.options.format,
        baseIRI: this.options.baseIRI,
        namespaceManager: this.namespaceManager,
        validateInput: false,
        // Don't validate for preview
        strictMode: false
      };
      const result = this.parser.parse(this.fileContent, parseOptions);
      if (result.isSuccess) {
        const parseResult = result.getValue();
        previewEl.innerHTML = `
                    <div class="preview-stats">
                        <h4>Import Preview</h4>
                        <div class="stats-grid">
                            <div class="stat-item">
                                <span class="stat-label">Triples:</span>
                                <span class="stat-value">${parseResult.tripleCount}</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Subjects:</span>
                                <span class="stat-value">${parseResult.graph.subjects().size}</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Predicates:</span>
                                <span class="stat-value">${parseResult.graph.predicates().size}</span>
                            </div>
                        </div>
                        ${Object.keys(parseResult.namespaces).length > 0 ? `
                            <div class="namespaces">
                                <strong>Namespaces found:</strong>
                                <ul>
                                    ${Object.entries(parseResult.namespaces).slice(0, 5).map(([prefix, uri]) => `<li>${prefix}: ${uri}</li>`).join("")}
                                    ${Object.keys(parseResult.namespaces).length > 5 ? "<li>... and more</li>" : ""}
                                </ul>
                            </div>
                        ` : ""}
                        ${((_a = parseResult.warnings) == null ? void 0 : _a.length) ? `
                            <div class="warnings">
                                <strong>Warnings:</strong>
                                <ul>
                                    ${parseResult.warnings.slice(0, 3).map((w) => `<li>${w}</li>`).join("")}
                                    ${parseResult.warnings.length > 3 ? "<li>... and more</li>" : ""}
                                </ul>
                            </div>
                        ` : ""}
                    </div>
                    <div class="sample-triples">
                        <h4>Sample Triples</h4>
                        <pre class="triple-sample">${this.formatSampleTriples(parseResult.graph)}</pre>
                    </div>
                `;
      } else {
        previewEl.innerHTML = `
                    <div class="preview-error">
                        <strong>Parse Error:</strong> ${result.errorValue()}
                    </div>
                `;
      }
    } catch (error) {
      previewEl.innerHTML = `
                <div class="preview-error">
                    <strong>Preview Error:</strong> ${error.message}
                </div>
            `;
    }
  }
  /**
   * Format sample triples for display
   */
  formatSampleTriples(graph) {
    const triples = graph.toArray().slice(0, 5);
    return triples.map((triple) => triple.toString()).join("\n") + (graph.size() > 5 ? "\n... and more" : "");
  }
  /**
   * Format file size
   */
  formatFileSize(bytes) {
    if (bytes < 1024)
      return bytes + " B";
    if (bytes < 1024 * 1024)
      return Math.round(bytes / 1024) + " KB";
    return Math.round(bytes / (1024 * 1024)) + " MB";
  }
  /**
   * Handle import action
   */
  async handleImport() {
    var _a, _b;
    if (!this.selectedFile || !this.fileContent) {
      new import_obsidian17.Notice("No file selected");
      return;
    }
    try {
      const parseOptions = {
        format: this.options.format,
        baseIRI: this.options.baseIRI,
        namespaceManager: this.namespaceManager,
        validateInput: this.options.validateInput,
        strictMode: this.options.strictMode
      };
      const result = this.parser.parse(this.fileContent, parseOptions);
      if (result.isFailure) {
        new import_obsidian17.Notice(`Import failed: ${result.errorValue()}`);
        return;
      }
      const parseResult = result.getValue();
      let finalGraph;
      if (this.options.mergeMode === "replace") {
        finalGraph = parseResult.graph;
      } else {
        finalGraph = this.graph.clone();
        finalGraph.merge(parseResult.graph);
      }
      if (this.onImport) {
        this.onImport(parseResult.graph, this.options);
      }
      const message = this.options.mergeMode === "replace" ? `Replaced graph with ${parseResult.tripleCount} triples` : `Added ${parseResult.tripleCount} triples to graph`;
      new import_obsidian17.Notice(message);
      if ((_a = parseResult.warnings) == null ? void 0 : _a.length) {
        new import_obsidian17.Notice(`Warnings: ${parseResult.warnings.length} warnings found`, 3e3);
      }
      if ((_b = parseResult.errors) == null ? void 0 : _b.length) {
        new import_obsidian17.Notice(`Errors: ${parseResult.errors.length} errors found`, 3e3);
      }
      this.close();
    } catch (error) {
      new import_obsidian17.Notice(`Import error: ${error.message}`);
    }
  }
  /**
   * Add custom styles
   */
  addStyles() {
    const style = document.createElement("style");
    style.textContent = `
            .current-stats, .preview-stats {
                margin-bottom: 20px;
                padding: 15px;
                background: var(--background-secondary);
                border-radius: 6px;
            }
            
            .stats-grid {
                display: flex;
                gap: 20px;
                margin-top: 10px;
            }
            
            .stat-item {
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            
            .stat-label {
                font-size: 12px;
                color: var(--text-muted);
                margin-bottom: 2px;
            }
            
            .stat-value {
                font-size: 16px;
                font-weight: 600;
                color: var(--text-normal);
            }
            
            .file-selection {
                margin: 20px 0;
                padding: 15px;
                border: 1px solid var(--background-modifier-border);
                border-radius: 6px;
            }
            
            .file-input-container {
                margin: 10px 0;
            }
            
            .upload-container {
                margin: 10px 0;
                display: flex;
                align-items: center;
                gap: 10px;
            }
            
            .selected-file {
                margin: 10px 0;
                padding: 10px;
                background: var(--background-primary-alt);
                border-radius: 4px;
            }
            
            .selected-file-info {
                display: flex;
                align-items: center;
                gap: 10px;
            }
            
            .file-size {
                color: var(--text-muted);
                font-size: 12px;
            }
            
            .preview-content {
                max-height: 300px;
                overflow-y: auto;
                padding: 15px;
                background: var(--background-secondary);
                border-radius: 6px;
            }
            
            .preview-error {
                color: var(--text-error);
                padding: 10px;
                background: var(--background-modifier-error);
                border-radius: 4px;
            }
            
            .namespaces, .warnings {
                margin: 10px 0;
            }
            
            .namespaces ul, .warnings ul {
                margin: 5px 0 0 20px;
                font-size: 12px;
            }
            
            .warnings {
                color: var(--text-warning);
            }
            
            .sample-triples {
                margin-top: 15px;
            }
            
            .triple-sample {
                font-family: var(--font-monospace);
                font-size: 11px;
                background: var(--background-primary);
                padding: 10px;
                border-radius: 4px;
                overflow-x: auto;
                margin: 5px 0 0 0;
            }
            
            .import-buttons {
                display: flex;
                gap: 10px;
                justify-content: flex-end;
                margin-top: 20px;
                padding-top: 20px;
                border-top: 1px solid var(--background-modifier-border);
            }
            
            .modal-button-container button {
                padding: 8px 16px;
                border-radius: 4px;
                border: 1px solid var(--background-modifier-border);
                background: var(--background-primary);
                color: var(--text-normal);
                cursor: pointer;
            }
            
            .modal-button-container button:hover:not(:disabled) {
                background: var(--background-secondary);
            }
            
            .modal-button-container button:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }
            
            .modal-button-container button.mod-cta:not(:disabled) {
                background: var(--interactive-accent);
                color: var(--text-on-accent);
                border-color: var(--interactive-accent);
            }
            
            .modal-button-container button.mod-cta:hover:not(:disabled) {
                background: var(--interactive-accent-hover);
                border-color: var(--interactive-accent-hover);
            }
        `;
    document.head.appendChild(style);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/presentation/modals/QuickTaskModal.ts
var import_obsidian18 = require("obsidian");
var QuickTaskModal = class extends import_obsidian18.Modal {
  constructor(app, createTaskUseCase, getCurrentProjectUseCase, activeFile) {
    super(app);
    this.createTaskUseCase = createTaskUseCase;
    this.getCurrentProjectUseCase = getCurrentProjectUseCase;
    this.activeFile = activeFile;
    this.taskTitle = "";
    this.taskDescription = "";
    this.taskPriority = "medium";
    this.taskStatus = "todo";
    this.taskDueDate = "";
    this.taskTags = [];
    this.availableProjects = [];
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Create New Task" });
    await this.loadProjectContext();
    if (this.currentProject) {
      const projectDiv = contentEl.createDiv({ cls: "quick-task-project" });
      projectDiv.createEl("div", {
        text: `Project: ${this.currentProject.title}`,
        cls: "quick-task-project-current"
      });
      this.selectedProjectId = this.currentProject.id;
    }
    if (this.availableProjects.length > 1) {
      new import_obsidian18.Setting(contentEl).setName("Project").setDesc("Select the project for this task").addDropdown((dropdown) => {
        dropdown.addOption("", "No project");
        this.availableProjects.forEach((project) => {
          dropdown.addOption(
            project.id,
            project.title
          );
        });
        if (this.currentProject) {
          dropdown.setValue(this.currentProject.id);
        }
        dropdown.onChange((value) => {
          this.selectedProjectId = value || void 0;
        });
      });
    }
    new import_obsidian18.Setting(contentEl).setName("Title").setDesc("Enter the task title (required)").addText((text) => {
      text.inputEl.addClass("quick-task-title-input");
      text.setPlaceholder("Task title...");
      text.onChange((value) => {
        this.taskTitle = value;
      });
      text.inputEl.focus();
      text.inputEl.select();
    });
    new import_obsidian18.Setting(contentEl).setName("Description").setDesc("Optional task description").addTextArea((text) => {
      text.inputEl.addClass("quick-task-description-input");
      text.setPlaceholder("Task description...");
      text.inputEl.rows = 3;
      text.onChange((value) => {
        this.taskDescription = value;
      });
    });
    const priorityStatusDiv = contentEl.createDiv({ cls: "quick-task-row" });
    new import_obsidian18.Setting(priorityStatusDiv).setName("Priority").addDropdown((dropdown) => {
      dropdown.addOption("low", "\u{1F7E2} Low").addOption("medium", "\u{1F7E1} Medium").addOption("high", "\u{1F7E0} High").addOption("urgent", "\u{1F534} Urgent").setValue(this.taskPriority).onChange((value) => {
        this.taskPriority = value;
      });
    });
    new import_obsidian18.Setting(priorityStatusDiv).setName("Status").addDropdown((dropdown) => {
      dropdown.addOption("todo", "\u{1F4CB} Todo").addOption("in-progress", "\u{1F504} In Progress").addOption("done", "\u2705 Done").addOption("cancelled", "\u274C Cancelled").setValue(this.taskStatus).onChange((value) => {
        this.taskStatus = value;
      });
    });
    const dateHoursDiv = contentEl.createDiv({ cls: "quick-task-row" });
    new import_obsidian18.Setting(dateHoursDiv).setName("Due Date").addText((text) => {
      text.inputEl.type = "date";
      text.onChange((value) => {
        this.taskDueDate = value;
      });
      const tomorrow = new Date();
      tomorrow.setDate(tomorrow.getDate() + 1);
      text.setValue(tomorrow.toISOString().split("T")[0]);
      this.taskDueDate = tomorrow.toISOString().split("T")[0];
    });
    new import_obsidian18.Setting(dateHoursDiv).setName("Est. Hours").addText((text) => {
      text.inputEl.type = "number";
      text.inputEl.min = "0";
      text.inputEl.step = "0.5";
      text.setPlaceholder("0");
      text.onChange((value) => {
        const hours = parseFloat(value);
        this.taskEstimatedHours = isNaN(hours) ? void 0 : hours;
      });
    });
    new import_obsidian18.Setting(contentEl).setName("Tags").setDesc("Enter tags separated by commas").addText((text) => {
      text.inputEl.addClass("quick-task-tags-input");
      text.setPlaceholder("tag1, tag2, tag3");
      text.onChange((value) => {
        this.taskTags = value.split(",").map((tag) => tag.trim()).filter((tag) => tag.length > 0);
      });
    });
    const buttonDiv = contentEl.createDiv({ cls: "quick-task-buttons" });
    const createBtn = buttonDiv.createEl("button", {
      text: "Create Task",
      cls: "mod-cta"
    });
    createBtn.addEventListener("click", async () => {
      await this.createTask();
    });
    const createContinueBtn = buttonDiv.createEl("button", {
      text: "Create & Continue",
      cls: "mod-primary"
    });
    createContinueBtn.addEventListener("click", async () => {
      const success = await this.createTask();
      if (success) {
        this.resetForm();
        this.onOpen();
      }
    });
    const cancelBtn = buttonDiv.createEl("button", {
      text: "Cancel"
    });
    cancelBtn.addEventListener("click", () => {
      this.close();
    });
    this.addStyles();
    contentEl.addEventListener("keydown", async (e) => {
      if (e.key === "Enter" && e.ctrlKey) {
        await this.createTask();
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  /**
   * Load current project context
   */
  async loadProjectContext() {
    try {
      const response = await this.getCurrentProjectUseCase.execute({
        activeFile: this.activeFile,
        preferences: {
          includeCompleted: false,
          maxResults: 10,
          selectionStrategy: "context"
        }
      });
      if (response.success && response.currentProject) {
        this.currentProject = response.currentProject;
      }
      if (response.availableProjects && response.availableProjects.length > 0) {
        this.availableProjects = response.availableProjects;
      }
    } catch (error) {
      console.error("Failed to load project context:", error);
    }
  }
  /**
   * Create the task
   */
  async createTask() {
    var _a;
    if (!this.taskTitle || this.taskTitle.trim().length === 0) {
      new import_obsidian18.Notice("Task title is required");
      return false;
    }
    try {
      const request = {
        title: this.taskTitle.trim(),
        description: this.taskDescription.trim() || void 0,
        priority: this.taskPriority,
        status: this.taskStatus,
        projectId: this.selectedProjectId,
        dueDate: this.taskDueDate || void 0,
        estimatedHours: this.taskEstimatedHours,
        tags: this.taskTags,
        context: {
          activeFile: this.activeFile
        }
      };
      const response = await this.createTaskUseCase.execute(request);
      if (response.success) {
        new import_obsidian18.Notice(`Task "${(_a = response.task) == null ? void 0 : _a.title}" created successfully`);
        this.close();
        return true;
      } else {
        new import_obsidian18.Notice(`Failed to create task: ${response.message}`);
        console.error("Task creation failed:", response.errors);
        return false;
      }
    } catch (error) {
      new import_obsidian18.Notice(`Error creating task: ${error.message}`);
      console.error("Task creation error:", error);
      return false;
    }
  }
  /**
   * Reset form fields
   */
  resetForm() {
    this.taskTitle = "";
    this.taskDescription = "";
    this.taskPriority = "medium";
    this.taskStatus = "todo";
    this.taskDueDate = "";
    this.taskEstimatedHours = void 0;
    this.taskTags = [];
  }
  /**
   * Add custom styles
   */
  addStyles() {
    const style = document.createElement("style");
    style.textContent = `
      .quick-task-project {
        padding: 10px;
        margin-bottom: 15px;
        background: var(--background-secondary);
        border-radius: 5px;
      }

      .quick-task-project-current {
        font-weight: bold;
        color: var(--text-accent);
      }

      .quick-task-row {
        display: flex;
        gap: 15px;
        margin-bottom: 15px;
      }

      .quick-task-row .setting-item {
        flex: 1;
        margin-bottom: 0;
      }

      .quick-task-title-input {
        font-size: 1.1em;
        font-weight: bold;
      }

      .quick-task-description-input {
        font-family: var(--font-monospace);
        min-height: 60px;
      }

      .quick-task-tags-input {
        font-family: var(--font-monospace);
      }

      .quick-task-buttons {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
        margin-top: 20px;
        padding-top: 15px;
        border-top: 1px solid var(--background-modifier-border);
      }

      .quick-task-buttons button {
        padding: 8px 16px;
      }
    `;
    document.head.appendChild(style);
  }
};

// src/domain/value-objects/TaskId.ts
var TaskId = class {
  constructor(value) {
    this.value = value;
  }
  static create(value) {
    if (!value || value.trim().length === 0) {
      return Result.fail("TaskId cannot be empty");
    }
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    if (!uuidRegex.test(value)) {
      return Result.fail("TaskId must be a valid UUID");
    }
    return Result.ok(new TaskId(value));
  }
  static generate() {
    const uuid = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
    return new TaskId(uuid);
  }
  toString() {
    return this.value;
  }
  equals(other) {
    return this.value === other.value;
  }
};

// src/domain/value-objects/Priority.ts
var PriorityLevel = /* @__PURE__ */ ((PriorityLevel3) => {
  PriorityLevel3["LOW"] = "low";
  PriorityLevel3["MEDIUM"] = "medium";
  PriorityLevel3["HIGH"] = "high";
  PriorityLevel3["URGENT"] = "urgent";
  return PriorityLevel3;
})(PriorityLevel || {});
var Priority = class {
  constructor(level) {
    this.level = level;
  }
  static create(value) {
    if (!value) {
      return Result.fail("Priority cannot be empty");
    }
    const normalizedValue = typeof value === "string" ? value.toLowerCase() : value;
    if (!Object.values(PriorityLevel).includes(normalizedValue)) {
      return Result.fail("Priority must be one of: low, medium, high, urgent");
    }
    return Result.ok(new Priority(normalizedValue));
  }
  static low() {
    return new Priority("low" /* LOW */);
  }
  static medium() {
    return new Priority("medium" /* MEDIUM */);
  }
  static high() {
    return new Priority("high" /* HIGH */);
  }
  static urgent() {
    return new Priority("urgent" /* URGENT */);
  }
  getLevel() {
    return this.level;
  }
  toString() {
    return this.level;
  }
  equals(other) {
    return this.level === other.level;
  }
  /**
   * Returns numeric value for sorting (higher number = higher priority)
   */
  getNumericValue() {
    switch (this.level) {
      case "low" /* LOW */:
        return 1;
      case "medium" /* MEDIUM */:
        return 2;
      case "high" /* HIGH */:
        return 3;
      case "urgent" /* URGENT */:
        return 4;
    }
  }
  /**
   * Compares priorities for sorting
   * Returns negative if this < other, positive if this > other, 0 if equal
   */
  compare(other) {
    return this.getNumericValue() - other.getNumericValue();
  }
  isHigherThan(other) {
    return this.getNumericValue() > other.getNumericValue();
  }
  isLowerThan(other) {
    return this.getNumericValue() < other.getNumericValue();
  }
};

// src/domain/value-objects/TaskStatus.ts
var TaskStatusType = /* @__PURE__ */ ((TaskStatusType3) => {
  TaskStatusType3["TODO"] = "todo";
  TaskStatusType3["IN_PROGRESS"] = "in-progress";
  TaskStatusType3["WAITING"] = "waiting";
  TaskStatusType3["DONE"] = "done";
  TaskStatusType3["CANCELLED"] = "cancelled";
  return TaskStatusType3;
})(TaskStatusType || {});
var TaskStatus = class {
  constructor(status) {
    this.status = status;
  }
  static create(value) {
    if (!value) {
      return Result.fail("TaskStatus cannot be empty");
    }
    const normalizedValue = typeof value === "string" ? value.toLowerCase().replace("_", "-") : value;
    if (!Object.values(TaskStatusType).includes(normalizedValue)) {
      return Result.fail("TaskStatus must be one of: todo, in-progress, waiting, done, cancelled");
    }
    return Result.ok(new TaskStatus(normalizedValue));
  }
  static todo() {
    return new TaskStatus("todo" /* TODO */);
  }
  static inProgress() {
    return new TaskStatus("in-progress" /* IN_PROGRESS */);
  }
  static waiting() {
    return new TaskStatus("waiting" /* WAITING */);
  }
  static done() {
    return new TaskStatus("done" /* DONE */);
  }
  static cancelled() {
    return new TaskStatus("cancelled" /* CANCELLED */);
  }
  getStatus() {
    return this.status;
  }
  toString() {
    return this.status;
  }
  equals(other) {
    return this.status === other.status;
  }
  /**
   * Checks if transition to another status is valid
   */
  canTransitionTo(newStatus) {
    const validTransitions = {
      ["todo" /* TODO */]: ["in-progress" /* IN_PROGRESS */, "waiting" /* WAITING */, "done" /* DONE */, "cancelled" /* CANCELLED */],
      ["in-progress" /* IN_PROGRESS */]: ["todo" /* TODO */, "waiting" /* WAITING */, "done" /* DONE */, "cancelled" /* CANCELLED */],
      ["waiting" /* WAITING */]: ["todo" /* TODO */, "in-progress" /* IN_PROGRESS */, "done" /* DONE */, "cancelled" /* CANCELLED */],
      ["done" /* DONE */]: ["todo" /* TODO */],
      // Can reopen completed tasks
      ["cancelled" /* CANCELLED */]: ["todo" /* TODO */]
      // Can reactivate cancelled tasks
    };
    return validTransitions[this.status].includes(newStatus.status);
  }
  /**
   * Returns if the task is in an active state (not done or cancelled)
   */
  isActive() {
    return this.status === "todo" /* TODO */ || this.status === "in-progress" /* IN_PROGRESS */ || this.status === "waiting" /* WAITING */;
  }
  /**
   * Returns if the task is completed
   */
  isCompleted() {
    return this.status === "done" /* DONE */;
  }
  /**
   * Returns if the task is cancelled
   */
  isCancelled() {
    return this.status === "cancelled" /* CANCELLED */;
  }
  /**
   * Returns if the task is in progress
   */
  isInProgress() {
    return this.status === "in-progress" /* IN_PROGRESS */;
  }
  /**
   * Returns markdown checkbox representation
   */
  toMarkdownCheckbox() {
    switch (this.status) {
      case "todo" /* TODO */:
        return "- [ ]";
      case "in-progress" /* IN_PROGRESS */:
        return "- [/]";
      case "waiting" /* WAITING */:
        return "- [-]";
      case "done" /* DONE */:
        return "- [x]";
      case "cancelled" /* CANCELLED */:
        return "- [~]";
    }
  }
  /**
   * Creates TaskStatus from markdown checkbox
   */
  static fromMarkdownCheckbox(checkbox) {
    const trimmed = checkbox.trim();
    if (trimmed === "- [ ]")
      return Result.ok(TaskStatus.todo());
    if (trimmed === "- [/]")
      return Result.ok(TaskStatus.inProgress());
    if (trimmed === "- [-]")
      return Result.ok(TaskStatus.waiting());
    if (trimmed === "- [x]" || trimmed === "- [X]")
      return Result.ok(TaskStatus.done());
    if (trimmed === "- [~]")
      return Result.ok(TaskStatus.cancelled());
    return Result.fail("Invalid markdown checkbox format");
  }
};

// src/domain/entities/Task.ts
var Task = class extends Entity {
  constructor(props) {
    super(props);
  }
  static create(params) {
    var _a;
    if (!params.title || params.title.trim().length === 0) {
      return Result.fail("Task title cannot be empty");
    }
    if (params.title.length > 200) {
      return Result.fail("Task title cannot exceed 200 characters");
    }
    if (params.estimatedHours !== void 0 && params.estimatedHours < 0) {
      return Result.fail("Estimated hours cannot be negative");
    }
    if (params.dueDate && params.dueDate < new Date()) {
      console.warn("Task created with past due date:", params.dueDate);
    }
    const props = {
      id: TaskId.generate(),
      title: params.title.trim(),
      description: (_a = params.description) == null ? void 0 : _a.trim(),
      priority: params.priority || Priority.medium(),
      status: params.status || TaskStatus.todo(),
      projectId: params.projectId,
      dueDate: params.dueDate,
      estimatedHours: params.estimatedHours,
      tags: params.tags || [],
      createdAt: new Date(),
      updatedAt: new Date()
    };
    return Result.ok(new Task(props));
  }
  // Getters
  getId() {
    return this.props.id;
  }
  getTitle() {
    return this.props.title;
  }
  getDescription() {
    return this.props.description;
  }
  getPriority() {
    return this.props.priority;
  }
  getStatus() {
    return this.props.status;
  }
  getProjectId() {
    return this.props.projectId;
  }
  getDueDate() {
    return this.props.dueDate;
  }
  getEstimatedHours() {
    return this.props.estimatedHours;
  }
  getTags() {
    return [...this.props.tags];
  }
  getCreatedAt() {
    return this.props.createdAt;
  }
  getUpdatedAt() {
    return this.props.updatedAt;
  }
  getCompletedAt() {
    return this.props.completedAt;
  }
  // Override equals to use TaskId comparison
  equals(object) {
    if (object === null || object === void 0) {
      return false;
    }
    if (this === object) {
      return true;
    }
    if (!(object instanceof Task)) {
      return false;
    }
    return this.props.id.equals(object.props.id);
  }
  // Business methods
  updateTitle(title) {
    if (!title || title.trim().length === 0) {
      return Result.fail("Task title cannot be empty");
    }
    if (title.length > 200) {
      return Result.fail("Task title cannot exceed 200 characters");
    }
    this.props.title = title.trim();
    this.props.updatedAt = new Date();
    return Result.ok();
  }
  updateDescription(description) {
    this.props.description = description == null ? void 0 : description.trim();
    this.props.updatedAt = new Date();
  }
  updatePriority(priority) {
    this.props.priority = priority;
    this.props.updatedAt = new Date();
  }
  updateStatus(status) {
    if (!this.props.status.canTransitionTo(status)) {
      return Result.fail(`Cannot transition from ${this.props.status.toString()} to ${status.toString()}`);
    }
    this.props.status = status;
    this.props.updatedAt = new Date();
    if (status.isCompleted()) {
      this.props.completedAt = new Date();
    } else if (this.props.completedAt) {
      this.props.completedAt = void 0;
    }
    return Result.ok();
  }
  assignToProject(projectId) {
    this.props.projectId = projectId;
    this.props.updatedAt = new Date();
  }
  removeFromProject() {
    this.props.projectId = void 0;
    this.props.updatedAt = new Date();
  }
  setDueDate(dueDate) {
    this.props.dueDate = dueDate;
    this.props.updatedAt = new Date();
  }
  removeDueDate() {
    this.props.dueDate = void 0;
    this.props.updatedAt = new Date();
  }
  setEstimatedHours(hours) {
    if (hours < 0) {
      return Result.fail("Estimated hours cannot be negative");
    }
    this.props.estimatedHours = hours;
    this.props.updatedAt = new Date();
    return Result.ok();
  }
  addTag(tag) {
    const normalizedTag = tag.trim().toLowerCase();
    if (normalizedTag && !this.props.tags.includes(normalizedTag)) {
      this.props.tags.push(normalizedTag);
      this.props.updatedAt = new Date();
    }
  }
  removeTag(tag) {
    const normalizedTag = tag.trim().toLowerCase();
    const index = this.props.tags.indexOf(normalizedTag);
    if (index > -1) {
      this.props.tags.splice(index, 1);
      this.props.updatedAt = new Date();
    }
  }
  hasTag(tag) {
    return this.props.tags.includes(tag.trim().toLowerCase());
  }
  // Query methods
  isOverdue() {
    return this.props.dueDate !== void 0 && this.props.dueDate < new Date() && this.props.status.isActive();
  }
  isDueToday() {
    if (!this.props.dueDate)
      return false;
    const today = new Date();
    const due = this.props.dueDate;
    return today.getFullYear() === due.getFullYear() && today.getMonth() === due.getMonth() && today.getDate() === due.getDate();
  }
  isHighPriority() {
    return this.props.priority.isHigherThan(Priority.medium());
  }
  // Serialization methods
  toFrontmatter() {
    const frontmatter = {
      "exo__Task_uid": this.props.id.toString(),
      "exo__Task_title": this.props.title,
      "exo__Task_priority": this.props.priority.toString(),
      "exo__Task_status": this.props.status.toString(),
      "exo__Task_createdAt": this.props.createdAt.toISOString(),
      "exo__Task_updatedAt": this.props.updatedAt.toISOString()
    };
    if (this.props.description) {
      frontmatter["exo__Task_description"] = this.props.description;
    }
    if (this.props.projectId) {
      frontmatter["exo__Effort_parent"] = `[[${this.props.projectId.toString()}]]`;
    }
    if (this.props.dueDate) {
      frontmatter["exo__Task_dueDate"] = this.props.dueDate.toISOString().split("T")[0];
    }
    if (this.props.estimatedHours !== void 0) {
      frontmatter["exo__Task_estimatedHours"] = this.props.estimatedHours;
    }
    if (this.props.tags.length > 0) {
      frontmatter["exo__Task_tags"] = this.props.tags;
    }
    if (this.props.completedAt) {
      frontmatter["exo__Task_completedAt"] = this.props.completedAt.toISOString();
    }
    return frontmatter;
  }
  static fromFrontmatter(frontmatter, fileName) {
    try {
      const idResult = TaskId.create(frontmatter["exo__Task_uid"] || TaskId.generate().toString());
      const id = idResult.isSuccess ? idResult.getValue() : TaskId.generate();
      const title = frontmatter["exo__Task_title"] || fileName.replace(".md", "");
      const description = frontmatter["exo__Task_description"];
      const priorityResult = Priority.create(frontmatter["exo__Task_priority"] || "medium");
      const priority = priorityResult.isSuccess ? priorityResult.getValue() : Priority.medium();
      const statusResult = TaskStatus.create(frontmatter["exo__Task_status"] || "todo");
      const status = statusResult.isSuccess ? statusResult.getValue() : TaskStatus.todo();
      let projectId;
      const parentValue = frontmatter["exo__Effort_parent"];
      if (parentValue) {
        const cleanParent = parentValue.toString().replace(/\[\[|\]\]/g, "");
        const projectIdResult = AssetId.create(cleanParent);
        if (projectIdResult.isSuccess) {
          projectId = projectIdResult.getValue();
        }
      }
      const dueDate = frontmatter["exo__Task_dueDate"] ? new Date(frontmatter["exo__Task_dueDate"]) : void 0;
      const estimatedHours = frontmatter["exo__Task_estimatedHours"];
      const tags = Array.isArray(frontmatter["exo__Task_tags"]) ? frontmatter["exo__Task_tags"] : [];
      const createdAt = frontmatter["exo__Task_createdAt"] ? new Date(frontmatter["exo__Task_createdAt"]) : new Date();
      const result = Task.create({
        title,
        description,
        priority,
        status,
        projectId,
        dueDate,
        estimatedHours,
        tags
      });
      if (result.isSuccess) {
        const task = result.getValue();
        task.props.id = id;
        task.props.createdAt = createdAt;
        if (frontmatter["exo__Task_completedAt"]) {
          task.props.completedAt = new Date(frontmatter["exo__Task_completedAt"]);
        }
        return task;
      } else {
        console.warn("Failed to create task from frontmatter:", result.error);
      }
      return null;
    } catch (error) {
      console.warn("Failed to create task from frontmatter:", error);
      return null;
    }
  }
  /**
   * Generates markdown content for the task
   */
  toMarkdown() {
    let content = `# ${this.props.title}

`;
    if (this.props.description) {
      content += `${this.props.description}

`;
    }
    content += `## Task Details

`;
    content += `${this.props.status.toMarkdownCheckbox()} **Status**: ${this.props.status.toString()}
`;
    content += `- **Priority**: ${this.props.priority.toString()}
`;
    if (this.props.dueDate) {
      content += `- **Due Date**: ${this.props.dueDate.toISOString().split("T")[0]}
`;
    }
    if (this.props.estimatedHours) {
      content += `- **Estimated Hours**: ${this.props.estimatedHours}
`;
    }
    if (this.props.projectId) {
      content += `- **Project**: [[${this.props.projectId.toString()}]]
`;
    }
    if (this.props.tags.length > 0) {
      content += `- **Tags**: ${this.props.tags.map((tag) => `#${tag}`).join(" ")}
`;
    }
    content += `
---

`;
    content += `*Created: ${this.props.createdAt.toISOString()}*
`;
    content += `*Updated: ${this.props.updatedAt.toISOString()}*
`;
    if (this.props.completedAt) {
      content += `*Completed: ${this.props.completedAt.toISOString()}*
`;
    }
    return content;
  }
};

// src/application/use-cases/CreateTaskFromProjectUseCase.ts
var CreateTaskFromProjectUseCase = class {
  constructor(taskRepository, assetRepository, graph, getCurrentProjectUseCase) {
    this.taskRepository = taskRepository;
    this.assetRepository = assetRepository;
    this.graph = graph;
    this.getCurrentProjectUseCase = getCurrentProjectUseCase;
  }
  async execute(request) {
    var _a, _b;
    try {
      const validationResult = this.validateRequest(request);
      if (validationResult.isFailure) {
        return {
          success: false,
          message: validationResult.error,
          errors: { request: [validationResult.error] }
        };
      }
      const processedRequest = await this.applyTemplate(request);
      const projectContext = await this.resolveProjectContext(processedRequest);
      const taskResult = await this.createTask(processedRequest, projectContext);
      if (taskResult.isFailure) {
        return {
          success: false,
          message: taskResult.error,
          errors: { task: [taskResult.error] }
        };
      }
      const task = taskResult.getValue();
      await this.taskRepository.save(task);
      const saveResult = await this.saveTaskAsAsset(task, processedRequest);
      if (saveResult.isFailure) {
        console.warn("Failed to save task as asset:", saveResult.error);
      }
      const rdfTriples = await this.updateRDFGraph(task, projectContext);
      return {
        success: true,
        taskId: task.getId().toString(),
        message: `Task "${task.getTitle()}" created successfully`,
        task: {
          id: task.getId().toString(),
          title: task.getTitle(),
          status: task.getStatus().toString(),
          priority: task.getPriority().toString(),
          projectId: (_a = task.getProjectId()) == null ? void 0 : _a.toString(),
          dueDate: (_b = task.getDueDate()) == null ? void 0 : _b.toISOString().split("T")[0],
          tags: task.getTags()
        },
        rdfTriples
      };
    } catch (error) {
      return {
        success: false,
        message: `Failed to create task: ${error.message}`,
        errors: { system: [error.message] }
      };
    }
  }
  /**
   * Validate the task creation request
   */
  validateRequest(request) {
    const errors = [];
    if (!request.title || request.title.trim().length === 0) {
      errors.push("Task title is required");
    }
    if (request.title && request.title.length > 200) {
      errors.push("Task title cannot exceed 200 characters");
    }
    if (request.estimatedHours !== void 0) {
      if (typeof request.estimatedHours !== "number" || request.estimatedHours < 0) {
        errors.push("Estimated hours must be a non-negative number");
      }
    }
    if (request.dueDate) {
      const dueDate = new Date(request.dueDate);
      if (isNaN(dueDate.getTime())) {
        errors.push("Due date must be a valid date");
      }
    }
    if (request.priority && !["low", "medium", "high", "urgent"].includes(request.priority)) {
      errors.push("Priority must be one of: low, medium, high, urgent");
    }
    if (request.status && !["todo", "in-progress", "done", "cancelled"].includes(request.status)) {
      errors.push("Status must be one of: todo, in-progress, done, cancelled");
    }
    if (errors.length > 0) {
      return Result.fail(errors.join("; "));
    }
    return Result.ok();
  }
  /**
   * Apply task template if specified
   */
  async applyTemplate(request) {
    if (!request.templateId) {
      return request;
    }
    try {
      const templateId = AssetId.create(request.templateId);
      if (templateId.isFailure) {
        console.warn("Invalid template ID:", request.templateId);
        return request;
      }
      const template = await this.assetRepository.findById(templateId.getValue());
      if (!template) {
        console.warn("Template not found:", request.templateId);
        return request;
      }
      const templateRequest = { ...request };
      if (!templateRequest.description && template.getProperty("description")) {
        templateRequest.description = template.getProperty("description");
      }
      if (!templateRequest.priority && template.getProperty("priority")) {
        templateRequest.priority = template.getProperty("priority");
      }
      if (!templateRequest.estimatedHours && template.getProperty("estimatedHours")) {
        templateRequest.estimatedHours = template.getProperty("estimatedHours");
      }
      if (!templateRequest.tags || templateRequest.tags.length === 0) {
        const templateTags = template.getProperty("tags");
        if (templateTags && Array.isArray(templateTags)) {
          templateRequest.tags = templateTags;
        }
      }
      if (request.templateVariables) {
        templateRequest.title = this.substituteVariables(templateRequest.title, request.templateVariables);
        if (templateRequest.description) {
          templateRequest.description = this.substituteVariables(templateRequest.description, request.templateVariables);
        }
      }
      return templateRequest;
    } catch (error) {
      console.warn("Failed to apply template:", error);
      return request;
    }
  }
  /**
   * Substitute template variables in text
   */
  substituteVariables(text, variables) {
    let result = text;
    for (const [key, value] of Object.entries(variables)) {
      const regex = new RegExp(`\\{\\{${key}\\}\\}`, "g");
      result = result.replace(regex, value);
    }
    return result;
  }
  /**
   * Resolve project context for task association
   */
  async resolveProjectContext(request) {
    var _a, _b;
    if (request.projectId) {
      const projectId = AssetId.create(request.projectId);
      if (projectId.isSuccess) {
        const project = await this.assetRepository.findById(projectId.getValue());
        if (project) {
          return request.projectId;
        }
      }
    }
    const projectResponse = await this.getCurrentProjectUseCase.execute({
      activeFile: (_a = request.context) == null ? void 0 : _a.activeFile,
      preferences: {
        includeCompleted: false,
        maxResults: 5,
        selectionStrategy: "context"
      }
    });
    return (_b = projectResponse.currentProject) == null ? void 0 : _b.id;
  }
  /**
   * Create the task domain entity
   */
  async createTask(request, projectId) {
    var _a;
    let priority;
    if (request.priority) {
      const priorityResult = Priority.create(request.priority);
      if (priorityResult.isFailure) {
        return Result.fail(`Invalid priority: ${priorityResult.error}`);
      }
      priority = priorityResult.getValue();
    } else {
      priority = Priority.medium();
    }
    let status;
    if (request.status) {
      const statusResult = TaskStatus.create(request.status);
      if (statusResult.isFailure) {
        return Result.fail(`Invalid status: ${statusResult.error}`);
      }
      status = statusResult.getValue();
    } else {
      status = TaskStatus.todo();
    }
    let taskProjectId;
    if (projectId) {
      const projectIdResult = AssetId.create(projectId);
      if (projectIdResult.isSuccess) {
        taskProjectId = projectIdResult.getValue();
      }
    }
    let dueDate;
    if (request.dueDate) {
      dueDate = new Date(request.dueDate);
      if (isNaN(dueDate.getTime())) {
        return Result.fail("Invalid due date format");
      }
    }
    return Task.create({
      title: request.title.trim(),
      description: (_a = request.description) == null ? void 0 : _a.trim(),
      priority,
      status,
      projectId: taskProjectId,
      dueDate,
      estimatedHours: request.estimatedHours,
      tags: request.tags || []
    });
  }
  /**
   * Save task as an asset in the repository
   */
  async saveTaskAsAsset(task, request) {
    var _a, _b, _c;
    try {
      const assetResult = Asset.create({
        id: AssetId.create(task.getId().toString()).getValue(),
        label: task.getTitle(),
        className: ClassName.create("ems__Task").getValue(),
        ontology: OntologyPrefix.create("ems").getValue(),
        properties: {
          ...task.toFrontmatter(),
          // Add context information
          creationContext: {
            activeFile: (_a = request.context) == null ? void 0 : _a.activeFile,
            selection: (_b = request.context) == null ? void 0 : _b.selection,
            focusContext: (_c = request.context) == null ? void 0 : _c.focusContext,
            timestamp: new Date().toISOString()
          }
        }
      });
      if (assetResult.isFailure) {
        return Result.fail(`Failed to create asset: ${assetResult.error}`);
      }
      const asset = assetResult.getValue();
      await this.assetRepository.save(asset);
      return Result.ok();
    } catch (error) {
      return Result.fail(`Failed to save task: ${error.message}`);
    }
  }
  /**
   * Update RDF graph with task relationships and metadata
   */
  async updateRDFGraph(task, projectId) {
    const triples = [];
    const taskIRI = this.ensureValidIRI(task.getId().toString());
    try {
      this.addTriple(triples, taskIRI, "rdf:type", "ems:Task");
      this.addTriple(triples, taskIRI, "ems:title", task.getTitle());
      this.addTriple(triples, taskIRI, "ems:status", task.getStatus().toString());
      this.addTriple(triples, taskIRI, "ems:priority", task.getPriority().toString());
      this.addTriple(triples, taskIRI, "ems:createdAt", task.getCreatedAt().toISOString());
      this.addTriple(triples, taskIRI, "ems:updatedAt", task.getUpdatedAt().toISOString());
      const description = task.getDescription();
      if (description) {
        this.addTriple(triples, taskIRI, "ems:description", description);
      }
      const dueDate = task.getDueDate();
      if (dueDate) {
        this.addTriple(triples, taskIRI, "ems:dueDate", dueDate.toISOString());
      }
      const estimatedHours = task.getEstimatedHours();
      if (estimatedHours !== void 0) {
        this.addTriple(triples, taskIRI, "ems:estimatedHours", estimatedHours.toString());
      }
      if (projectId) {
        const projectIRI = this.ensureValidIRI(projectId);
        this.addTriple(triples, taskIRI, "ems:belongsToProject", projectIRI);
        this.addTriple(triples, projectIRI, "ems:hasTask", taskIRI);
      }
      for (const tag of task.getTags()) {
        this.addTriple(triples, taskIRI, "ems:hasTag", tag);
      }
      for (const tripleData of triples) {
        try {
          const subjectIRI = this.ensureValidIRI(tripleData.subject);
          const predicateIRI = this.ensureValidIRI(tripleData.predicate);
          const triple = new Triple(
            new IRI(subjectIRI),
            new IRI(predicateIRI),
            tripleData.object.startsWith('"') ? new Literal(tripleData.object.slice(1, -1)) : new IRI(this.ensureValidIRI(tripleData.object))
          );
          this.graph.add(triple);
        } catch (error) {
          console.warn("Failed to create triple:", tripleData, error);
        }
      }
      return triples;
    } catch (error) {
      console.warn("Failed to update RDF graph:", error);
      return [];
    }
  }
  /**
   * Helper method to add triple data
   */
  addTriple(triples, subject, predicate, object) {
    if (!triples) {
      return;
    }
    triples.push({
      subject,
      predicate,
      object: object.includes(" ") || object.includes(":") === false ? `"${object}"` : object
    });
  }
  /**
   * Ensure a string is formatted as a valid IRI
   */
  ensureValidIRI(value) {
    if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(value)) {
      return `ems:${value}`;
    }
    if (value.includes(":")) {
      return value;
    }
    return `ems:${value}`;
  }
};

// src/application/use-cases/GetCurrentProjectUseCase.ts
var GetCurrentProjectUseCase = class {
  constructor(assetRepository, focusService, graph) {
    this.assetRepository = assetRepository;
    this.focusService = focusService;
    this.graph = graph;
  }
  async execute(request) {
    var _a, _b, _c, _d;
    try {
      const availableProjects = await this.getAvailableProjects(
        (_b = (_a = request.preferences) == null ? void 0 : _a.includeCompleted) != null ? _b : false,
        (_d = (_c = request.preferences) == null ? void 0 : _c.maxResults) != null ? _d : 10
      );
      const currentProject = await this.detectCurrentProject(
        request,
        availableProjects
      );
      const context = this.buildContextInfo(request, currentProject);
      return {
        success: true,
        currentProject,
        availableProjects,
        context
      };
    } catch (error) {
      return {
        success: false,
        availableProjects: [],
        context: {
          strategy: "error",
          confidence: 0,
          reasoning: `Failed to get project context: ${error.message}`
        },
        message: error.message
      };
    }
  }
  /**
   * Get all available projects from the system
   */
  async getAvailableProjects(includeCompleted, maxResults) {
    try {
      const projectClassName = ClassName.create("ems__Project");
      if (projectClassName.isFailure) {
        return [];
      }
      const projectAssets = await this.assetRepository.findByClass(
        projectClassName.getValue()
      );
      const projects = projectAssets.filter((asset) => {
        if (!includeCompleted) {
          const status = asset.getProperty("status");
          return status !== "completed" && status !== "cancelled";
        }
        return true;
      }).map((asset) => ({
        id: asset.getId().toString(),
        title: asset.getTitle(),
        status: asset.getProperty("status") || "active",
        priority: asset.getProperty("priority") || "medium",
        description: asset.getProperty("description"),
        isActive: asset.getProperty("status") === "active",
        lastUpdated: asset.getProperty("updatedAt") || new Date().toISOString()
      })).sort((a, b) => {
        if (a.isActive && !b.isActive)
          return -1;
        if (!a.isActive && b.isActive)
          return 1;
        return new Date(b.lastUpdated).getTime() - new Date(a.lastUpdated).getTime();
      }).slice(0, maxResults);
      return projects;
    } catch (error) {
      console.warn("Failed to get available projects:", error);
      return [];
    }
  }
  /**
   * Detect current project based on context clues
   */
  async detectCurrentProject(request, availableProjects) {
    var _a;
    const strategy = ((_a = request.preferences) == null ? void 0 : _a.selectionStrategy) || "context";
    switch (strategy) {
      case "context":
        return this.detectByContext(request, availableProjects);
      case "recent":
        return this.detectByRecentActivity(availableProjects);
      case "active":
        return this.detectByActiveStatus(availableProjects);
      case "priority":
        return this.detectByPriority(availableProjects);
      default:
        return this.detectByContext(request, availableProjects);
    }
  }
  /**
   * Detect project by analyzing current file context
   */
  async detectByContext(request, availableProjects) {
    if (!request.activeFile) {
      return this.detectByRecentActivity(availableProjects);
    }
    try {
      const currentAsset = await this.assetRepository.findByFilename(request.activeFile);
      if (currentAsset) {
        const className = currentAsset.getClassName().toString();
        if (className === "ems__Project") {
          return this.assetToProjectResponse(currentAsset);
        }
        const projectId = currentAsset.getProperty("projectId") || currentAsset.getProperty("exo__Effort_parent");
        if (projectId) {
          const cleanProjectId = projectId.toString().replace(/\[\[|\]\]/g, "");
          const project = availableProjects.find((p) => p.id === cleanProjectId);
          if (project) {
            return project;
          }
        }
      }
      const projectFromGraph = await this.findProjectFromGraph(request.activeFile, availableProjects);
      if (projectFromGraph) {
        return projectFromGraph;
      }
      return this.detectByRecentActivity(availableProjects);
    } catch (error) {
      console.warn("Context-based project detection failed:", error);
      return this.detectByRecentActivity(availableProjects);
    }
  }
  /**
   * Detect project using RDF graph relationships
   */
  async findProjectFromGraph(activeFile, availableProjects) {
    try {
      const fileIRI = activeFile.replace(/\.md$/, "").replace(/\s+/g, "_");
      const projectTriples = this.graph.query(
        fileIRI,
        "exo__Effort_parent"
      );
      if (projectTriples.length > 0) {
        const projectIRI = projectTriples[0].getObject().toString();
        const project = availableProjects.find(
          (p) => p.id === projectIRI || p.title.replace(/\s+/g, "_") === projectIRI
        );
        if (project) {
          return project;
        }
      }
      const taskTriples = this.graph.query(
        void 0,
        "exo__Effort_parent",
        fileIRI
      );
      for (const triple of taskTriples) {
        const potentialProject = triple.getSubject().toString();
        const project = availableProjects.find(
          (p) => p.id === potentialProject || p.title.replace(/\s+/g, "_") === potentialProject
        );
        if (project) {
          return project;
        }
      }
      return void 0;
    } catch (error) {
      console.warn("Graph-based project detection failed:", error);
      return void 0;
    }
  }
  /**
   * Detect project by recent activity
   */
  detectByRecentActivity(availableProjects) {
    const recentProjects = availableProjects.filter((p) => p.isActive).sort((a, b) => new Date(b.lastUpdated).getTime() - new Date(a.lastUpdated).getTime());
    return recentProjects[0];
  }
  /**
   * Detect project by active status
   */
  detectByActiveStatus(availableProjects) {
    return availableProjects.find((p) => p.isActive);
  }
  /**
   * Detect project by priority
   */
  detectByPriority(availableProjects) {
    const priorityOrder = { urgent: 4, high: 3, medium: 2, low: 1 };
    return availableProjects.filter((p) => p.isActive).sort((a, b) => (priorityOrder[b.priority] || 2) - (priorityOrder[a.priority] || 2))[0];
  }
  /**
   * Build context information for response
   */
  buildContextInfo(request, currentProject) {
    var _a;
    const strategy = ((_a = request.preferences) == null ? void 0 : _a.selectionStrategy) || "context";
    let confidence = 0;
    let reasoning = "";
    if (currentProject) {
      switch (strategy) {
        case "context":
          confidence = request.activeFile ? 0.8 : 0.3;
          reasoning = request.activeFile ? `Detected from current file context: ${request.activeFile}` : "Used most recent active project";
          break;
        case "recent":
          confidence = 0.6;
          reasoning = "Selected most recently updated active project";
          break;
        case "active":
          confidence = 0.5;
          reasoning = "Selected first active project";
          break;
        case "priority":
          confidence = 0.7;
          reasoning = "Selected highest priority active project";
          break;
      }
    } else {
      reasoning = "No suitable project found";
    }
    return {
      strategy,
      confidence,
      reasoning
    };
  }
  /**
   * Convert Asset to project response format
   */
  assetToProjectResponse(asset) {
    return {
      id: asset.getId().toString(),
      title: asset.getTitle(),
      status: asset.getProperty("status") || "active",
      priority: asset.getProperty("priority") || "medium",
      description: asset.getProperty("description")
    };
  }
};

// src/infrastructure/repositories/ObsidianTaskRepository.ts
var import_obsidian19 = require("obsidian");
var ObsidianTaskRepository = class {
  constructor(app) {
    this.app = app;
    this.tasksFolder = "Tasks";
    this.taskCache = /* @__PURE__ */ new Map();
  }
  async findById(id) {
    var _a;
    const cached = this.taskCache.get(id.toString());
    if (cached) {
      return cached;
    }
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      if (file.path.startsWith(this.tasksFolder)) {
        const metadata = this.app.metadataCache.getFileCache(file);
        if (((_a = metadata == null ? void 0 : metadata.frontmatter) == null ? void 0 : _a.id) === id.toString()) {
          const task = await this.loadTaskFromFile(file);
          if (task) {
            this.taskCache.set(id.toString(), task);
            return task;
          }
        }
      }
    }
    return null;
  }
  async findByProject(projectId) {
    var _a;
    const tasks = [];
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      if (file.path.startsWith(this.tasksFolder)) {
        const metadata = this.app.metadataCache.getFileCache(file);
        if (((_a = metadata == null ? void 0 : metadata.frontmatter) == null ? void 0 : _a.projectId) === projectId.toString()) {
          const task = await this.loadTaskFromFile(file);
          if (task) {
            tasks.push(task);
          }
        }
      }
    }
    return tasks;
  }
  async findByStatus(status) {
    var _a;
    const tasks = [];
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      if (file.path.startsWith(this.tasksFolder)) {
        const metadata = this.app.metadataCache.getFileCache(file);
        if (((_a = metadata == null ? void 0 : metadata.frontmatter) == null ? void 0 : _a.status) === status.toString()) {
          const task = await this.loadTaskFromFile(file);
          if (task) {
            tasks.push(task);
          }
        }
      }
    }
    return tasks;
  }
  async findByPriority(priority) {
    var _a;
    const tasks = [];
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      if (file.path.startsWith(this.tasksFolder)) {
        const metadata = this.app.metadataCache.getFileCache(file);
        if (((_a = metadata == null ? void 0 : metadata.frontmatter) == null ? void 0 : _a.priority) === priority.toString()) {
          const task = await this.loadTaskFromFile(file);
          if (task) {
            tasks.push(task);
          }
        }
      }
    }
    return tasks;
  }
  async findByTag(tag) {
    var _a;
    const tasks = [];
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      if (file.path.startsWith(this.tasksFolder)) {
        const metadata = this.app.metadataCache.getFileCache(file);
        const tags = ((_a = metadata == null ? void 0 : metadata.frontmatter) == null ? void 0 : _a.tags) || [];
        if (Array.isArray(tags) && tags.includes(tag)) {
          const task = await this.loadTaskFromFile(file);
          if (task) {
            tasks.push(task);
          }
        }
      }
    }
    return tasks;
  }
  async findOverdue() {
    var _a;
    const now = new Date();
    const tasks = [];
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      if (file.path.startsWith(this.tasksFolder)) {
        const metadata = this.app.metadataCache.getFileCache(file);
        if ((_a = metadata == null ? void 0 : metadata.frontmatter) == null ? void 0 : _a.dueDate) {
          const dueDate = new Date(metadata.frontmatter.dueDate);
          if (dueDate < now && metadata.frontmatter.status !== "done") {
            const task = await this.loadTaskFromFile(file);
            if (task) {
              tasks.push(task);
            }
          }
        }
      }
    }
    return tasks;
  }
  async findDueToday() {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    return this.findDueBetween(today, tomorrow);
  }
  async findDueBetween(startDate, endDate) {
    var _a;
    const tasks = [];
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      if (file.path.startsWith(this.tasksFolder)) {
        const metadata = this.app.metadataCache.getFileCache(file);
        if ((_a = metadata == null ? void 0 : metadata.frontmatter) == null ? void 0 : _a.dueDate) {
          const dueDate = new Date(metadata.frontmatter.dueDate);
          if (dueDate >= startDate && dueDate <= endDate) {
            const task = await this.loadTaskFromFile(file);
            if (task) {
              tasks.push(task);
            }
          }
        }
      }
    }
    return tasks;
  }
  async findAll() {
    const tasks = [];
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      if (file.path.startsWith(this.tasksFolder)) {
        const task = await this.loadTaskFromFile(file);
        if (task) {
          tasks.push(task);
        }
      }
    }
    return tasks;
  }
  async findByCriteria(criteria) {
    let tasks = await this.findAll();
    if (criteria.status) {
      tasks = tasks.filter((t) => t.getStatus().equals(criteria.status));
    }
    if (criteria.priority) {
      tasks = tasks.filter((t) => t.getPriority().equals(criteria.priority));
    }
    if (criteria.projectId) {
      tasks = tasks.filter((t) => {
        var _a;
        return (_a = t.getProjectId()) == null ? void 0 : _a.equals(criteria.projectId);
      });
    }
    if (criteria.tags && criteria.tags.length > 0) {
      tasks = tasks.filter((t) => {
        const taskTags = t.getTags();
        return criteria.tags.some((tag) => taskTags.includes(tag));
      });
    }
    return tasks;
  }
  async save(task) {
    try {
      await this.ensureTasksFolder();
      const fileName = this.sanitizeFileName(task.getTitle());
      const filePath = `${this.tasksFolder}/${fileName}.md`;
      let file = this.app.vault.getAbstractFileByPath(filePath);
      if (!file) {
        file = await this.app.vault.create(filePath, "");
      }
      if (!(file instanceof import_obsidian19.TFile)) {
        throw new Error("File path exists but is not a file");
      }
      const content = this.generateTaskContent(task);
      await this.app.vault.modify(file, content);
      this.taskCache.set(task.getId().toString(), task);
      new import_obsidian19.Notice(`Task "${task.getTitle()}" saved successfully`);
    } catch (error) {
      console.error("Failed to save task:", error);
      new import_obsidian19.Notice(`Failed to save task: ${error.message}`);
      throw error;
    }
  }
  async delete(id) {
    var _a;
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      if (file.path.startsWith(this.tasksFolder)) {
        const metadata = this.app.metadataCache.getFileCache(file);
        if (((_a = metadata == null ? void 0 : metadata.frontmatter) == null ? void 0 : _a.id) === id.toString()) {
          await this.app.vault.delete(file);
          this.taskCache.delete(id.toString());
          new import_obsidian19.Notice("Task deleted successfully");
          return;
        }
      }
    }
    throw new Error(`Task with id ${id.toString()} not found`);
  }
  async exists(id) {
    const task = await this.findById(id);
    return task !== null;
  }
  async findByFilename(filename) {
    const file = this.app.vault.getAbstractFileByPath(`${this.tasksFolder}/${filename}`);
    if (file instanceof import_obsidian19.TFile) {
      return await this.loadTaskFromFile(file);
    }
    return null;
  }
  async getStatistics() {
    const tasks = await this.findAll();
    const now = new Date();
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    const weekEnd = new Date(today);
    weekEnd.setDate(weekEnd.getDate() + 7);
    const stats = {
      total: tasks.length,
      byStatus: {},
      byPriority: {},
      overdue: 0,
      dueToday: 0,
      dueThisWeek: 0,
      completed: 0,
      averageCompletionTime: void 0
    };
    let completionTimes = [];
    for (const task of tasks) {
      const status = task.getStatus().toString();
      stats.byStatus[status] = (stats.byStatus[status] || 0) + 1;
      if (status === "done") {
        stats.completed++;
        const createdAt = task.getCreatedAt();
        const updatedAt = task.getUpdatedAt();
        if (createdAt && updatedAt) {
          const completionTime = updatedAt.getTime() - createdAt.getTime();
          completionTimes.push(completionTime);
        }
      }
      const priority = task.getPriority().toString();
      stats.byPriority[priority] = (stats.byPriority[priority] || 0) + 1;
      const dueDate = task.getDueDate();
      if (dueDate) {
        if (dueDate < now && task.getStatus().toString() !== "done") {
          stats.overdue++;
        }
        if (dueDate >= today && dueDate < tomorrow) {
          stats.dueToday++;
        }
        if (dueDate >= today && dueDate < weekEnd) {
          stats.dueThisWeek++;
        }
      }
    }
    if (completionTimes.length > 0) {
      const totalTime = completionTimes.reduce((sum, time) => sum + time, 0);
      stats.averageCompletionTime = totalTime / completionTimes.length;
    }
    return stats;
  }
  async search(query) {
    const tasks = await this.findAll();
    const lowerQuery = query.toLowerCase();
    return tasks.filter((task) => {
      var _a;
      const title = task.getTitle().toLowerCase();
      const description = ((_a = task.getDescription()) == null ? void 0 : _a.toLowerCase()) || "";
      const tags = task.getTags().join(" ").toLowerCase();
      return title.includes(lowerQuery) || description.includes(lowerQuery) || tags.includes(lowerQuery);
    });
  }
  async findRecentlyUpdated(limit = 10) {
    const tasks = await this.findAll();
    return tasks.sort((a, b) => b.getUpdatedAt().getTime() - a.getUpdatedAt().getTime()).slice(0, limit);
  }
  async findRecentlyCreated(limit = 10) {
    const tasks = await this.findAll();
    return tasks.sort((a, b) => b.getCreatedAt().getTime() - a.getCreatedAt().getTime()).slice(0, limit);
  }
  /**
   * Load task from Obsidian file
   */
  async loadTaskFromFile(file) {
    var _a;
    try {
      const content = await this.app.vault.read(file);
      const metadata = this.app.metadataCache.getFileCache(file);
      if (!((_a = metadata == null ? void 0 : metadata.frontmatter) == null ? void 0 : _a.id)) {
        return null;
      }
      const fm = metadata.frontmatter;
      const priorityResult = Priority.create(fm.priority || "medium");
      if (priorityResult.isFailure) {
        console.warn(`Invalid priority in task ${fm.id}: ${fm.priority}`);
        return null;
      }
      const statusResult = TaskStatus.create(fm.status || "todo");
      if (statusResult.isFailure) {
        console.warn(`Invalid status in task ${fm.id}: ${fm.status}`);
        return null;
      }
      let projectId;
      if (fm.projectId) {
        const projectIdResult = AssetId.create(fm.projectId);
        if (projectIdResult.isSuccess) {
          projectId = projectIdResult.getValue();
        }
      }
      const dueDate = fm.dueDate ? new Date(fm.dueDate) : void 0;
      const createdAt = fm.createdAt ? new Date(fm.createdAt) : file.stat.ctime;
      const updatedAt = fm.updatedAt ? new Date(fm.updatedAt) : file.stat.mtime;
      const taskIdResult = TaskId.create(fm.id);
      if (taskIdResult.isFailure) {
        console.warn(`Invalid task ID: ${fm.id}`);
        return null;
      }
      const contentLines = content.split("\n");
      let inFrontmatter = false;
      let description = "";
      for (const line of contentLines) {
        if (line === "---") {
          inFrontmatter = !inFrontmatter;
          continue;
        }
        if (!inFrontmatter && line.trim() && !line.startsWith("#")) {
          description += line + "\n";
        }
      }
      const taskResult = Task.create({
        title: fm.title || file.basename,
        description: description.trim() || fm.description,
        priority: priorityResult.getValue(),
        status: statusResult.getValue(),
        projectId,
        dueDate,
        estimatedHours: fm.estimatedHours,
        tags: fm.tags || []
      });
      if (taskResult.isFailure) {
        console.warn(`Failed to create task from file ${file.path}: ${taskResult.error}`);
        return null;
      }
      return taskResult.getValue();
    } catch (error) {
      console.error(`Failed to load task from file ${file.path}:`, error);
      return null;
    }
  }
  /**
   * Generate markdown content for task
   */
  generateTaskContent(task) {
    var _a, _b;
    const frontmatter = task.toFrontmatter();
    const description = task.getDescription() || "";
    let content = "---\n";
    for (const [key, value] of Object.entries(frontmatter)) {
      if (value !== void 0 && value !== null) {
        if (Array.isArray(value)) {
          if (value.length > 0) {
            content += `${key}:
`;
            for (const item of value) {
              content += `  - ${item}
`;
            }
          }
        } else if (typeof value === "object") {
          content += `${key}: ${JSON.stringify(value)}
`;
        } else {
          content += `${key}: ${value}
`;
        }
      }
    }
    content += "---\n\n";
    content += `# ${task.getTitle()}

`;
    if (description) {
      content += `${description}

`;
    }
    content += "## Details\n\n";
    content += `- **Status**: ${task.getStatus().toString()}
`;
    content += `- **Priority**: ${task.getPriority().toString()}
`;
    if (task.getProjectId()) {
      content += `- **Project**: [[${(_a = task.getProjectId()) == null ? void 0 : _a.toString()}]]
`;
    }
    if (task.getDueDate()) {
      content += `- **Due Date**: ${(_b = task.getDueDate()) == null ? void 0 : _b.toISOString().split("T")[0]}
`;
    }
    if (task.getEstimatedHours()) {
      content += `- **Estimated Hours**: ${task.getEstimatedHours()}
`;
    }
    const tags = task.getTags();
    if (tags.length > 0) {
      content += "\n## Tags\n\n";
      content += tags.map((tag) => `#${tag}`).join(" ") + "\n";
    }
    content += "\n## Notes\n\n";
    content += "_Add your notes here..._\n";
    return content;
  }
  /**
   * Ensure tasks folder exists
   */
  async ensureTasksFolder() {
    const folder = this.app.vault.getAbstractFileByPath(this.tasksFolder);
    if (!folder) {
      await this.app.vault.createFolder(this.tasksFolder);
    }
  }
  /**
   * Sanitize filename for safe file creation
   */
  sanitizeFileName(title) {
    return title.replace(/[\\/:*?"<>|]/g, "-").replace(/\s+/g, " ").trim().substring(0, 100);
  }
};

// src/domain/semantic/core/IndexedGraph.ts
var IndexedGraph = class extends Graph {
  constructor() {
    super(...arguments);
    this.stats = null;
    this.metrics = {
      lastIndexTime: 0,
      lastQueryTime: 0,
      cacheHitRate: 0,
      averageQueryTime: 0
    };
    // Query result cache with LRU eviction
    this.queryCache = /* @__PURE__ */ new Map();
    this.maxCacheSize = 100;
    this.cacheHits = 0;
    this.cacheMisses = 0;
    // Batch operation buffer
    this.batchBuffer = [];
    this.batchMode = false;
  }
  /**
   * Enable batch mode for bulk operations
   * Defers index updates until commit
   */
  beginBatch() {
    this.batchMode = true;
    this.batchBuffer = [];
  }
  /**
   * Commit batch operations and rebuild indexes
   */
  commitBatch() {
    const startTime = performance.now();
    for (const triple of this.batchBuffer) {
      super.add(triple);
    }
    this.batchBuffer = [];
    this.batchMode = false;
    this.invalidateCache();
    this.metrics.lastIndexTime = performance.now() - startTime;
  }
  /**
   * Rollback batch operations
   */
  rollbackBatch() {
    this.batchBuffer = [];
    this.batchMode = false;
  }
  /**
   * Override add to support batch mode
   */
  add(triple) {
    if (this.batchMode) {
      this.batchBuffer.push(triple);
      return;
    }
    super.add(triple);
    this.invalidateStats();
    this.invalidateCache();
  }
  /**
   * Override remove to support batch mode
   */
  remove(triple) {
    if (this.batchMode) {
      const index = this.batchBuffer.findIndex((t) => t.equals(triple));
      if (index >= 0) {
        this.batchBuffer.splice(index, 1);
      }
      return;
    }
    super.remove(triple);
    this.invalidateStats();
    this.invalidateCache();
  }
  /**
   * Cached query with automatic result caching and performance optimization
   */
  query(subject, predicate, object) {
    const cacheKey = `${subject || "*"}|${predicate || "*"}|${object || "*"}`;
    if (this.queryCache.has(cacheKey)) {
      this.cacheHits++;
      this.updateCacheHitRate();
      const result = this.queryCache.get(cacheKey);
      this.queryCache.delete(cacheKey);
      this.queryCache.set(cacheKey, result);
      this.metrics.lastQueryTime = 0;
      return result;
    }
    const startTime = performance.now();
    const results = this.match(
      subject ? new IRI(subject) : void 0,
      predicate ? new IRI(predicate) : void 0,
      object ? this.parseObject(object) : void 0
    );
    const queryTime = performance.now() - startTime;
    this.metrics.lastQueryTime = queryTime;
    this.updateAverageQueryTime(queryTime);
    this.cacheMisses++;
    this.updateCacheHitRate();
    this.cacheResult(cacheKey, results);
    return results;
  }
  /**
   * Get graph statistics (cached)
   */
  getStatistics() {
    if (!this.stats) {
      this.stats = this.calculateStatistics();
    }
    return this.stats;
  }
  /**
   * Get performance metrics
   */
  getMetrics() {
    return { ...this.metrics };
  }
  /**
   * Helper method to compare terms safely
   */
  termEquals(term1, term2) {
    return term1.toString() === term2.toString();
  }
  /**
   * Get all triples in the graph
   */
  getAllTriples() {
    return Array.from(this.triples || []);
  }
  /**
   * Get the size of the graph
   */
  size() {
    return this.getAllTriples().length;
  }
  /**
   * Clear all triples from the graph
   */
  clear() {
    this.triples = /* @__PURE__ */ new Set();
    this.spo = /* @__PURE__ */ new Map();
    this.pos = /* @__PURE__ */ new Map();
    this.osp = /* @__PURE__ */ new Map();
    this.invalidateCache();
    this.invalidateStats();
    this.batchBuffer = [];
  }
  /**
   * Match triples by pattern using optimized index lookups
   * Achieves O(1) or O(log n) performance instead of O(n)
   */
  match(subject, predicate, object) {
    var _a, _b, _c, _d, _e;
    const results = [];
    const allTriples = this.getAllTriples();
    if (subject && predicate && object) {
      const s = subject.toString();
      const p = predicate.toString();
      const o = object.toString();
      if ((_b = (_a = this.getSPOIndex().get(s)) == null ? void 0 : _a.get(p)) == null ? void 0 : _b.has(o)) {
        for (const triple of allTriples) {
          if (this.termEquals(triple.getSubject(), subject) && this.termEquals(triple.getPredicate(), predicate) && this.termEquals(triple.getObject(), object)) {
            results.push(triple);
            break;
          }
        }
      }
    } else if (subject && predicate) {
      const s = subject.toString();
      const p = predicate.toString();
      const objects = (_c = this.getSPOIndex().get(s)) == null ? void 0 : _c.get(p);
      if (objects) {
        for (const triple of allTriples) {
          if (this.termEquals(triple.getSubject(), subject) && this.termEquals(triple.getPredicate(), predicate)) {
            results.push(triple);
          }
        }
      }
    } else if (predicate && object) {
      const p = predicate.toString();
      const o = object.toString();
      const subjects = (_d = this.getPOSIndex().get(p)) == null ? void 0 : _d.get(o);
      if (subjects) {
        for (const triple of allTriples) {
          if (this.termEquals(triple.getPredicate(), predicate) && this.termEquals(triple.getObject(), object)) {
            results.push(triple);
          }
        }
      }
    } else if (object && subject) {
      const o = object.toString();
      const s = subject.toString();
      const predicates = (_e = this.getOSPIndex().get(o)) == null ? void 0 : _e.get(s);
      if (predicates) {
        for (const triple of allTriples) {
          if (this.termEquals(triple.getSubject(), subject) && this.termEquals(triple.getObject(), object)) {
            results.push(triple);
          }
        }
      }
    } else {
      for (const triple of allTriples) {
        let matches = true;
        if (subject && !this.termEquals(triple.getSubject(), subject)) {
          matches = false;
        }
        if (predicate && !this.termEquals(triple.getPredicate(), predicate)) {
          matches = false;
        }
        if (object && !this.termEquals(triple.getObject(), object)) {
          matches = false;
        }
        if (matches) {
          results.push(triple);
        }
      }
    }
    return results;
  }
  /**
   * Optimize indexes for better query performance
   */
  optimize() {
    const startTime = performance.now();
    const allTriples = this.getAllTriples();
    this.clear();
    this.beginBatch();
    for (const triple of allTriples) {
      this.add(triple);
    }
    this.commitBatch();
    this.metrics.lastIndexTime = performance.now() - startTime;
  }
  /**
   * Parallel query execution for complex patterns
   */
  async parallelQuery(patterns) {
    const promises = patterns.map(
      (pattern) => Promise.resolve(this.query(pattern.s, pattern.p, pattern.o))
    );
    return Promise.all(promises);
  }
  /**
   * Stream large result sets
   */
  *stream(subject, predicate, object) {
    const results = this.query(subject, predicate, object);
    for (const triple of results) {
      yield triple;
    }
  }
  // Private helper methods
  parseObject(value) {
    if (value.startsWith("_:")) {
      return new BlankNode(value.substring(2));
    } else if (value.startsWith('"')) {
      return new Literal(value.slice(1, -1));
    } else {
      return new IRI(value);
    }
  }
  calculateStatistics() {
    const triples = this.getAllTriples();
    const subjects = /* @__PURE__ */ new Set();
    const predicates = /* @__PURE__ */ new Set();
    const objects = /* @__PURE__ */ new Set();
    for (const triple of triples) {
      subjects.add(triple.getSubject().toString());
      predicates.add(triple.getPredicate().toString());
      objects.add(triple.getObject().toString());
    }
    return {
      totalTriples: triples.length,
      uniqueSubjects: subjects.size,
      uniquePredicates: predicates.size,
      uniqueObjects: objects.size,
      indexSizes: {
        spo: this.getSPOIndex().size,
        pos: this.getPOSIndex().size,
        osp: this.getOSPIndex().size
      }
    };
  }
  invalidateStats() {
    this.stats = null;
  }
  invalidateCache() {
    this.queryCache.clear();
  }
  cacheResult(key, result) {
    if (this.queryCache.size >= this.maxCacheSize) {
      const entriesToRemove = Math.floor(this.maxCacheSize * 0.2);
      const keysToRemove = Array.from(this.queryCache.keys()).slice(0, entriesToRemove);
      for (const keyToRemove of keysToRemove) {
        this.queryCache.delete(keyToRemove);
      }
    }
    this.queryCache.set(key, result);
  }
  updateCacheHitRate() {
    const total = this.cacheHits + this.cacheMisses;
    this.metrics.cacheHitRate = total > 0 ? this.cacheHits / total : 0;
  }
  updateAverageQueryTime(newTime) {
    const alpha = 0.2;
    this.metrics.averageQueryTime = this.metrics.averageQueryTime * (1 - alpha) + newTime * alpha;
  }
  // Protected getters for index access
  getSPOIndex() {
    return this.spo;
  }
  getPOSIndex() {
    return this.pos;
  }
  getOSPIndex() {
    return this.osp;
  }
};

// src/domain/entities/ExoFocus.ts
var ExoFocus = class extends Entity {
  constructor(props, id) {
    super(props);
    this._focusId = id || this.generateId();
  }
  generateId() {
    return "focus-" + Date.now() + "-" + Math.random().toString(36).substring(2, 9);
  }
  get id() {
    return this._focusId;
  }
  static create(props, id) {
    if (!props.name || props.name.trim().length === 0) {
      return Result.fail("Focus name is required");
    }
    if (props.priority < 0 || props.priority > 100) {
      return Result.fail("Priority must be between 0 and 100");
    }
    return Result.ok(new ExoFocus(props, id));
  }
  get name() {
    return this.props.name;
  }
  get description() {
    return this.props.description;
  }
  get filters() {
    return this.props.filters;
  }
  get priority() {
    return this.props.priority;
  }
  get active() {
    return this.props.active;
  }
  get createdAt() {
    return this.props.createdAt;
  }
  get updatedAt() {
    return this.props.updatedAt;
  }
  addFilter(filter) {
    if (!this.isValidFilter(filter)) {
      return Result.fail("Invalid filter configuration");
    }
    this.props.filters.push(filter);
    this.props.updatedAt = new Date();
    return Result.ok();
  }
  removeFilter(index) {
    if (index < 0 || index >= this.props.filters.length) {
      return Result.fail("Invalid filter index");
    }
    this.props.filters.splice(index, 1);
    this.props.updatedAt = new Date();
    return Result.ok();
  }
  activate() {
    this.props.active = true;
    this.props.updatedAt = new Date();
  }
  deactivate() {
    this.props.active = false;
    this.props.updatedAt = new Date();
  }
  updatePriority(priority) {
    if (priority < 0 || priority > 100) {
      return Result.fail("Priority must be between 0 and 100");
    }
    this.props.priority = priority;
    this.props.updatedAt = new Date();
    return Result.ok();
  }
  matchesAsset(asset) {
    if (!this.props.active) {
      return true;
    }
    for (const filter of this.props.filters) {
      if (!this.evaluateFilter(filter, asset)) {
        return false;
      }
    }
    return true;
  }
  matchesTriple(triple) {
    if (!this.props.active) {
      return true;
    }
    for (const filter of this.props.filters) {
      if (filter.type === "property" && filter.property) {
        if (filter.property !== triple.predicate) {
          continue;
        }
        if (!this.evaluateValue(filter.operator, triple.object, filter.value)) {
          return false;
        }
      }
    }
    return true;
  }
  isValidFilter(filter) {
    const validTypes = ["class", "tag", "property", "timeframe", "relation"];
    const validOperators = ["includes", "excludes", "equals", "contains", "before", "after", "between"];
    return validTypes.includes(filter.type) && validOperators.includes(filter.operator);
  }
  evaluateFilter(filter, asset) {
    switch (filter.type) {
      case "class":
        return this.evaluateClassFilter(filter, asset);
      case "tag":
        return this.evaluateTagFilter(filter, asset);
      case "property":
        return this.evaluatePropertyFilter(filter, asset);
      case "timeframe":
        return this.evaluateTimeframeFilter(filter, asset);
      case "relation":
        return this.evaluateRelationFilter(filter, asset);
      default:
        return true;
    }
  }
  evaluateClassFilter(filter, asset) {
    const assetClass = asset["exo__Instance_class"] || asset.class;
    if (!assetClass)
      return false;
    const className = assetClass.replace(/\[\[|\]\]/g, "");
    switch (filter.operator) {
      case "equals":
        return className === filter.value;
      case "includes":
        return Array.isArray(filter.value) ? filter.value.includes(className) : className === filter.value;
      case "excludes":
        return Array.isArray(filter.value) ? !filter.value.includes(className) : className !== filter.value;
      case "contains":
        return className.toLowerCase().includes(String(filter.value).toLowerCase());
      default:
        return true;
    }
  }
  evaluateTagFilter(filter, asset) {
    const tags = asset.tags || asset["exo__Asset_tags"] || [];
    const tagArray = Array.isArray(tags) ? tags : [tags];
    switch (filter.operator) {
      case "includes":
        return tagArray.some((tag) => tag === filter.value || Array.isArray(filter.value) && filter.value.includes(tag));
      case "excludes":
        return !tagArray.some((tag) => tag === filter.value || Array.isArray(filter.value) && filter.value.includes(tag));
      case "contains":
        return tagArray.some((tag) => tag.toLowerCase().includes(String(filter.value).toLowerCase()));
      default:
        return true;
    }
  }
  evaluatePropertyFilter(filter, asset) {
    if (!filter.property)
      return true;
    const value = asset[filter.property];
    if (value === void 0)
      return filter.operator === "excludes";
    return this.evaluateValue(filter.operator, value, filter.value);
  }
  evaluateTimeframeFilter(filter, asset) {
    const dateProperties = [
      "exo__Asset_createdAt",
      "exo__Asset_updatedAt",
      "ems__Task_dueDate",
      "ems__Event_date"
    ];
    for (const prop of dateProperties) {
      const dateValue = asset[prop];
      if (dateValue) {
        const date = new Date(dateValue);
        if (!isNaN(date.getTime())) {
          return this.evaluateDateValue(filter.operator, date, filter.value);
        }
      }
    }
    return filter.operator === "excludes";
  }
  evaluateRelationFilter(filter, asset) {
    return true;
  }
  evaluateValue(operator, actualValue, filterValue) {
    switch (operator) {
      case "equals":
        return actualValue === filterValue;
      case "includes":
        if (Array.isArray(actualValue)) {
          return actualValue.includes(filterValue);
        }
        return actualValue === filterValue;
      case "excludes":
        if (Array.isArray(actualValue)) {
          return !actualValue.includes(filterValue);
        }
        return actualValue !== filterValue;
      case "contains":
        return String(actualValue).toLowerCase().includes(String(filterValue).toLowerCase());
      default:
        return true;
    }
  }
  evaluateDateValue(operator, date, filterValue) {
    switch (operator) {
      case "before":
        return date < new Date(filterValue);
      case "after":
        return date > new Date(filterValue);
      case "between":
        if (Array.isArray(filterValue) && filterValue.length === 2) {
          const start = new Date(filterValue[0]);
          const end = new Date(filterValue[1]);
          return date >= start && date <= end;
        }
        return false;
      case "equals":
        const filterDate = new Date(filterValue);
        return date.toDateString() === filterDate.toDateString();
      default:
        return true;
    }
  }
  toJSON() {
    return {
      id: this.id,
      name: this.props.name,
      description: this.props.description,
      filters: this.props.filters,
      priority: this.props.priority,
      active: this.props.active,
      createdAt: this.props.createdAt.toISOString(),
      updatedAt: this.props.updatedAt.toISOString()
    };
  }
  static fromJSON(json) {
    return ExoFocus.create({
      name: json.name,
      description: json.description,
      filters: json.filters || [],
      priority: json.priority || 50,
      active: json.active !== false,
      createdAt: new Date(json.createdAt || Date.now()),
      updatedAt: new Date(json.updatedAt || Date.now())
    }, json.id);
  }
};

// src/application/services/ExoFocusService.ts
var ExoFocusService = class {
  constructor(app, graph) {
    this.app = app;
    this.graph = graph;
    this.activeFocus = null;
    this.allFocuses = /* @__PURE__ */ new Map();
    this.focusFilePath = ".exocortex/focus.json";
    this.focusConfigPath = ".exocortex/focus-configs.json";
    var _a, _b;
    if ((_b = (_a = this.app) == null ? void 0 : _a.vault) == null ? void 0 : _b.adapter) {
      this.loadFocuses();
    }
  }
  /**
   * Load all focus configurations from vault
   */
  async loadFocuses() {
    var _a, _b;
    if (!((_b = (_a = this.app) == null ? void 0 : _a.vault) == null ? void 0 : _b.adapter)) {
      return;
    }
    try {
      const content = await this.app.vault.adapter.read(this.focusConfigPath);
      const configs = JSON.parse(content);
      for (const config of configs) {
        const focusResult = ExoFocus.fromJSON(config);
        if (focusResult.isSuccess) {
          const focus = focusResult.getValue();
          this.allFocuses.set(focus.id, focus);
          if (focus.active) {
            this.activeFocus = focus;
          }
        }
      }
    } catch (error) {
      await this.createDefaultFocuses();
    }
  }
  /**
   * Create default focus configurations
   */
  async createDefaultFocuses() {
    var _a, _b;
    if (!((_b = (_a = this.app) == null ? void 0 : _a.vault) == null ? void 0 : _b.adapter)) {
      return;
    }
    const defaults = [
      {
        name: "All",
        description: "No filtering - show all knowledge",
        filters: [],
        priority: 0,
        active: true
      },
      {
        name: "Work",
        description: "Work-related knowledge only",
        filters: [
          {
            type: "tag",
            operator: "includes",
            value: ["work", "project", "task", "meeting"]
          },
          {
            type: "class",
            operator: "includes",
            value: ["ems__Task", "ems__Project", "ems__Meeting"]
          }
        ],
        priority: 50,
        active: false
      },
      {
        name: "Personal",
        description: "Personal knowledge only",
        filters: [
          {
            type: "tag",
            operator: "includes",
            value: ["personal", "family", "health", "hobby"]
          },
          {
            type: "tag",
            operator: "excludes",
            value: ["work", "project"]
          }
        ],
        priority: 50,
        active: false
      },
      {
        name: "Today",
        description: "Focus on today's items",
        filters: [
          {
            type: "timeframe",
            operator: "equals",
            value: new Date().toISOString().split("T")[0]
          }
        ],
        priority: 75,
        active: false
      },
      {
        name: "This Week",
        description: "Focus on this week's items",
        filters: [
          {
            type: "timeframe",
            operator: "between",
            value: [
              this.getWeekStart(),
              this.getWeekEnd()
            ]
          }
        ],
        priority: 60,
        active: false
      }
    ];
    for (const config of defaults) {
      const focusResult = ExoFocus.create({
        ...config,
        createdAt: new Date(),
        updatedAt: new Date()
      });
      if (focusResult.isSuccess) {
        const focus = focusResult.getValue();
        this.allFocuses.set(focus.id, focus);
        if (focus.active) {
          this.activeFocus = focus;
        }
      }
    }
    await this.saveFocuses();
  }
  /**
   * Save all focus configurations
   */
  async saveFocuses() {
    var _a, _b;
    if (!((_b = (_a = this.app) == null ? void 0 : _a.vault) == null ? void 0 : _b.adapter)) {
      return;
    }
    const configs = Array.from(this.allFocuses.values()).map((f) => f.toJSON());
    await this.app.vault.adapter.write(
      this.focusConfigPath,
      JSON.stringify(configs, null, 2)
    );
    if (this.activeFocus) {
      await this.app.vault.adapter.write(
        this.focusFilePath,
        JSON.stringify({
          activeId: this.activeFocus.id,
          name: this.activeFocus.name,
          filters: this.activeFocus.filters,
          timestamp: new Date().toISOString()
        }, null, 2)
      );
    }
  }
  /**
   * Get active focus
   */
  getActiveFocus() {
    return this.activeFocus;
  }
  /**
   * Set active focus by ID
   */
  async setActiveFocus(focusId) {
    const focus = this.allFocuses.get(focusId);
    if (!focus) {
      return Result.fail("Focus not found");
    }
    if (this.activeFocus) {
      this.activeFocus.deactivate();
    }
    focus.activate();
    this.activeFocus = focus;
    await this.saveFocuses();
    return Result.ok();
  }
  /**
   * Create new focus
   */
  async createFocus(name, description, filters) {
    const focusResult = ExoFocus.create({
      name,
      description,
      filters,
      priority: 50,
      active: false,
      createdAt: new Date(),
      updatedAt: new Date()
    });
    if (focusResult.isFailure) {
      return focusResult;
    }
    const focus = focusResult.getValue();
    this.allFocuses.set(focus.id, focus);
    await this.saveFocuses();
    return Result.ok(focus);
  }
  /**
   * Update focus
   */
  async updateFocus(focusId, updates) {
    const focus = this.allFocuses.get(focusId);
    if (!focus) {
      return Result.fail("Focus not found");
    }
    if (updates.priority !== void 0) {
      const result = focus.updatePriority(updates.priority);
      if (result.isFailure) {
        return result;
      }
    }
    await this.saveFocuses();
    return Result.ok();
  }
  /**
   * Delete focus
   */
  async deleteFocus(focusId) {
    const focus = this.allFocuses.get(focusId);
    if (!focus) {
      return Result.fail("Focus not found");
    }
    if (focus === this.activeFocus) {
      const allFocus = Array.from(this.allFocuses.values()).find((f) => f.name === "All");
      if (allFocus) {
        this.activeFocus = allFocus;
        allFocus.activate();
      } else {
        this.activeFocus = null;
      }
    }
    this.allFocuses.delete(focusId);
    await this.saveFocuses();
    return Result.ok();
  }
  /**
   * Get all focuses
   */
  getAllFocuses() {
    return Array.from(this.allFocuses.values());
  }
  /**
   * Filter assets based on active focus
   */
  filterAssets(assets) {
    if (!this.activeFocus) {
      return assets;
    }
    return assets.filter((asset) => this.activeFocus.matchesAsset(asset));
  }
  /**
   * Filter triples based on active focus
   */
  filterTriples(triples) {
    if (!this.activeFocus) {
      return triples;
    }
    return triples.filter((triple) => {
      const tripleObj = {
        subject: triple.getSubject().toString(),
        predicate: triple.getPredicate().toString(),
        object: triple.getObject().toString()
      };
      return this.activeFocus.matchesTriple(tripleObj);
    });
  }
  /**
   * Filter files based on active focus
   */
  async filterFiles(files) {
    if (!this.activeFocus) {
      return files;
    }
    const filteredFiles = [];
    for (const file of files) {
      const cache = this.app.metadataCache.getFileCache(file);
      if (cache == null ? void 0 : cache.frontmatter) {
        if (this.activeFocus.matchesAsset(cache.frontmatter)) {
          filteredFiles.push(file);
        }
      }
    }
    return filteredFiles;
  }
  /**
   * Apply focus to SPARQL query results
   */
  filterSPARQLResults(results) {
    if (!this.activeFocus) {
      return results;
    }
    return results.filter((result) => {
      if (result.subject && result.predicate && result.object) {
        return this.activeFocus.matchesTriple(result);
      }
      return this.activeFocus.matchesAsset(result);
    });
  }
  /**
   * Get focus statistics
   */
  async getFocusStatistics() {
    var _a;
    const files = this.app.vault.getMarkdownFiles();
    const allAssets = files.length;
    const filteredFiles = await this.filterFiles(files);
    const filteredAssets = filteredFiles.length;
    const allTriples = this.graph.match(null, null, null);
    const totalTriples = allTriples.length;
    const filteredTriples = this.filterTriples(allTriples);
    const filteredTriplesCount = filteredTriples.length;
    return {
      totalAssets: allAssets,
      filteredAssets,
      totalTriples,
      filteredTriples: filteredTriplesCount,
      activeFocus: ((_a = this.activeFocus) == null ? void 0 : _a.name) || "None"
    };
  }
  /**
   * Helper: Get start of current week
   */
  getWeekStart() {
    const now = new Date();
    const dayOfWeek = now.getDay();
    const diff = now.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1);
    const weekStart = new Date(now.setDate(diff));
    weekStart.setHours(0, 0, 0, 0);
    return weekStart.toISOString();
  }
  /**
   * Helper: Get end of current week
   */
  getWeekEnd() {
    const now = new Date();
    const dayOfWeek = now.getDay();
    const diff = now.getDate() - dayOfWeek + 7;
    const weekEnd = new Date(now.setDate(diff));
    weekEnd.setHours(23, 59, 59, 999);
    return weekEnd.toISOString();
  }
};

// manifest.json
var manifest_default = {
  id: "exocortex",
  name: "Exocortex",
  version: "2.16.0",
  minAppVersion: "1.0.0",
  description: "SPARQL queries in Obsidian - Semantic knowledge management",
  author: "A. Kitelev",
  authorUrl: "https://github.com/kitelev",
  isDesktopOnly: false,
  main: "main.js"
};

// src/main.ts
var ExocortexPlugin = class extends import_obsidian20.Plugin {
  async onload() {
    console.log(`\u{1F680} Exocortex: Loading plugin v${manifest_default.version}...`);
    DIContainer.initialize(this.app, this);
    this.container = DIContainer.getInstance();
    this.graph = new Graph();
    this.rdfService = new RDFService(this.app);
    await this.loadVaultIntoGraph();
    const cacheConfig = {
      maxSize: 500,
      // Reasonable cache size for Obsidian plugin
      defaultTTL: 5 * 60 * 1e3,
      // 5 minutes TTL
      enabled: true
    };
    this.sparqlProcessor = new SPARQLProcessor(this, this.graph, void 0, cacheConfig);
    this.graphVisualizationProcessor = new GraphVisualizationProcessor(this, this.graph);
    try {
      this.registerMarkdownCodeBlockProcessor(
        "sparql",
        (source, el, ctx) => this.sparqlProcessor.processCodeBlock(source, el, ctx)
      );
    } catch (error) {
      console.warn("SPARQL processor registration failed (may already be registered):", error.message);
    }
    try {
      this.registerMarkdownCodeBlockProcessor(
        "graph",
        (source, el, ctx) => this.graphVisualizationProcessor.processCodeBlock(source, el, ctx)
      );
    } catch (error) {
      console.warn("Graph processor registration failed (may already be registered):", error.message);
    }
    this.addCommand({
      id: "create-exo-asset",
      name: "Create new ExoAsset",
      hotkeys: [{ modifiers: ["Mod", "Shift"], key: "n" }],
      callback: () => {
        new CreateAssetModal(this.app).open();
      }
    });
    this.addRibbonIcon("plus-circle", "Create ExoAsset", () => {
      new CreateAssetModal(this.app).open();
    });
    this.addCommand({
      id: "view-sparql-cache-stats",
      name: "View SPARQL cache statistics",
      callback: () => {
        const stats = this.sparqlProcessor.getCacheStatistics();
        const message = [
          `SPARQL Query Cache Statistics:`,
          `\u2022 Cache hits: ${stats.hits}`,
          `\u2022 Cache misses: ${stats.misses}`,
          `\u2022 Hit rate: ${stats.hitRate.toFixed(1)}%`,
          `\u2022 Cached entries: ${stats.size}/${stats.maxSize}`,
          `\u2022 Total queries: ${stats.totalQueries}`,
          `\u2022 Evictions: ${stats.evictions}`
        ].join("\n");
        new import_obsidian20.Notice(message, 8e3);
      }
    });
    this.addCommand({
      id: "clear-sparql-cache",
      name: "Clear SPARQL cache",
      callback: () => {
        this.sparqlProcessor.invalidateCache();
        new import_obsidian20.Notice("SPARQL query cache cleared!");
      }
    });
    this.addCommand({
      id: "export-knowledge-graph",
      name: "Export knowledge graph",
      callback: () => {
        const modal = new ExportRDFModal(
          this.app,
          this.graph,
          this.rdfService.getNamespaceManager(),
          (result) => {
            console.log("Knowledge graph exported:", result);
          }
        );
        modal.open();
      }
    });
    this.addCommand({
      id: "import-rdf-data",
      name: "Import RDF data",
      callback: () => {
        const modal = new ImportRDFModal(
          this.app,
          this.graph,
          this.rdfService.getNamespaceManager(),
          async (importedGraph, options) => {
            try {
              if (options.mergeMode === "replace") {
                this.graph.clear();
                this.graph.merge(importedGraph);
              } else {
                this.graph.merge(importedGraph);
              }
              this.sparqlProcessor.invalidateCache();
              console.log("RDF data imported successfully");
            } catch (error) {
              console.error("Failed to import RDF data:", error);
              new import_obsidian20.Notice(`Import failed: ${error.message}`);
            }
          }
        );
        modal.open();
      }
    });
    this.addCommand({
      id: "quick-create-task",
      name: "Quick create task for current project",
      hotkeys: [{ modifiers: ["Mod", "Shift"], key: "t" }],
      callback: async () => {
        try {
          const activeFile = this.app.workspace.getActiveFile();
          const activeFilePath = activeFile == null ? void 0 : activeFile.path;
          const taskRepository = new ObsidianTaskRepository(this.app);
          const assetRepository = new ObsidianAssetRepository(this.app);
          const indexedGraph = new IndexedGraph();
          const focusService = new ExoFocusService(this.app, this.graph);
          const getCurrentProjectUseCase = new GetCurrentProjectUseCase(
            assetRepository,
            focusService,
            indexedGraph
          );
          const createTaskUseCase = new CreateTaskFromProjectUseCase(
            taskRepository,
            assetRepository,
            indexedGraph,
            getCurrentProjectUseCase
          );
          const modal = new QuickTaskModal(
            this.app,
            createTaskUseCase,
            getCurrentProjectUseCase,
            activeFilePath
          );
          modal.open();
        } catch (error) {
          console.error("Failed to open quick task modal:", error);
          new import_obsidian20.Notice(`Failed to open task creation: ${error.message}`);
        }
      }
    });
    this.registerEvent(
      this.app.vault.on("modify", async (file) => {
        if (file instanceof import_obsidian20.TFile && file.extension === "md") {
          await this.updateFileInGraph(file);
          this.sparqlProcessor.invalidateCache();
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("create", async (file) => {
        if (file instanceof import_obsidian20.TFile && file.extension === "md") {
          await this.updateFileInGraph(file);
          this.sparqlProcessor.invalidateCache();
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("delete", async (file) => {
        if (file instanceof import_obsidian20.TFile && file.extension === "md") {
          this.removeFileFromGraph(file);
          this.sparqlProcessor.invalidateCache();
        }
      })
    );
    new import_obsidian20.Notice("\u{1F50D} Exocortex: SPARQL support and graph visualization enabled!");
    console.log("\u2705 Exocortex: SPARQL processor and graph visualization registered");
  }
  async loadVaultIntoGraph() {
    console.log("\u{1F4CA} Loading vault into RDF graph...");
    const startTime = Date.now();
    const files = this.app.vault.getMarkdownFiles();
    let triplesCount = 0;
    for (const file of files) {
      try {
        const content = await this.app.vault.read(file);
        const triples = this.extractTriplesFromFile(file, content);
        for (const triple of triples) {
          this.graph.add(triple);
          triplesCount++;
        }
      } catch (err) {
        console.warn(`Failed to process ${file.path}:`, err);
      }
    }
    const loadTime = Date.now() - startTime;
    console.log(`\u2705 Loaded ${triplesCount} triples from ${files.length} files in ${loadTime}ms`);
  }
  async updateFileInGraph(file) {
    try {
      this.removeFileFromGraph(file);
      const content = await this.app.vault.read(file);
      const triples = this.extractTriplesFromFile(file, content);
      for (const triple of triples) {
        this.graph.add(triple);
      }
    } catch (err) {
      console.warn(`Failed to update ${file.path} in graph:`, err);
    }
  }
  removeFileFromGraph(file) {
    const subject = new IRI(`file://${file.basename}`);
    const triplesToRemove = this.graph.match(subject, null, null);
    for (const triple of triplesToRemove) {
      this.graph.remove(triple);
    }
  }
  extractTriplesFromFile(file, content) {
    const triples = [];
    const subject = new IRI(`file://${file.basename}`);
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (frontmatterMatch) {
      const frontmatter = this.parseFrontmatter(frontmatterMatch[1]);
      for (const [key, value] of Object.entries(frontmatter)) {
        if (Array.isArray(value)) {
          for (const v of value) {
            triples.push(new Triple(
              subject,
              new IRI(key),
              Literal.string(String(v))
            ));
          }
        } else if (value !== null && value !== void 0) {
          triples.push(new Triple(
            subject,
            new IRI(key),
            Literal.string(String(value))
          ));
        }
      }
    }
    triples.push(new Triple(
      subject,
      new IRI("file_path"),
      Literal.string(file.path)
    ));
    triples.push(new Triple(
      subject,
      new IRI("file_name"),
      Literal.string(file.name)
    ));
    return triples;
  }
  parseFrontmatter(yaml) {
    const result = {};
    const lines = yaml.split("\n");
    let currentKey = null;
    let currentValue = null;
    let inArray = false;
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed)
        continue;
      if (line.startsWith("  - ") || line.startsWith("    - ")) {
        if (currentKey && inArray) {
          const value = line.substring(line.indexOf("- ") + 2).trim();
          const cleanValue = value.replace(/^["']|["']$/g, "").replace(/\[\[|\]\]/g, "");
          if (!Array.isArray(currentValue)) {
            currentValue = [];
          }
          currentValue.push(cleanValue);
        }
        continue;
      }
      if (trimmed.includes(":")) {
        if (currentKey !== null && currentValue !== null) {
          result[currentKey] = currentValue;
        }
        const colonIndex = trimmed.indexOf(":");
        currentKey = trimmed.substring(0, colonIndex).trim();
        const valueStr = trimmed.substring(colonIndex + 1).trim();
        if (!valueStr) {
          inArray = true;
          currentValue = [];
        } else {
          inArray = false;
          currentValue = valueStr.replace(/^["']|["']$/g, "").replace(/\[\[|\]\]/g, "");
        }
      }
    }
    if (currentKey !== null && currentValue !== null) {
      result[currentKey] = currentValue;
    }
    return result;
  }
  async onunload() {
    console.log("\u{1F44B} Exocortex: Plugin unloaded");
    if (this.graph) {
      this.graph.clear();
    }
    if (this.sparqlProcessor) {
      this.sparqlProcessor.destroy();
    }
  }
};
