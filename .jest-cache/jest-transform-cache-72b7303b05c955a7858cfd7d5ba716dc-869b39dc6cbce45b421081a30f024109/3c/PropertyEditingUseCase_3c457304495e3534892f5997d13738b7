b42afda9a5e7b7efcb83acc9bc15aff1
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PropertyEditingUseCase = void 0;
const tslib_1 = require("tslib");
const Result_1 = require("../../domain/core/Result");
const AssetId_1 = require("../../domain/value-objects/AssetId");
class PropertyEditingUseCase {
    constructor(assetRepository, plugin // Reference to main plugin for property discovery
    ) {
        this.assetRepository = assetRepository;
        this.plugin = plugin;
    }
    execute(request) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Validate request
            if (!request.assetId) {
                return Result_1.Result.fail('Asset ID is required');
            }
            if (!request.propertyName) {
                return Result_1.Result.fail('Property name is required');
            }
            // Validate property value
            const validationResult = this.validatePropertyValue(request.value, request.propertyDefinition);
            if (validationResult.isFailure) {
                return Result_1.Result.fail(validationResult.error);
            }
            try {
                // If assetId looks like a file path, use direct update method
                if (request.assetId.includes('/') || request.assetId.endsWith('.md')) {
                    // Use the new direct update method
                    const repo = this.assetRepository;
                    if (repo.updateFrontmatterByPath) {
                        console.log(`Updating property ${request.propertyName} to ${request.value} for file ${request.assetId}`);
                        yield repo.updateFrontmatterByPath(request.assetId, {
                            [request.propertyName]: request.value
                        });
                        return Result_1.Result.ok({
                            success: true,
                            updatedValue: request.value
                        });
                    }
                }
                // Fallback to original logic for asset IDs
                let asset = null;
                // First try as UUID
                const assetIdResult = AssetId_1.AssetId.create(request.assetId);
                if (assetIdResult.isSuccess) {
                    asset = yield this.assetRepository.findById(assetIdResult.getValue());
                }
                // If not found by ID, try by filename
                if (!asset) {
                    asset = yield this.assetRepository.findByFilename(request.assetId);
                }
                if (!asset) {
                    return Result_1.Result.fail(`Asset not found: ${request.assetId}`);
                }
                // Update the property
                asset.setProperty(request.propertyName, request.value);
                // Save the asset
                yield this.assetRepository.save(asset);
                return Result_1.Result.ok({
                    success: true,
                    updatedValue: request.value
                });
            }
            catch (error) {
                return Result_1.Result.fail(`Failed to update property: ${error}`);
            }
        });
    }
    /**
     * Validate property value based on its definition
     */
    validatePropertyValue(value, definition) {
        var _a;
        // Check required
        if (definition.isRequired && (value === null || value === undefined || value === '')) {
            return Result_1.Result.fail(`${definition.label} is required`);
        }
        // Skip further validation if value is empty and not required
        if (!definition.isRequired && (value === null || value === undefined || value === '')) {
            return Result_1.Result.ok();
        }
        // Validate based on range/type
        if (definition.range === 'number') {
            if (isNaN(Number(value))) {
                return Result_1.Result.fail(`${definition.label} must be a number`);
            }
        }
        if (definition.range === 'date') {
            if (isNaN(Date.parse(value))) {
                return Result_1.Result.fail(`${definition.label} must be a valid date`);
            }
        }
        if (definition.range === 'boolean') {
            if (typeof value !== 'boolean') {
                return Result_1.Result.fail(`${definition.label} must be true or false`);
            }
        }
        if ((_a = definition.range) === null || _a === void 0 ? void 0 : _a.startsWith('enum:')) {
            const allowedValues = definition.range.substring(5).split(',').map(v => v.trim());
            if (!allowedValues.includes(value)) {
                return Result_1.Result.fail(`${definition.label} must be one of: ${allowedValues.join(', ')}`);
            }
        }
        // Custom validation regex
        if (definition.validation) {
            try {
                const regex = new RegExp(definition.validation);
                if (!regex.test(String(value))) {
                    return Result_1.Result.fail(`${definition.label} format is invalid`);
                }
            }
            catch (e) {
                // Invalid regex, skip validation
            }
        }
        return Result_1.Result.ok();
    }
    /**
     * Get properties for a class (delegating to plugin for now)
     */
    getPropertiesForClass(className) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const properties = yield this.plugin.findPropertiesForClass(className);
                return Result_1.Result.ok(properties);
            }
            catch (error) {
                return Result_1.Result.fail(`Failed to get properties: ${error.message}`);
            }
        });
    }
    /**
     * Get assets for a class (for dropdowns)
     */
    getAssetsForClass(className) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const assets = yield this.plugin.findAssetsByClass(className, true);
                return Result_1.Result.ok(assets);
            }
            catch (error) {
                return Result_1.Result.fail(`Failed to get assets: ${error.message}`);
            }
        });
    }
}
exports.PropertyEditingUseCase = PropertyEditingUseCase;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2tpdGVsZXYvRG9jdW1lbnRzL2V4b2NvcnRleC1vYnNpZGlhbi1wbHVnaW4vc3JjL2FwcGxpY2F0aW9uL3VzZS1jYXNlcy9Qcm9wZXJ0eUVkaXRpbmdVc2VDYXNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFDQSxxREFBa0Q7QUFFbEQsZ0VBQTZEO0FBeUI3RCxNQUFhLHNCQUFzQjtJQUMvQixZQUNZLGVBQWlDLEVBQ2pDLE1BQVcsQ0FBQyxrREFBa0Q7O1FBRDlELG9CQUFlLEdBQWYsZUFBZSxDQUFrQjtRQUNqQyxXQUFNLEdBQU4sTUFBTSxDQUFLO0lBQ3BCLENBQUM7SUFFRSxPQUFPLENBQUMsT0FBOEI7O1lBQ3hDLG1CQUFtQjtZQUNuQixJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRTtnQkFDbEIsT0FBTyxlQUFNLENBQUMsSUFBSSxDQUF5QixzQkFBc0IsQ0FBQyxDQUFDO2FBQ3RFO1lBRUQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUU7Z0JBQ3ZCLE9BQU8sZUFBTSxDQUFDLElBQUksQ0FBeUIsMkJBQTJCLENBQUMsQ0FBQzthQUMzRTtZQUVELDBCQUEwQjtZQUMxQixNQUFNLGdCQUFnQixHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FDL0MsT0FBTyxDQUFDLEtBQUssRUFDYixPQUFPLENBQUMsa0JBQWtCLENBQzdCLENBQUM7WUFFRixJQUFJLGdCQUFnQixDQUFDLFNBQVMsRUFBRTtnQkFDNUIsT0FBTyxlQUFNLENBQUMsSUFBSSxDQUF5QixnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUN0RTtZQUVELElBQUk7Z0JBQ0EsOERBQThEO2dCQUM5RCxJQUFJLE9BQU8sQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFO29CQUNsRSxtQ0FBbUM7b0JBQ25DLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxlQUFzQixDQUFDO29CQUN6QyxJQUFJLElBQUksQ0FBQyx1QkFBdUIsRUFBRTt3QkFDOUIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxxQkFBcUIsT0FBTyxDQUFDLFlBQVksT0FBTyxPQUFPLENBQUMsS0FBSyxhQUFhLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO3dCQUN6RyxNQUFNLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFOzRCQUNoRCxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsRUFBRSxPQUFPLENBQUMsS0FBSzt5QkFDeEMsQ0FBQyxDQUFDO3dCQUVILE9BQU8sZUFBTSxDQUFDLEVBQUUsQ0FBeUI7NEJBQ3JDLE9BQU8sRUFBRSxJQUFJOzRCQUNiLFlBQVksRUFBRSxPQUFPLENBQUMsS0FBSzt5QkFDOUIsQ0FBQyxDQUFDO3FCQUNOO2lCQUNKO2dCQUVELDJDQUEyQztnQkFDM0MsSUFBSSxLQUFLLEdBQWlCLElBQUksQ0FBQztnQkFFL0Isb0JBQW9CO2dCQUNwQixNQUFNLGFBQWEsR0FBRyxpQkFBTyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQ3RELElBQUksYUFBYSxDQUFDLFNBQVMsRUFBRTtvQkFDekIsS0FBSyxHQUFHLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7aUJBQ3pFO2dCQUVELHNDQUFzQztnQkFDdEMsSUFBSSxDQUFDLEtBQUssRUFBRTtvQkFDUixLQUFLLEdBQUcsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7aUJBQ3RFO2dCQUVELElBQUksQ0FBQyxLQUFLLEVBQUU7b0JBQ1IsT0FBTyxlQUFNLENBQUMsSUFBSSxDQUF5QixvQkFBb0IsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7aUJBQ3JGO2dCQUVELHNCQUFzQjtnQkFDdEIsS0FBSyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsWUFBWSxFQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFFdkQsaUJBQWlCO2dCQUNqQixNQUFNLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUV2QyxPQUFPLGVBQU0sQ0FBQyxFQUFFLENBQXlCO29CQUNyQyxPQUFPLEVBQUUsSUFBSTtvQkFDYixZQUFZLEVBQUUsT0FBTyxDQUFDLEtBQUs7aUJBQzlCLENBQUMsQ0FBQzthQUNOO1lBQUMsT0FBTyxLQUFLLEVBQUU7Z0JBQ1osT0FBTyxlQUFNLENBQUMsSUFBSSxDQUF5Qiw4QkFBOEIsS0FBSyxFQUFFLENBQUMsQ0FBQzthQUNyRjtRQUNMLENBQUM7S0FBQTtJQUVEOztPQUVHO0lBQ0sscUJBQXFCLENBQ3pCLEtBQVUsRUFDVixVQUF1RDs7UUFFdkQsaUJBQWlCO1FBQ2pCLElBQUksVUFBVSxDQUFDLFVBQVUsSUFBSSxDQUFDLEtBQUssS0FBSyxJQUFJLElBQUksS0FBSyxLQUFLLFNBQVMsSUFBSSxLQUFLLEtBQUssRUFBRSxDQUFDLEVBQUU7WUFDbEYsT0FBTyxlQUFNLENBQUMsSUFBSSxDQUFPLEdBQUcsVUFBVSxDQUFDLEtBQUssY0FBYyxDQUFDLENBQUM7U0FDL0Q7UUFFRCw2REFBNkQ7UUFDN0QsSUFBSSxDQUFDLFVBQVUsQ0FBQyxVQUFVLElBQUksQ0FBQyxLQUFLLEtBQUssSUFBSSxJQUFJLEtBQUssS0FBSyxTQUFTLElBQUksS0FBSyxLQUFLLEVBQUUsQ0FBQyxFQUFFO1lBQ25GLE9BQU8sZUFBTSxDQUFDLEVBQUUsRUFBUSxDQUFDO1NBQzVCO1FBRUQsK0JBQStCO1FBQy9CLElBQUksVUFBVSxDQUFDLEtBQUssS0FBSyxRQUFRLEVBQUU7WUFDL0IsSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7Z0JBQ3RCLE9BQU8sZUFBTSxDQUFDLElBQUksQ0FBTyxHQUFHLFVBQVUsQ0FBQyxLQUFLLG1CQUFtQixDQUFDLENBQUM7YUFDcEU7U0FDSjtRQUVELElBQUksVUFBVSxDQUFDLEtBQUssS0FBSyxNQUFNLEVBQUU7WUFDN0IsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO2dCQUMxQixPQUFPLGVBQU0sQ0FBQyxJQUFJLENBQU8sR0FBRyxVQUFVLENBQUMsS0FBSyx1QkFBdUIsQ0FBQyxDQUFDO2FBQ3hFO1NBQ0o7UUFFRCxJQUFJLFVBQVUsQ0FBQyxLQUFLLEtBQUssU0FBUyxFQUFFO1lBQ2hDLElBQUksT0FBTyxLQUFLLEtBQUssU0FBUyxFQUFFO2dCQUM1QixPQUFPLGVBQU0sQ0FBQyxJQUFJLENBQU8sR0FBRyxVQUFVLENBQUMsS0FBSyx3QkFBd0IsQ0FBQyxDQUFDO2FBQ3pFO1NBQ0o7UUFFRCxJQUFJLE1BQUEsVUFBVSxDQUFDLEtBQUssMENBQUUsVUFBVSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ3ZDLE1BQU0sYUFBYSxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztZQUNsRixJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRTtnQkFDaEMsT0FBTyxlQUFNLENBQUMsSUFBSSxDQUFPLEdBQUcsVUFBVSxDQUFDLEtBQUssb0JBQW9CLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2FBQy9GO1NBQ0o7UUFFRCwwQkFBMEI7UUFDMUIsSUFBSSxVQUFVLENBQUMsVUFBVSxFQUFFO1lBQ3ZCLElBQUk7Z0JBQ0EsTUFBTSxLQUFLLEdBQUcsSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2dCQUNoRCxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtvQkFDNUIsT0FBTyxlQUFNLENBQUMsSUFBSSxDQUFPLEdBQUcsVUFBVSxDQUFDLEtBQUssb0JBQW9CLENBQUMsQ0FBQztpQkFDckU7YUFDSjtZQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUNSLGlDQUFpQzthQUNwQztTQUNKO1FBRUQsT0FBTyxlQUFNLENBQUMsRUFBRSxFQUFRLENBQUM7SUFDN0IsQ0FBQztJQUVEOztPQUVHO0lBQ0cscUJBQXFCLENBQUMsU0FBaUI7O1lBQ3pDLElBQUk7Z0JBQ0EsTUFBTSxVQUFVLEdBQUcsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLHNCQUFzQixDQUFDLFNBQVMsQ0FBQyxDQUFDO2dCQUN2RSxPQUFPLGVBQU0sQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLENBQUM7YUFDaEM7WUFBQyxPQUFPLEtBQUssRUFBRTtnQkFDWixPQUFPLGVBQU0sQ0FBQyxJQUFJLENBQUMsNkJBQTZCLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO2FBQ3BFO1FBQ0wsQ0FBQztLQUFBO0lBRUQ7O09BRUc7SUFDRyxpQkFBaUIsQ0FBQyxTQUFpQjs7WUFDckMsSUFBSTtnQkFDQSxNQUFNLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsaUJBQWlCLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDO2dCQUNwRSxPQUFPLGVBQU0sQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDNUI7WUFBQyxPQUFPLEtBQUssRUFBRTtnQkFDWixPQUFPLGVBQU0sQ0FBQyxJQUFJLENBQUMseUJBQXlCLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO2FBQ2hFO1FBQ0wsQ0FBQztLQUFBO0NBQ0o7QUE5SkQsd0RBOEpDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9raXRlbGV2L0RvY3VtZW50cy9leG9jb3J0ZXgtb2JzaWRpYW4tcGx1Z2luL3NyYy9hcHBsaWNhdGlvbi91c2UtY2FzZXMvUHJvcGVydHlFZGl0aW5nVXNlQ2FzZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBVc2VDYXNlIH0gZnJvbSAnLi4vY29yZS9Vc2VDYXNlJztcbmltcG9ydCB7IFJlc3VsdCB9IGZyb20gJy4uLy4uL2RvbWFpbi9jb3JlL1Jlc3VsdCc7XG5pbXBvcnQgeyBJQXNzZXRSZXBvc2l0b3J5IH0gZnJvbSAnLi4vLi4vZG9tYWluL3JlcG9zaXRvcmllcy9JQXNzZXRSZXBvc2l0b3J5JztcbmltcG9ydCB7IEFzc2V0SWQgfSBmcm9tICcuLi8uLi9kb21haW4vdmFsdWUtb2JqZWN0cy9Bc3NldElkJztcbmltcG9ydCB7IEFzc2V0IH0gZnJvbSAnLi4vLi4vZG9tYWluL2VudGl0aWVzL0Fzc2V0JztcblxuLyoqXG4gKiBVc2UgY2FzZSBmb3IgZWRpdGluZyBhc3NldCBwcm9wZXJ0aWVzIGlubGluZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFVwZGF0ZVByb3BlcnR5UmVxdWVzdCB7XG4gICAgYXNzZXRJZDogc3RyaW5nO1xuICAgIHByb3BlcnR5TmFtZTogc3RyaW5nO1xuICAgIHZhbHVlOiBhbnk7XG4gICAgcHJvcGVydHlEZWZpbml0aW9uOiB7XG4gICAgICAgIHByb3BlcnR5TmFtZTogc3RyaW5nO1xuICAgICAgICBsYWJlbDogc3RyaW5nO1xuICAgICAgICByYW5nZTogc3RyaW5nO1xuICAgICAgICBpc1JlcXVpcmVkOiBib29sZWFuO1xuICAgICAgICBpc09iamVjdFByb3BlcnR5PzogYm9vbGVhbjtcbiAgICAgICAgdmFsaWRhdGlvbj86IHN0cmluZztcbiAgICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVwZGF0ZVByb3BlcnR5UmVzcG9uc2Uge1xuICAgIHN1Y2Nlc3M6IGJvb2xlYW47XG4gICAgdXBkYXRlZFZhbHVlOiBhbnk7XG59XG5cbmV4cG9ydCBjbGFzcyBQcm9wZXJ0eUVkaXRpbmdVc2VDYXNlIGltcGxlbWVudHMgVXNlQ2FzZTxVcGRhdGVQcm9wZXJ0eVJlcXVlc3QsIFVwZGF0ZVByb3BlcnR5UmVzcG9uc2U+IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBhc3NldFJlcG9zaXRvcnk6IElBc3NldFJlcG9zaXRvcnksXG4gICAgICAgIHByaXZhdGUgcGx1Z2luOiBhbnkgLy8gUmVmZXJlbmNlIHRvIG1haW4gcGx1Z2luIGZvciBwcm9wZXJ0eSBkaXNjb3ZlcnlcbiAgICApIHt9XG5cbiAgICBhc3luYyBleGVjdXRlKHJlcXVlc3Q6IFVwZGF0ZVByb3BlcnR5UmVxdWVzdCk6IFByb21pc2U8UmVzdWx0PFVwZGF0ZVByb3BlcnR5UmVzcG9uc2U+PiB7XG4gICAgICAgIC8vIFZhbGlkYXRlIHJlcXVlc3RcbiAgICAgICAgaWYgKCFyZXF1ZXN0LmFzc2V0SWQpIHtcbiAgICAgICAgICAgIHJldHVybiBSZXN1bHQuZmFpbDxVcGRhdGVQcm9wZXJ0eVJlc3BvbnNlPignQXNzZXQgSUQgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVxdWVzdC5wcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBSZXN1bHQuZmFpbDxVcGRhdGVQcm9wZXJ0eVJlc3BvbnNlPignUHJvcGVydHkgbmFtZSBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgcHJvcGVydHkgdmFsdWVcbiAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IHRoaXMudmFsaWRhdGVQcm9wZXJ0eVZhbHVlKFxuICAgICAgICAgICAgcmVxdWVzdC52YWx1ZSxcbiAgICAgICAgICAgIHJlcXVlc3QucHJvcGVydHlEZWZpbml0aW9uXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHZhbGlkYXRpb25SZXN1bHQuaXNGYWlsdXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVzdWx0LmZhaWw8VXBkYXRlUHJvcGVydHlSZXNwb25zZT4odmFsaWRhdGlvblJlc3VsdC5lcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gSWYgYXNzZXRJZCBsb29rcyBsaWtlIGEgZmlsZSBwYXRoLCB1c2UgZGlyZWN0IHVwZGF0ZSBtZXRob2RcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LmFzc2V0SWQuaW5jbHVkZXMoJy8nKSB8fCByZXF1ZXN0LmFzc2V0SWQuZW5kc1dpdGgoJy5tZCcpKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBuZXcgZGlyZWN0IHVwZGF0ZSBtZXRob2RcbiAgICAgICAgICAgICAgICBjb25zdCByZXBvID0gdGhpcy5hc3NldFJlcG9zaXRvcnkgYXMgYW55O1xuICAgICAgICAgICAgICAgIGlmIChyZXBvLnVwZGF0ZUZyb250bWF0dGVyQnlQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBVcGRhdGluZyBwcm9wZXJ0eSAke3JlcXVlc3QucHJvcGVydHlOYW1lfSB0byAke3JlcXVlc3QudmFsdWV9IGZvciBmaWxlICR7cmVxdWVzdC5hc3NldElkfWApO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCByZXBvLnVwZGF0ZUZyb250bWF0dGVyQnlQYXRoKHJlcXVlc3QuYXNzZXRJZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgW3JlcXVlc3QucHJvcGVydHlOYW1lXTogcmVxdWVzdC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZXN1bHQub2s8VXBkYXRlUHJvcGVydHlSZXNwb25zZT4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRWYWx1ZTogcmVxdWVzdC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIG9yaWdpbmFsIGxvZ2ljIGZvciBhc3NldCBJRHNcbiAgICAgICAgICAgIGxldCBhc3NldDogQXNzZXQgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRmlyc3QgdHJ5IGFzIFVVSURcbiAgICAgICAgICAgIGNvbnN0IGFzc2V0SWRSZXN1bHQgPSBBc3NldElkLmNyZWF0ZShyZXF1ZXN0LmFzc2V0SWQpO1xuICAgICAgICAgICAgaWYgKGFzc2V0SWRSZXN1bHQuaXNTdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgYXNzZXQgPSBhd2FpdCB0aGlzLmFzc2V0UmVwb3NpdG9yeS5maW5kQnlJZChhc3NldElkUmVzdWx0LmdldFZhbHVlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBJZiBub3QgZm91bmQgYnkgSUQsIHRyeSBieSBmaWxlbmFtZVxuICAgICAgICAgICAgaWYgKCFhc3NldCkge1xuICAgICAgICAgICAgICAgIGFzc2V0ID0gYXdhaXQgdGhpcy5hc3NldFJlcG9zaXRvcnkuZmluZEJ5RmlsZW5hbWUocmVxdWVzdC5hc3NldElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCFhc3NldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBSZXN1bHQuZmFpbDxVcGRhdGVQcm9wZXJ0eVJlc3BvbnNlPihgQXNzZXQgbm90IGZvdW5kOiAke3JlcXVlc3QuYXNzZXRJZH1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBwcm9wZXJ0eVxuICAgICAgICAgICAgYXNzZXQuc2V0UHJvcGVydHkocmVxdWVzdC5wcm9wZXJ0eU5hbWUsIHJlcXVlc3QudmFsdWUpO1xuXG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBhc3NldFxuICAgICAgICAgICAgYXdhaXQgdGhpcy5hc3NldFJlcG9zaXRvcnkuc2F2ZShhc3NldCk7XG5cbiAgICAgICAgICAgIHJldHVybiBSZXN1bHQub2s8VXBkYXRlUHJvcGVydHlSZXNwb25zZT4oe1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgdXBkYXRlZFZhbHVlOiByZXF1ZXN0LnZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBSZXN1bHQuZmFpbDxVcGRhdGVQcm9wZXJ0eVJlc3BvbnNlPihgRmFpbGVkIHRvIHVwZGF0ZSBwcm9wZXJ0eTogJHtlcnJvcn1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIHByb3BlcnR5IHZhbHVlIGJhc2VkIG9uIGl0cyBkZWZpbml0aW9uXG4gICAgICovXG4gICAgcHJpdmF0ZSB2YWxpZGF0ZVByb3BlcnR5VmFsdWUoXG4gICAgICAgIHZhbHVlOiBhbnksXG4gICAgICAgIGRlZmluaXRpb246IFVwZGF0ZVByb3BlcnR5UmVxdWVzdFsncHJvcGVydHlEZWZpbml0aW9uJ11cbiAgICApOiBSZXN1bHQ8dm9pZD4ge1xuICAgICAgICAvLyBDaGVjayByZXF1aXJlZFxuICAgICAgICBpZiAoZGVmaW5pdGlvbi5pc1JlcXVpcmVkICYmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSAnJykpIHtcbiAgICAgICAgICAgIHJldHVybiBSZXN1bHQuZmFpbDx2b2lkPihgJHtkZWZpbml0aW9uLmxhYmVsfSBpcyByZXF1aXJlZGApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2tpcCBmdXJ0aGVyIHZhbGlkYXRpb24gaWYgdmFsdWUgaXMgZW1wdHkgYW5kIG5vdCByZXF1aXJlZFxuICAgICAgICBpZiAoIWRlZmluaXRpb24uaXNSZXF1aXJlZCAmJiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gJycpKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVzdWx0Lm9rPHZvaWQ+KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWxpZGF0ZSBiYXNlZCBvbiByYW5nZS90eXBlXG4gICAgICAgIGlmIChkZWZpbml0aW9uLnJhbmdlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaWYgKGlzTmFOKE51bWJlcih2YWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlc3VsdC5mYWlsPHZvaWQ+KGAke2RlZmluaXRpb24ubGFiZWx9IG11c3QgYmUgYSBudW1iZXJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWZpbml0aW9uLnJhbmdlID09PSAnZGF0ZScpIHtcbiAgICAgICAgICAgIGlmIChpc05hTihEYXRlLnBhcnNlKHZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVzdWx0LmZhaWw8dm9pZD4oYCR7ZGVmaW5pdGlvbi5sYWJlbH0gbXVzdCBiZSBhIHZhbGlkIGRhdGVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWZpbml0aW9uLnJhbmdlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBSZXN1bHQuZmFpbDx2b2lkPihgJHtkZWZpbml0aW9uLmxhYmVsfSBtdXN0IGJlIHRydWUgb3IgZmFsc2VgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWZpbml0aW9uLnJhbmdlPy5zdGFydHNXaXRoKCdlbnVtOicpKSB7XG4gICAgICAgICAgICBjb25zdCBhbGxvd2VkVmFsdWVzID0gZGVmaW5pdGlvbi5yYW5nZS5zdWJzdHJpbmcoNSkuc3BsaXQoJywnKS5tYXAodiA9PiB2LnRyaW0oKSk7XG4gICAgICAgICAgICBpZiAoIWFsbG93ZWRWYWx1ZXMuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlc3VsdC5mYWlsPHZvaWQ+KGAke2RlZmluaXRpb24ubGFiZWx9IG11c3QgYmUgb25lIG9mOiAke2FsbG93ZWRWYWx1ZXMuam9pbignLCAnKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEN1c3RvbSB2YWxpZGF0aW9uIHJlZ2V4XG4gICAgICAgIGlmIChkZWZpbml0aW9uLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGRlZmluaXRpb24udmFsaWRhdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWdleC50ZXN0KFN0cmluZyh2YWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZXN1bHQuZmFpbDx2b2lkPihgJHtkZWZpbml0aW9uLmxhYmVsfSBmb3JtYXQgaXMgaW52YWxpZGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIHJlZ2V4LCBza2lwIHZhbGlkYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBSZXN1bHQub2s8dm9pZD4oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgcHJvcGVydGllcyBmb3IgYSBjbGFzcyAoZGVsZWdhdGluZyB0byBwbHVnaW4gZm9yIG5vdylcbiAgICAgKi9cbiAgICBhc3luYyBnZXRQcm9wZXJ0aWVzRm9yQ2xhc3MoY2xhc3NOYW1lOiBzdHJpbmcpOiBQcm9taXNlPFJlc3VsdDxhbnlbXT4+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBhd2FpdCB0aGlzLnBsdWdpbi5maW5kUHJvcGVydGllc0ZvckNsYXNzKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gUmVzdWx0Lm9rKHByb3BlcnRpZXMpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIFJlc3VsdC5mYWlsKGBGYWlsZWQgdG8gZ2V0IHByb3BlcnRpZXM6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhc3NldHMgZm9yIGEgY2xhc3MgKGZvciBkcm9wZG93bnMpXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QXNzZXRzRm9yQ2xhc3MoY2xhc3NOYW1lOiBzdHJpbmcpOiBQcm9taXNlPFJlc3VsdDxhbnlbXT4+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFzc2V0cyA9IGF3YWl0IHRoaXMucGx1Z2luLmZpbmRBc3NldHNCeUNsYXNzKGNsYXNzTmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gUmVzdWx0Lm9rKGFzc2V0cyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVzdWx0LmZhaWwoYEZhaWxlZCB0byBnZXQgYXNzZXRzOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG59Il0sInZlcnNpb24iOjN9