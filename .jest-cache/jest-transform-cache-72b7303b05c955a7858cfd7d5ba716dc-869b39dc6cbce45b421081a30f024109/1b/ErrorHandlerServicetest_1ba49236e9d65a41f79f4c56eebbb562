213405314e69554eb4a2c0066634454c
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
// Mock dependencies
jest.mock('../../../../src/domain/errors/ErrorAnalyzer');
jest.mock('obsidian', () => ({
    Notice: jest.fn()
}));
const ErrorHandlerService_1 = require("../../../../src/application/services/ErrorHandlerService");
const ExocortexError_1 = require("../../../../src/domain/errors/ExocortexError");
const ErrorAnalyzer_1 = require("../../../../src/domain/errors/ErrorAnalyzer");
const obsidian_1 = require("obsidian");
describe('ErrorHandlerService', () => {
    let errorHandlerService;
    let mockAnalyzer;
    let mockNotice;
    let consoleErrorSpy;
    let consoleWarnSpy;
    let consoleInfoSpy;
    let consoleLogSpy;
    beforeEach(() => {
        mockAnalyzer = ErrorAnalyzer_1.ErrorAnalyzer;
        mockNotice = obsidian_1.Notice;
        // Mock console methods
        consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation();
        consoleWarnSpy = jest.spyOn(console, 'warn').mockImplementation();
        consoleInfoSpy = jest.spyOn(console, 'info').mockImplementation();
        consoleLogSpy = jest.spyOn(console, 'log').mockImplementation();
        jest.clearAllMocks();
    });
    afterEach(() => {
        consoleErrorSpy.mockRestore();
        consoleWarnSpy.mockRestore();
        consoleInfoSpy.mockRestore();
        consoleLogSpy.mockRestore();
    });
    describe('constructor', () => {
        it('should create service with default options', () => {
            errorHandlerService = new ErrorHandlerService_1.ErrorHandlerService();
            const metrics = errorHandlerService.getMetrics();
            expect(metrics.totalErrors).toBe(0);
            expect(metrics.errorsBySeverity[ExocortexError_1.ErrorSeverity.CRITICAL]).toBe(0);
            expect(metrics.errorsByCategory[ExocortexError_1.ErrorCategory.SYSTEM]).toBe(0);
        });
        it('should create service with custom options', () => {
            const options = {
                showUserNotification: false,
                logToConsole: false,
                trackMetrics: false,
                autoRecover: true
            };
            errorHandlerService = new ErrorHandlerService_1.ErrorHandlerService(options);
            expect(errorHandlerService).toBeDefined();
        });
        it('should merge custom options with defaults', () => {
            const options = {
                showUserNotification: false
            };
            errorHandlerService = new ErrorHandlerService_1.ErrorHandlerService(options);
            expect(errorHandlerService).toBeDefined();
        });
        it('should initialize empty error history', () => {
            errorHandlerService = new ErrorHandlerService_1.ErrorHandlerService();
            const history = errorHandlerService.getErrorHistory();
            expect(history).toEqual([]);
        });
        it('should initialize metrics with zero values', () => {
            errorHandlerService = new ErrorHandlerService_1.ErrorHandlerService();
            const metrics = errorHandlerService.getMetrics();
            expect(metrics.totalErrors).toBe(0);
            expect(metrics.averageResolutionTime).toBe(0);
            expect(metrics.lastError).toBeUndefined();
        });
    });
    describe('handleError', () => {
        beforeEach(() => {
            errorHandlerService = new ErrorHandlerService_1.ErrorHandlerService();
        });
        it('should handle string error successfully', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockError = createMockExocortexError();
            mockAnalyzer.analyze.mockReturnValue(mockError);
            const result = yield errorHandlerService.handleError('Test error message');
            expect(result.isSuccess).toBe(true);
            expect(mockAnalyzer.analyze).toHaveBeenCalledWith('Test error message');
        }));
        it('should handle Error object successfully', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockError = createMockExocortexError();
            mockAnalyzer.analyze.mockReturnValue(mockError);
            const errorObject = new Error('Test error');
            const result = yield errorHandlerService.handleError(errorObject);
            expect(result.isSuccess).toBe(true);
            expect(mockAnalyzer.analyze).toHaveBeenCalledWith(errorObject);
        }));
        it('should handle ExocortexError directly', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const exocortexError = createMockExocortexError();
            const result = yield errorHandlerService.handleError(exocortexError);
            expect(result.isSuccess).toBe(true);
            expect(mockAnalyzer.analyze).not.toHaveBeenCalled();
        }));
        it('should merge context when provided', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockError = createMockExocortexError();
            mockAnalyzer.analyze.mockReturnValue(mockError);
            const context = {
                userId: 'user123',
                sessionId: 'session456'
            };
            const result = yield errorHandlerService.handleError('Test error', context);
            expect(result.isSuccess).toBe(true);
        }));
        it('should update metrics when tracking enabled', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockError = createMockExocortexError();
            mockAnalyzer.analyze.mockReturnValue(mockError);
            yield errorHandlerService.handleError('Test error');
            const metrics = errorHandlerService.getMetrics();
            expect(metrics.totalErrors).toBe(1);
            expect(metrics.errorsBySeverity[ExocortexError_1.ErrorSeverity.ERROR]).toBe(1);
            expect(metrics.errorsByCategory[ExocortexError_1.ErrorCategory.VALIDATION]).toBe(1);
        }));
        it('should skip metrics when tracking disabled', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            errorHandlerService = new ErrorHandlerService_1.ErrorHandlerService({ trackMetrics: false });
            const mockError = createMockExocortexError();
            mockAnalyzer.analyze.mockReturnValue(mockError);
            yield errorHandlerService.handleError('Test error');
            const metrics = errorHandlerService.getMetrics();
            expect(metrics.totalErrors).toBe(0);
        }));
        it('should log to console when enabled', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockError = createMockExocortexError();
            mockAnalyzer.analyze.mockReturnValue(mockError);
            yield errorHandlerService.handleError('Test error');
            expect(consoleErrorSpy).toHaveBeenCalled();
        }));
        it('should skip console logging when disabled', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            errorHandlerService = new ErrorHandlerService_1.ErrorHandlerService({ logToConsole: false });
            const mockError = createMockExocortexError();
            mockAnalyzer.analyze.mockReturnValue(mockError);
            yield errorHandlerService.handleError('Test error');
            expect(consoleErrorSpy).not.toHaveBeenCalled();
        }));
        it('should show user notification when enabled', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockError = createMockExocortexError();
            mockAnalyzer.analyze.mockReturnValue(mockError);
            yield errorHandlerService.handleError('Test error');
            expect(mockNotice).toHaveBeenCalled();
        }));
        it('should skip user notification when disabled', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            errorHandlerService = new ErrorHandlerService_1.ErrorHandlerService({ showUserNotification: false });
            const mockError = createMockExocortexError();
            mockAnalyzer.analyze.mockReturnValue(mockError);
            yield errorHandlerService.handleError('Test error');
            expect(mockNotice).not.toHaveBeenCalled();
        }));
        it('should add error to history', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockError = createMockExocortexError();
            mockAnalyzer.analyze.mockReturnValue(mockError);
            yield errorHandlerService.handleError('Test error');
            const history = errorHandlerService.getErrorHistory();
            expect(history).toHaveLength(1);
            expect(history[0]).toEqual(mockError);
        }));
        it('should attempt recovery when enabled and error is recoverable', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            errorHandlerService = new ErrorHandlerService_1.ErrorHandlerService({ autoRecover: true });
            const mockSuggestion = {
                title: 'Auto Fix',
                description: 'Automatic fix suggestion',
                confidence: 0.95,
                action: {
                    label: 'Apply Fix',
                    handler: jest.fn().mockResolvedValue(undefined)
                }
            };
            const mockError = Object.assign(Object.assign({}, createMockExocortexError()), { recoverable: true, suggestions: [mockSuggestion] });
            mockAnalyzer.analyze.mockReturnValue(mockError);
            yield errorHandlerService.handleError('Recoverable error');
            expect(mockSuggestion.action.handler).toHaveBeenCalled();
        }));
        it('should skip recovery when disabled', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockSuggestion = {
                title: 'Auto Fix',
                description: 'Automatic fix suggestion',
                confidence: 0.95,
                action: {
                    label: 'Apply Fix',
                    handler: jest.fn().mockResolvedValue(undefined)
                }
            };
            const mockError = Object.assign(Object.assign({}, createMockExocortexError()), { recoverable: true, suggestions: [mockSuggestion] });
            mockAnalyzer.analyze.mockReturnValue(mockError);
            yield errorHandlerService.handleError('Recoverable error');
            expect(mockSuggestion.action.handler).not.toHaveBeenCalled();
        }));
        it('should handle error in error handler gracefully', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            mockAnalyzer.analyze.mockImplementation(() => {
                throw new Error('Analyzer failed');
            });
            const result = yield errorHandlerService.handleError('Test error');
            expect(result.isFailure).toBe(true);
            expect(result.error).toContain('Failed to handle the error properly');
            expect(consoleErrorSpy).toHaveBeenCalledWith('Error in error handler:', expect.any(Error));
        }));
    });
    describe('markErrorResolved', () => {
        beforeEach(() => {
            errorHandlerService = new ErrorHandlerService_1.ErrorHandlerService();
        });
        it('should track resolution time', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockError = createMockExocortexError();
            mockAnalyzer.analyze.mockReturnValue(mockError);
            // Handle error and mark as resolved
            yield errorHandlerService.handleError('Test error');
            // Add a small delay to ensure resolution time > 0
            yield new Promise(resolve => setTimeout(resolve, 1));
            errorHandlerService.markErrorResolved(mockError.id);
            const metrics = errorHandlerService.getMetrics();
            expect(metrics.averageResolutionTime).toBeGreaterThanOrEqual(0);
        }));
        it('should handle non-existent error ID gracefully', () => {
            expect(() => {
                errorHandlerService.markErrorResolved('non-existent-id');
            }).not.toThrow();
        });
        it('should calculate average resolution time correctly', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockError1 = Object.assign(Object.assign({}, createMockExocortexError()), { id: 'error1' });
            const mockError2 = Object.assign(Object.assign({}, createMockExocortexError()), { id: 'error2' });
            mockAnalyzer.analyze.mockReturnValueOnce(mockError1).mockReturnValueOnce(mockError2);
            yield errorHandlerService.handleError('Error 1');
            yield new Promise(resolve => setTimeout(resolve, 10)); // Small delay
            yield errorHandlerService.handleError('Error 2');
            errorHandlerService.markErrorResolved('error1');
            errorHandlerService.markErrorResolved('error2');
            const metrics = errorHandlerService.getMetrics();
            expect(metrics.averageResolutionTime).toBeGreaterThan(0);
        }));
        it('should limit resolution time history to 100 entries', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            // Create 101 errors
            for (let i = 0; i < 101; i++) {
                const mockError = Object.assign(Object.assign({}, createMockExocortexError()), { id: `error${i}` });
                mockAnalyzer.analyze.mockReturnValue(mockError);
                yield errorHandlerService.handleError(`Error ${i}`);
                // Add tiny delay to ensure resolution time > 0
                if (i === 0) {
                    yield new Promise(resolve => setTimeout(resolve, 1));
                }
                errorHandlerService.markErrorResolved(`error${i}`);
            }
            // Should maintain only 100 resolution times
            const metrics = errorHandlerService.getMetrics();
            expect(metrics.averageResolutionTime).toBeGreaterThanOrEqual(0);
        }));
    });
    describe('logging methods', () => {
        beforeEach(() => {
            errorHandlerService = new ErrorHandlerService_1.ErrorHandlerService();
        });
        it('should log critical errors to console.error', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockError = Object.assign(Object.assign({}, createMockExocortexError()), { severity: ExocortexError_1.ErrorSeverity.CRITICAL });
            mockAnalyzer.analyze.mockReturnValue(mockError);
            yield errorHandlerService.handleError('Critical error');
            expect(consoleErrorSpy).toHaveBeenCalled();
        }));
        it('should log warnings to console.warn', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockError = Object.assign(Object.assign({}, createMockExocortexError()), { severity: ExocortexError_1.ErrorSeverity.WARNING });
            mockAnalyzer.analyze.mockReturnValue(mockError);
            yield errorHandlerService.handleError('Warning error');
            expect(consoleWarnSpy).toHaveBeenCalled();
        }));
        it('should log info messages to console.info', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockError = Object.assign(Object.assign({}, createMockExocortexError()), { severity: ExocortexError_1.ErrorSeverity.INFO });
            mockAnalyzer.analyze.mockReturnValue(mockError);
            yield errorHandlerService.handleError('Info message');
            expect(consoleInfoSpy).toHaveBeenCalled();
        }));
        it('should format error message with location', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockError = Object.assign(Object.assign({}, createMockExocortexError()), { context: {
                    operation: 'test',
                    timestamp: new Date(),
                    location: { line: 42, column: 10, file: 'test.sparql' }
                } });
            mockAnalyzer.analyze.mockReturnValue(mockError);
            yield errorHandlerService.handleError('Error with location');
            expect(consoleErrorSpy).toHaveBeenCalledWith(expect.stringContaining('(Line 42:10)'), expect.any(Object));
        }));
        it('should handle string location context', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockError = Object.assign(Object.assign({}, createMockExocortexError()), { context: {
                    operation: 'test',
                    timestamp: new Date(),
                    location: 'Some location string'
                } });
            mockAnalyzer.analyze.mockReturnValue(mockError);
            yield errorHandlerService.handleError('Error with string location');
            expect(consoleErrorSpy).toHaveBeenCalled();
        }));
    });
    describe('user notifications', () => {
        beforeEach(() => {
            errorHandlerService = new ErrorHandlerService_1.ErrorHandlerService();
        });
        it('should show longer notification for critical errors', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockError = Object.assign(Object.assign({}, createMockExocortexError()), { severity: ExocortexError_1.ErrorSeverity.CRITICAL });
            mockAnalyzer.analyze.mockReturnValue(mockError);
            yield errorHandlerService.handleError('Critical error');
            expect(mockNotice).toHaveBeenCalledWith(expect.any(String), 10000);
        }));
        it('should show shorter notification for info messages', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockError = Object.assign(Object.assign({}, createMockExocortexError()), { severity: ExocortexError_1.ErrorSeverity.INFO });
            mockAnalyzer.analyze.mockReturnValue(mockError);
            yield errorHandlerService.handleError('Info message');
            expect(mockNotice).toHaveBeenCalledWith(expect.any(String), 3000);
        }));
        it('should include suggestion in notification message', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockSuggestion = {
                title: 'Quick Fix',
                description: 'Try this solution'
            };
            const mockError = Object.assign(Object.assign({}, createMockExocortexError()), { suggestions: [mockSuggestion] });
            mockAnalyzer.analyze.mockReturnValue(mockError);
            yield errorHandlerService.handleError('Error with suggestion');
            expect(mockNotice).toHaveBeenCalledWith(expect.stringContaining('💡 Quick Fix'), expect.any(Number));
        }));
        it('should handle error without suggestions', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockError = Object.assign(Object.assign({}, createMockExocortexError()), { suggestions: [] });
            mockAnalyzer.analyze.mockReturnValue(mockError);
            yield errorHandlerService.handleError('Error without suggestions');
            expect(mockNotice).toHaveBeenCalledWith(expect.not.stringContaining('💡'), expect.any(Number));
        }));
    });
    describe('error history management', () => {
        beforeEach(() => {
            errorHandlerService = new ErrorHandlerService_1.ErrorHandlerService();
        });
        it('should maintain error history in LIFO order', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockError1 = Object.assign(Object.assign({}, createMockExocortexError()), { id: 'error1', title: 'First Error' });
            const mockError2 = Object.assign(Object.assign({}, createMockExocortexError()), { id: 'error2', title: 'Second Error' });
            mockAnalyzer.analyze.mockReturnValueOnce(mockError1).mockReturnValueOnce(mockError2);
            yield errorHandlerService.handleError('First error');
            yield errorHandlerService.handleError('Second error');
            const history = errorHandlerService.getErrorHistory();
            expect(history[0].title).toBe('Second Error');
            expect(history[1].title).toBe('First Error');
        }));
        it('should limit history to maximum size', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            // Add 101 errors to exceed the limit
            for (let i = 0; i < 101; i++) {
                const mockError = Object.assign(Object.assign({}, createMockExocortexError()), { id: `error${i}` });
                mockAnalyzer.analyze.mockReturnValue(mockError);
                yield errorHandlerService.handleError(`Error ${i}`);
            }
            const history = errorHandlerService.getErrorHistory();
            expect(history).toHaveLength(100);
        }));
        it('should clear history successfully', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockError = createMockExocortexError();
            mockAnalyzer.analyze.mockReturnValue(mockError);
            yield errorHandlerService.handleError('Test error');
            expect(errorHandlerService.getErrorHistory()).toHaveLength(1);
            errorHandlerService.clearHistory();
            expect(errorHandlerService.getErrorHistory()).toHaveLength(0);
        }));
        it('should clear error start times when clearing history', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockError = createMockExocortexError();
            mockAnalyzer.analyze.mockReturnValue(mockError);
            yield errorHandlerService.handleError('Test error');
            errorHandlerService.clearHistory();
            // Should not throw when trying to mark resolved after clear
            expect(() => {
                errorHandlerService.markErrorResolved(mockError.id);
            }).not.toThrow();
        }));
    });
    describe('getSuggestions', () => {
        beforeEach(() => {
            errorHandlerService = new ErrorHandlerService_1.ErrorHandlerService();
        });
        it('should return suggestions for string error', () => {
            const mockSuggestions = [
                { title: 'Fix 1', description: 'First fix' },
                { title: 'Fix 2', description: 'Second fix' }
            ];
            const mockError = Object.assign(Object.assign({}, createMockExocortexError()), { suggestions: mockSuggestions });
            mockAnalyzer.analyze.mockReturnValue(mockError);
            const suggestions = errorHandlerService.getSuggestions('Test error');
            expect(suggestions).toEqual(mockSuggestions);
            expect(mockAnalyzer.analyze).toHaveBeenCalledWith('Test error');
        });
        it('should return suggestions for Error object', () => {
            const mockSuggestions = [
                { title: 'Error Fix', description: 'Fix for error object' }
            ];
            const mockError = Object.assign(Object.assign({}, createMockExocortexError()), { suggestions: mockSuggestions });
            mockAnalyzer.analyze.mockReturnValue(mockError);
            const errorObject = new Error('Test error object');
            const suggestions = errorHandlerService.getSuggestions(errorObject);
            expect(suggestions).toEqual(mockSuggestions);
            expect(mockAnalyzer.analyze).toHaveBeenCalledWith(errorObject);
        });
        it('should return empty array when no suggestions available', () => {
            const mockError = Object.assign(Object.assign({}, createMockExocortexError()), { suggestions: undefined });
            mockAnalyzer.analyze.mockReturnValue(mockError);
            const suggestions = errorHandlerService.getSuggestions('Error without suggestions');
            expect(suggestions).toEqual([]);
        });
    });
    describe('analyzeError', () => {
        beforeEach(() => {
            errorHandlerService = new ErrorHandlerService_1.ErrorHandlerService();
        });
        it('should return analyzed ExocortexError for string', () => {
            const mockError = createMockExocortexError();
            mockAnalyzer.analyze.mockReturnValue(mockError);
            const analyzed = errorHandlerService.analyzeError('Test error');
            expect(analyzed).toEqual(mockError);
            expect(mockAnalyzer.analyze).toHaveBeenCalledWith('Test error');
        });
        it('should return analyzed ExocortexError for Error object', () => {
            const mockError = createMockExocortexError();
            mockAnalyzer.analyze.mockReturnValue(mockError);
            const errorObject = new Error('Test error object');
            const analyzed = errorHandlerService.analyzeError(errorObject);
            expect(analyzed).toEqual(mockError);
            expect(mockAnalyzer.analyze).toHaveBeenCalledWith(errorObject);
        });
    });
    describe('recovery mechanism', () => {
        beforeEach(() => {
            errorHandlerService = new ErrorHandlerService_1.ErrorHandlerService({ autoRecover: true });
        });
        it('should not attempt recovery for non-recoverable errors', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockSuggestion = {
                title: 'Manual Fix',
                description: 'Requires manual intervention',
                confidence: 0.95,
                action: {
                    label: 'Apply',
                    handler: jest.fn()
                }
            };
            const mockError = Object.assign(Object.assign({}, createMockExocortexError()), { recoverable: false, suggestions: [mockSuggestion] });
            mockAnalyzer.analyze.mockReturnValue(mockError);
            yield errorHandlerService.handleError('Non-recoverable error');
            expect(mockSuggestion.action.handler).not.toHaveBeenCalled();
        }));
        it('should not attempt recovery for low-confidence suggestions', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockSuggestion = {
                title: 'Uncertain Fix',
                description: 'Low confidence fix',
                confidence: 0.5,
                action: {
                    label: 'Try',
                    handler: jest.fn()
                }
            };
            const mockError = Object.assign(Object.assign({}, createMockExocortexError()), { recoverable: true, suggestions: [mockSuggestion] });
            mockAnalyzer.analyze.mockReturnValue(mockError);
            yield errorHandlerService.handleError('Low confidence error');
            expect(mockSuggestion.action.handler).not.toHaveBeenCalled();
        }));
        it('should handle recovery failure gracefully', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockSuggestion = {
                title: 'Failing Fix',
                description: 'This fix will fail',
                confidence: 0.95,
                action: {
                    label: 'Apply',
                    handler: jest.fn().mockRejectedValue(new Error('Recovery failed'))
                }
            };
            const mockError = Object.assign(Object.assign({}, createMockExocortexError()), { recoverable: true, suggestions: [mockSuggestion] });
            mockAnalyzer.analyze.mockReturnValue(mockError);
            const result = yield errorHandlerService.handleError('Failing recovery error');
            expect(result.isSuccess).toBe(true); // Main error handling should still succeed
            expect(consoleErrorSpy).toHaveBeenCalledWith('Auto-recovery failed:', expect.any(Error));
        }));
        it('should show recovery notification on success', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockSuggestion = {
                title: 'Successful Fix',
                description: 'This fix will succeed',
                confidence: 0.95,
                action: {
                    label: 'Apply',
                    handler: jest.fn().mockResolvedValue(undefined)
                }
            };
            const mockError = Object.assign(Object.assign({}, createMockExocortexError()), { recoverable: true, suggestions: [mockSuggestion] });
            mockAnalyzer.analyze.mockReturnValue(mockError);
            yield errorHandlerService.handleError('Recoverable error');
            expect(mockNotice).toHaveBeenCalledWith('Auto-recovery: Successful Fix', 3000);
        }));
    });
    describe('edge cases and boundary conditions', () => {
        beforeEach(() => {
            errorHandlerService = new ErrorHandlerService_1.ErrorHandlerService();
        });
        it('should handle empty string error', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockError = createMockExocortexError();
            mockAnalyzer.analyze.mockReturnValue(mockError);
            const result = yield errorHandlerService.handleError('');
            expect(result.isSuccess).toBe(true);
            expect(mockAnalyzer.analyze).toHaveBeenCalledWith('');
        }));
        it('should handle null context gracefully', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockError = createMockExocortexError();
            mockAnalyzer.analyze.mockReturnValue(mockError);
            const result = yield errorHandlerService.handleError('Test error', null);
            expect(result.isSuccess).toBe(true);
        }));
        it('should handle undefined suggestions array', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockError = Object.assign(Object.assign({}, createMockExocortexError()), { suggestions: undefined });
            mockAnalyzer.analyze.mockReturnValue(mockError);
            const result = yield errorHandlerService.handleError('Error without suggestions');
            expect(result.isSuccess).toBe(true);
        }));
        it('should handle error with null action in suggestion', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockSuggestion = {
                title: 'No Action Fix',
                description: 'Suggestion without action',
                confidence: 0.95,
                action: null
            };
            const mockError = Object.assign(Object.assign({}, createMockExocortexError()), { recoverable: true, suggestions: [mockSuggestion] });
            mockAnalyzer.analyze.mockReturnValue(mockError);
            const result = yield errorHandlerService.handleError('Error with null action');
            expect(result.isSuccess).toBe(true);
        }));
        it('should handle very large error messages', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const largeMessage = 'Large error message: ' + 'x'.repeat(10000);
            const mockError = Object.assign(Object.assign({}, createMockExocortexError()), { message: largeMessage });
            mockAnalyzer.analyze.mockReturnValue(mockError);
            const result = yield errorHandlerService.handleError(largeMessage);
            expect(result.isSuccess).toBe(true);
        }));
    });
    // Helper function to create mock ExocortexError
    function createMockExocortexError() {
        return {
            id: 'test-error-id',
            severity: ExocortexError_1.ErrorSeverity.ERROR,
            category: ExocortexError_1.ErrorCategory.VALIDATION,
            title: 'Test Error',
            message: 'This is a test error message',
            context: {
                operation: 'test-operation',
                timestamp: new Date()
            },
            recoverable: false
        };
    }
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2tpdGVsZXYvRG9jdW1lbnRzL2V4b2NvcnRleC1vYnNpZGlhbi1wbHVnaW4vdGVzdHMvdW5pdC9hcHBsaWNhdGlvbi9zZXJ2aWNlcy9FcnJvckhhbmRsZXJTZXJ2aWNlLnRlc3QudHMiLCJtYXBwaW5ncyI6Ijs7O0FBTUEsb0JBQW9CO0FBQ3BCLElBQUksQ0FBQyxJQUFJLENBQUMsNkNBQTZDLENBQUMsQ0FBQztBQUN6RCxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0lBQzNCLE1BQU0sRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO0NBQ2xCLENBQUMsQ0FBQyxDQUFDO0FBVkosa0dBQWtJO0FBQ2xJLGlGQUF5STtBQUV6SSwrRUFBNEU7QUFDNUUsdUNBQWtDO0FBUWxDLFFBQVEsQ0FBQyxxQkFBcUIsRUFBRSxHQUFHLEVBQUU7SUFDbkMsSUFBSSxtQkFBd0MsQ0FBQztJQUM3QyxJQUFJLFlBQStDLENBQUM7SUFDcEQsSUFBSSxVQUEyQyxDQUFDO0lBQ2hELElBQUksZUFBaUMsQ0FBQztJQUN0QyxJQUFJLGNBQWdDLENBQUM7SUFDckMsSUFBSSxjQUFnQyxDQUFDO0lBQ3JDLElBQUksYUFBK0IsQ0FBQztJQUVwQyxVQUFVLENBQUMsR0FBRyxFQUFFO1FBQ2QsWUFBWSxHQUFHLDZCQUFrRCxDQUFDO1FBQ2xFLFVBQVUsR0FBRyxpQkFBeUMsQ0FBQztRQUV2RCx1QkFBdUI7UUFDdkIsZUFBZSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDLGtCQUFrQixFQUFFLENBQUM7UUFDcEUsY0FBYyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUFDLGtCQUFrQixFQUFFLENBQUM7UUFDbEUsY0FBYyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUFDLGtCQUFrQixFQUFFLENBQUM7UUFDbEUsYUFBYSxHQUFHLElBQUksQ0FB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LGVBQWU7WUFDbkIsUUFBUSxFQUFFLDhCQUFhLENBQUMsS0FBSztZQUM3QixRQUFRLEVBQUUsOEJBQWEsQ0FBQyxVQUFVO1lBQ2xDLEtBQUssRUFBRSxZQUFZO1lBQ25CLE9BQU8sRUFBRSw4QkFBOEI7WUFDdkMsT0FBTyxFQUFFO2dCQUNQLFNBQVMsRUFBRSxnQkFBZ0I7Z0JBQzNCLFNBQVMsRUFBRSxJQUFJLElBQUksRUFBRTthQUN0QjtZQUNELFdBQVcsRUFBRSxLQUFLO1NBQ25CLENBQUM7SUFDSixDQUFDO0FBQ0gsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL1VzZXJzL2tpdGVsZXYvRG9jdW1lbnRzL2V4b2NvcnRleC1vYnNpZGlhbi1wbHVnaW4vdGVzdHMvdW5pdC9hcHBsaWNhdGlvbi9zZXJ2aWNlcy9FcnJvckhhbmRsZXJTZXJ2aWNlLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXJyb3JIYW5kbGVyU2VydmljZSwgRXJyb3JIYW5kbGVyT3B0aW9ucywgRXJyb3JNZXRyaWNzIH0gZnJvbSAnLi4vLi4vLi4vLi4vc3JjL2FwcGxpY2F0aW9uL3NlcnZpY2VzL0Vycm9ySGFuZGxlclNlcnZpY2UnO1xuaW1wb3J0IHsgRXhvY29ydGV4RXJyb3IsIEVycm9yU2V2ZXJpdHksIEVycm9yQ2F0ZWdvcnksIEVycm9yQnVpbGRlciwgRml4U3VnZ2VzdGlvbiB9IGZyb20gJy4uLy4uLy4uLy4uL3NyYy9kb21haW4vZXJyb3JzL0V4b2NvcnRleEVycm9yJztcbmltcG9ydCB7IEVuaGFuY2VkUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vLi4vc3JjL2RvbWFpbi9jb3JlL0VuaGFuY2VkUmVzdWx0JztcbmltcG9ydCB7IEVycm9yQW5hbHl6ZXIgfSBmcm9tICcuLi8uLi8uLi8uLi9zcmMvZG9tYWluL2Vycm9ycy9FcnJvckFuYWx5emVyJztcbmltcG9ydCB7IE5vdGljZSB9IGZyb20gJ29ic2lkaWFuJztcblxuLy8gTW9jayBkZXBlbmRlbmNpZXNcbmplc3QubW9jaygnLi4vLi4vLi4vLi4vc3JjL2RvbWFpbi9lcnJvcnMvRXJyb3JBbmFseXplcicpO1xuamVzdC5tb2NrKCdvYnNpZGlhbicsICgpID0+ICh7XG4gIE5vdGljZTogamVzdC5mbigpXG59KSk7XG5cbmRlc2NyaWJlKCdFcnJvckhhbmRsZXJTZXJ2aWNlJywgKCkgPT4ge1xuICBsZXQgZXJyb3JIYW5kbGVyU2VydmljZTogRXJyb3JIYW5kbGVyU2VydmljZTtcbiAgbGV0IG1vY2tBbmFseXplcjogamVzdC5Nb2NrZWQ8dHlwZW9mIEVycm9yQW5hbHl6ZXI+O1xuICBsZXQgbW9ja05vdGljZTogamVzdC5Nb2NrZWRDbGFzczx0eXBlb2YgTm90aWNlPjtcbiAgbGV0IGNvbnNvbGVFcnJvclNweTogamVzdC5TcHlJbnN0YW5jZTtcbiAgbGV0IGNvbnNvbGVXYXJuU3B5OiBqZXN0LlNweUluc3RhbmNlO1xuICBsZXQgY29uc29sZUluZm9TcHk6IGplc3QuU3B5SW5zdGFuY2U7XG4gIGxldCBjb25zb2xlTG9nU3B5OiBqZXN0LlNweUluc3RhbmNlO1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIG1vY2tBbmFseXplciA9IEVycm9yQW5hbHl6ZXIgYXMgamVzdC5Nb2NrZWQ8dHlwZW9mIEVycm9yQW5hbHl6ZXI+O1xuICAgIG1vY2tOb3RpY2UgPSBOb3RpY2UgYXMgamVzdC5Nb2NrZWRDbGFzczx0eXBlb2YgTm90aWNlPjtcbiAgICBcbiAgICAvLyBNb2NrIGNvbnNvbGUgbWV0aG9kc1xuICAgIGNvbnNvbGVFcnJvclNweSA9IGplc3Quc3B5T24oY29uc29sZSwgJ2Vycm9yJykubW9ja0ltcGxlbWVudGF0aW9uKCk7XG4gICAgY29uc29sZVdhcm5TcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICd3YXJuJykubW9ja0ltcGxlbWVudGF0aW9uKCk7XG4gICAgY29uc29sZUluZm9TcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdpbmZvJykubW9ja0ltcGxlbWVudGF0aW9uKCk7XG4gICAgY29uc29sZUxvZ1NweSA9IGplc3Quc3B5T24oY29uc29sZSwgJ2xvZycpLm1vY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgY29uc29sZUVycm9yU3B5Lm1vY2tSZXN0b3JlKCk7XG4gICAgY29uc29sZVdhcm5TcHkubW9ja1Jlc3RvcmUoKTtcbiAgICBjb25zb2xlSW5mb1NweS5tb2NrUmVzdG9yZSgpO1xuICAgIGNvbnNvbGVMb2dTcHkubW9ja1Jlc3RvcmUoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2NvbnN0cnVjdG9yJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgY3JlYXRlIHNlcnZpY2Ugd2l0aCBkZWZhdWx0IG9wdGlvbnMnLCAoKSA9PiB7XG4gICAgICBlcnJvckhhbmRsZXJTZXJ2aWNlID0gbmV3IEVycm9ySGFuZGxlclNlcnZpY2UoKTtcbiAgICAgIFxuICAgICAgY29uc3QgbWV0cmljcyA9IGVycm9ySGFuZGxlclNlcnZpY2UuZ2V0TWV0cmljcygpO1xuICAgICAgZXhwZWN0KG1ldHJpY3MudG90YWxFcnJvcnMpLnRvQmUoMCk7XG4gICAgICBleHBlY3QobWV0cmljcy5lcnJvcnNCeVNldmVyaXR5W0Vycm9yU2V2ZXJpdHkuQ1JJVElDQUxdKS50b0JlKDApO1xuICAgICAgZXhwZWN0KG1ldHJpY3MuZXJyb3JzQnlDYXRlZ29yeVtFcnJvckNhdGVnb3J5LlNZU1RFTV0pLnRvQmUoMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNyZWF0ZSBzZXJ2aWNlIHdpdGggY3VzdG9tIG9wdGlvbnMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zOiBFcnJvckhhbmRsZXJPcHRpb25zID0ge1xuICAgICAgICBzaG93VXNlck5vdGlmaWNhdGlvbjogZmFsc2UsXG4gICAgICAgIGxvZ1RvQ29uc29sZTogZmFsc2UsXG4gICAgICAgIHRyYWNrTWV0cmljczogZmFsc2UsXG4gICAgICAgIGF1dG9SZWNvdmVyOiB0cnVlXG4gICAgICB9O1xuXG4gICAgICBlcnJvckhhbmRsZXJTZXJ2aWNlID0gbmV3IEVycm9ySGFuZGxlclNlcnZpY2Uob3B0aW9ucyk7XG4gICAgICBleHBlY3QoZXJyb3JIYW5kbGVyU2VydmljZSkudG9CZURlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbWVyZ2UgY3VzdG9tIG9wdGlvbnMgd2l0aCBkZWZhdWx0cycsICgpID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbnM6IEVycm9ySGFuZGxlck9wdGlvbnMgPSB7XG4gICAgICAgIHNob3dVc2VyTm90aWZpY2F0aW9uOiBmYWxzZVxuICAgICAgfTtcblxuICAgICAgZXJyb3JIYW5kbGVyU2VydmljZSA9IG5ldyBFcnJvckhhbmRsZXJTZXJ2aWNlKG9wdGlvbnMpO1xuICAgICAgZXhwZWN0KGVycm9ySGFuZGxlclNlcnZpY2UpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGluaXRpYWxpemUgZW1wdHkgZXJyb3IgaGlzdG9yeScsICgpID0+IHtcbiAgICAgIGVycm9ySGFuZGxlclNlcnZpY2UgPSBuZXcgRXJyb3JIYW5kbGVyU2VydmljZSgpO1xuICAgICAgXG4gICAgICBjb25zdCBoaXN0b3J5ID0gZXJyb3JIYW5kbGVyU2VydmljZS5nZXRFcnJvckhpc3RvcnkoKTtcbiAgICAgIGV4cGVjdChoaXN0b3J5KS50b0VxdWFsKFtdKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaW5pdGlhbGl6ZSBtZXRyaWNzIHdpdGggemVybyB2YWx1ZXMnLCAoKSA9PiB7XG4gICAgICBlcnJvckhhbmRsZXJTZXJ2aWNlID0gbmV3IEVycm9ySGFuZGxlclNlcnZpY2UoKTtcbiAgICAgIFxuICAgICAgY29uc3QgbWV0cmljcyA9IGVycm9ySGFuZGxlclNlcnZpY2UuZ2V0TWV0cmljcygpO1xuICAgICAgZXhwZWN0KG1ldHJpY3MudG90YWxFcnJvcnMpLnRvQmUoMCk7XG4gICAgICBleHBlY3QobWV0cmljcy5hdmVyYWdlUmVzb2x1dGlvblRpbWUpLnRvQmUoMCk7XG4gICAgICBleHBlY3QobWV0cmljcy5sYXN0RXJyb3IpLnRvQmVVbmRlZmluZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2hhbmRsZUVycm9yJywgKCkgPT4ge1xuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgZXJyb3JIYW5kbGVyU2VydmljZSA9IG5ldyBFcnJvckhhbmRsZXJTZXJ2aWNlKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBzdHJpbmcgZXJyb3Igc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0Vycm9yOiBFeG9jb3J0ZXhFcnJvciA9IGNyZWF0ZU1vY2tFeG9jb3J0ZXhFcnJvcigpO1xuICAgICAgbW9ja0FuYWx5emVyLmFuYWx5emUubW9ja1JldHVyblZhbHVlKG1vY2tFcnJvcik7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGVycm9ySGFuZGxlclNlcnZpY2UuaGFuZGxlRXJyb3IoJ1Rlc3QgZXJyb3IgbWVzc2FnZScpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmlzU3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChtb2NrQW5hbHl6ZXIuYW5hbHl6ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ1Rlc3QgZXJyb3IgbWVzc2FnZScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgRXJyb3Igb2JqZWN0IHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tFcnJvcjogRXhvY29ydGV4RXJyb3IgPSBjcmVhdGVNb2NrRXhvY29ydGV4RXJyb3IoKTtcbiAgICAgIG1vY2tBbmFseXplci5hbmFseXplLm1vY2tSZXR1cm5WYWx1ZShtb2NrRXJyb3IpO1xuICAgICAgY29uc3QgZXJyb3JPYmplY3QgPSBuZXcgRXJyb3IoJ1Rlc3QgZXJyb3InKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXJyb3JIYW5kbGVyU2VydmljZS5oYW5kbGVFcnJvcihlcnJvck9iamVjdCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuaXNTdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KG1vY2tBbmFseXplci5hbmFseXplKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChlcnJvck9iamVjdCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBFeG9jb3J0ZXhFcnJvciBkaXJlY3RseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGV4b2NvcnRleEVycm9yOiBFeG9jb3J0ZXhFcnJvciA9IGNyZWF0ZU1vY2tFeG9jb3J0ZXhFcnJvcigpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBlcnJvckhhbmRsZXJTZXJ2aWNlLmhhbmRsZUVycm9yKGV4b2NvcnRleEVycm9yKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QobW9ja0FuYWx5emVyLmFuYWx5emUpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIG1lcmdlIGNvbnRleHQgd2hlbiBwcm92aWRlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tFcnJvcjogRXhvY29ydGV4RXJyb3IgPSBjcmVhdGVNb2NrRXhvY29ydGV4RXJyb3IoKTtcbiAgICAgIG1vY2tBbmFseXplci5hbmFseXplLm1vY2tSZXR1cm5WYWx1ZShtb2NrRXJyb3IpO1xuICAgICAgXG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICB1c2VySWQ6ICd1c2VyMTIzJyxcbiAgICAgICAgc2Vzc2lvbklkOiAnc2Vzc2lvbjQ1NidcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGVycm9ySGFuZGxlclNlcnZpY2UuaGFuZGxlRXJyb3IoJ1Rlc3QgZXJyb3InLCBjb250ZXh0KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHVwZGF0ZSBtZXRyaWNzIHdoZW4gdHJhY2tpbmcgZW5hYmxlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tFcnJvcjogRXhvY29ydGV4RXJyb3IgPSBjcmVhdGVNb2NrRXhvY29ydGV4RXJyb3IoKTtcbiAgICAgIG1vY2tBbmFseXplci5hbmFseXplLm1vY2tSZXR1cm5WYWx1ZShtb2NrRXJyb3IpO1xuXG4gICAgICBhd2FpdCBlcnJvckhhbmRsZXJTZXJ2aWNlLmhhbmRsZUVycm9yKCdUZXN0IGVycm9yJyk7XG5cbiAgICAgIGNvbnN0IG1ldHJpY3MgPSBlcnJvckhhbmRsZXJTZXJ2aWNlLmdldE1ldHJpY3MoKTtcbiAgICAgIGV4cGVjdChtZXRyaWNzLnRvdGFsRXJyb3JzKS50b0JlKDEpO1xuICAgICAgZXhwZWN0KG1ldHJpY3MuZXJyb3JzQnlTZXZlcml0eVtFcnJvclNldmVyaXR5LkVSUk9SXSkudG9CZSgxKTtcbiAgICAgIGV4cGVjdChtZXRyaWNzLmVycm9yc0J5Q2F0ZWdvcnlbRXJyb3JDYXRlZ29yeS5WQUxJREFUSU9OXSkudG9CZSgxKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc2tpcCBtZXRyaWNzIHdoZW4gdHJhY2tpbmcgZGlzYWJsZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBlcnJvckhhbmRsZXJTZXJ2aWNlID0gbmV3IEVycm9ySGFuZGxlclNlcnZpY2UoeyB0cmFja01ldHJpY3M6IGZhbHNlIH0pO1xuICAgICAgY29uc3QgbW9ja0Vycm9yOiBFeG9jb3J0ZXhFcnJvciA9IGNyZWF0ZU1vY2tFeG9jb3J0ZXhFcnJvcigpO1xuICAgICAgbW9ja0FuYWx5emVyLmFuYWx5emUubW9ja1JldHVyblZhbHVlKG1vY2tFcnJvcik7XG5cbiAgICAgIGF3YWl0IGVycm9ySGFuZGxlclNlcnZpY2UuaGFuZGxlRXJyb3IoJ1Rlc3QgZXJyb3InKTtcblxuICAgICAgY29uc3QgbWV0cmljcyA9IGVycm9ySGFuZGxlclNlcnZpY2UuZ2V0TWV0cmljcygpO1xuICAgICAgZXhwZWN0KG1ldHJpY3MudG90YWxFcnJvcnMpLnRvQmUoMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGxvZyB0byBjb25zb2xlIHdoZW4gZW5hYmxlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tFcnJvcjogRXhvY29ydGV4RXJyb3IgPSBjcmVhdGVNb2NrRXhvY29ydGV4RXJyb3IoKTtcbiAgICAgIG1vY2tBbmFseXplci5hbmFseXplLm1vY2tSZXR1cm5WYWx1ZShtb2NrRXJyb3IpO1xuXG4gICAgICBhd2FpdCBlcnJvckhhbmRsZXJTZXJ2aWNlLmhhbmRsZUVycm9yKCdUZXN0IGVycm9yJyk7XG5cbiAgICAgIGV4cGVjdChjb25zb2xlRXJyb3JTcHkpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc2tpcCBjb25zb2xlIGxvZ2dpbmcgd2hlbiBkaXNhYmxlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGVycm9ySGFuZGxlclNlcnZpY2UgPSBuZXcgRXJyb3JIYW5kbGVyU2VydmljZSh7IGxvZ1RvQ29uc29sZTogZmFsc2UgfSk7XG4gICAgICBjb25zdCBtb2NrRXJyb3I6IEV4b2NvcnRleEVycm9yID0gY3JlYXRlTW9ja0V4b2NvcnRleEVycm9yKCk7XG4gICAgICBtb2NrQW5hbHl6ZXIuYW5hbHl6ZS5tb2NrUmV0dXJuVmFsdWUobW9ja0Vycm9yKTtcblxuICAgICAgYXdhaXQgZXJyb3JIYW5kbGVyU2VydmljZS5oYW5kbGVFcnJvcignVGVzdCBlcnJvcicpO1xuXG4gICAgICBleHBlY3QoY29uc29sZUVycm9yU3B5KS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBzaG93IHVzZXIgbm90aWZpY2F0aW9uIHdoZW4gZW5hYmxlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tFcnJvcjogRXhvY29ydGV4RXJyb3IgPSBjcmVhdGVNb2NrRXhvY29ydGV4RXJyb3IoKTtcbiAgICAgIG1vY2tBbmFseXplci5hbmFseXplLm1vY2tSZXR1cm5WYWx1ZShtb2NrRXJyb3IpO1xuXG4gICAgICBhd2FpdCBlcnJvckhhbmRsZXJTZXJ2aWNlLmhhbmRsZUVycm9yKCdUZXN0IGVycm9yJyk7XG5cbiAgICAgIGV4cGVjdChtb2NrTm90aWNlKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHNraXAgdXNlciBub3RpZmljYXRpb24gd2hlbiBkaXNhYmxlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGVycm9ySGFuZGxlclNlcnZpY2UgPSBuZXcgRXJyb3JIYW5kbGVyU2VydmljZSh7IHNob3dVc2VyTm90aWZpY2F0aW9uOiBmYWxzZSB9KTtcbiAgICAgIGNvbnN0IG1vY2tFcnJvcjogRXhvY29ydGV4RXJyb3IgPSBjcmVhdGVNb2NrRXhvY29ydGV4RXJyb3IoKTtcbiAgICAgIG1vY2tBbmFseXplci5hbmFseXplLm1vY2tSZXR1cm5WYWx1ZShtb2NrRXJyb3IpO1xuXG4gICAgICBhd2FpdCBlcnJvckhhbmRsZXJTZXJ2aWNlLmhhbmRsZUVycm9yKCdUZXN0IGVycm9yJyk7XG5cbiAgICAgIGV4cGVjdChtb2NrTm90aWNlKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBhZGQgZXJyb3IgdG8gaGlzdG9yeScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tFcnJvcjogRXhvY29ydGV4RXJyb3IgPSBjcmVhdGVNb2NrRXhvY29ydGV4RXJyb3IoKTtcbiAgICAgIG1vY2tBbmFseXplci5hbmFseXplLm1vY2tSZXR1cm5WYWx1ZShtb2NrRXJyb3IpO1xuXG4gICAgICBhd2FpdCBlcnJvckhhbmRsZXJTZXJ2aWNlLmhhbmRsZUVycm9yKCdUZXN0IGVycm9yJyk7XG5cbiAgICAgIGNvbnN0IGhpc3RvcnkgPSBlcnJvckhhbmRsZXJTZXJ2aWNlLmdldEVycm9ySGlzdG9yeSgpO1xuICAgICAgZXhwZWN0KGhpc3RvcnkpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChoaXN0b3J5WzBdKS50b0VxdWFsKG1vY2tFcnJvcik7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGF0dGVtcHQgcmVjb3Zlcnkgd2hlbiBlbmFibGVkIGFuZCBlcnJvciBpcyByZWNvdmVyYWJsZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGVycm9ySGFuZGxlclNlcnZpY2UgPSBuZXcgRXJyb3JIYW5kbGVyU2VydmljZSh7IGF1dG9SZWNvdmVyOiB0cnVlIH0pO1xuICAgICAgY29uc3QgbW9ja1N1Z2dlc3Rpb246IEZpeFN1Z2dlc3Rpb24gPSB7XG4gICAgICAgIHRpdGxlOiAnQXV0byBGaXgnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0F1dG9tYXRpYyBmaXggc3VnZ2VzdGlvbicsXG4gICAgICAgIGNvbmZpZGVuY2U6IDAuOTUsXG4gICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgIGxhYmVsOiAnQXBwbHkgRml4JyxcbiAgICAgICAgICBoYW5kbGVyOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCBtb2NrRXJyb3I6IEV4b2NvcnRleEVycm9yID0ge1xuICAgICAgICAuLi5jcmVhdGVNb2NrRXhvY29ydGV4RXJyb3IoKSxcbiAgICAgICAgcmVjb3ZlcmFibGU6IHRydWUsXG4gICAgICAgIHN1Z2dlc3Rpb25zOiBbbW9ja1N1Z2dlc3Rpb25dXG4gICAgICB9O1xuICAgICAgbW9ja0FuYWx5emVyLmFuYWx5emUubW9ja1JldHVyblZhbHVlKG1vY2tFcnJvcik7XG5cbiAgICAgIGF3YWl0IGVycm9ySGFuZGxlclNlcnZpY2UuaGFuZGxlRXJyb3IoJ1JlY292ZXJhYmxlIGVycm9yJyk7XG5cbiAgICAgIGV4cGVjdChtb2NrU3VnZ2VzdGlvbi5hY3Rpb24hLmhhbmRsZXIpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc2tpcCByZWNvdmVyeSB3aGVuIGRpc2FibGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1N1Z2dlc3Rpb246IEZpeFN1Z2dlc3Rpb24gPSB7XG4gICAgICAgIHRpdGxlOiAnQXV0byBGaXgnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0F1dG9tYXRpYyBmaXggc3VnZ2VzdGlvbicsXG4gICAgICAgIGNvbmZpZGVuY2U6IDAuOTUsXG4gICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgIGxhYmVsOiAnQXBwbHkgRml4JyxcbiAgICAgICAgICBoYW5kbGVyOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCBtb2NrRXJyb3I6IEV4b2NvcnRleEVycm9yID0ge1xuICAgICAgICAuLi5jcmVhdGVNb2NrRXhvY29ydGV4RXJyb3IoKSxcbiAgICAgICAgcmVjb3ZlcmFibGU6IHRydWUsXG4gICAgICAgIHN1Z2dlc3Rpb25zOiBbbW9ja1N1Z2dlc3Rpb25dXG4gICAgICB9O1xuICAgICAgbW9ja0FuYWx5emVyLmFuYWx5emUubW9ja1JldHVyblZhbHVlKG1vY2tFcnJvcik7XG5cbiAgICAgIGF3YWl0IGVycm9ySGFuZGxlclNlcnZpY2UuaGFuZGxlRXJyb3IoJ1JlY292ZXJhYmxlIGVycm9yJyk7XG5cbiAgICAgIGV4cGVjdChtb2NrU3VnZ2VzdGlvbi5hY3Rpb24hLmhhbmRsZXIpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBlcnJvciBpbiBlcnJvciBoYW5kbGVyIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrQW5hbHl6ZXIuYW5hbHl6ZS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuYWx5emVyIGZhaWxlZCcpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGVycm9ySGFuZGxlclNlcnZpY2UuaGFuZGxlRXJyb3IoJ1Rlc3QgZXJyb3InKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5pc0ZhaWx1cmUpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yKS50b0NvbnRhaW4oJ0ZhaWxlZCB0byBoYW5kbGUgdGhlIGVycm9yIHByb3Blcmx5Jyk7XG4gICAgICBleHBlY3QoY29uc29sZUVycm9yU3B5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnRXJyb3IgaW4gZXJyb3IgaGFuZGxlcjonLCBleHBlY3QuYW55KEVycm9yKSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdtYXJrRXJyb3JSZXNvbHZlZCcsICgpID0+IHtcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIGVycm9ySGFuZGxlclNlcnZpY2UgPSBuZXcgRXJyb3JIYW5kbGVyU2VydmljZSgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0cmFjayByZXNvbHV0aW9uIHRpbWUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRXJyb3I6IEV4b2NvcnRleEVycm9yID0gY3JlYXRlTW9ja0V4b2NvcnRleEVycm9yKCk7XG4gICAgICBtb2NrQW5hbHl6ZXIuYW5hbHl6ZS5tb2NrUmV0dXJuVmFsdWUobW9ja0Vycm9yKTtcblxuICAgICAgLy8gSGFuZGxlIGVycm9yIGFuZCBtYXJrIGFzIHJlc29sdmVkXG4gICAgICBhd2FpdCBlcnJvckhhbmRsZXJTZXJ2aWNlLmhhbmRsZUVycm9yKCdUZXN0IGVycm9yJyk7XG4gICAgICBcbiAgICAgIC8vIEFkZCBhIHNtYWxsIGRlbGF5IHRvIGVuc3VyZSByZXNvbHV0aW9uIHRpbWUgPiAwXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMSkpO1xuICAgICAgXG4gICAgICBlcnJvckhhbmRsZXJTZXJ2aWNlLm1hcmtFcnJvclJlc29sdmVkKG1vY2tFcnJvci5pZCk7XG5cbiAgICAgIGNvbnN0IG1ldHJpY3MgPSBlcnJvckhhbmRsZXJTZXJ2aWNlLmdldE1ldHJpY3MoKTtcbiAgICAgIGV4cGVjdChtZXRyaWNzLmF2ZXJhZ2VSZXNvbHV0aW9uVGltZSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG5vbi1leGlzdGVudCBlcnJvciBJRCBncmFjZWZ1bGx5JywgKCkgPT4ge1xuICAgICAgZXhwZWN0KCgpID0+IHtcbiAgICAgICAgZXJyb3JIYW5kbGVyU2VydmljZS5tYXJrRXJyb3JSZXNvbHZlZCgnbm9uLWV4aXN0ZW50LWlkJyk7XG4gICAgICB9KS5ub3QudG9UaHJvdygpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBjYWxjdWxhdGUgYXZlcmFnZSByZXNvbHV0aW9uIHRpbWUgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0Vycm9yMTogRXhvY29ydGV4RXJyb3IgPSB7IC4uLmNyZWF0ZU1vY2tFeG9jb3J0ZXhFcnJvcigpLCBpZDogJ2Vycm9yMScgfTtcbiAgICAgIGNvbnN0IG1vY2tFcnJvcjI6IEV4b2NvcnRleEVycm9yID0geyAuLi5jcmVhdGVNb2NrRXhvY29ydGV4RXJyb3IoKSwgaWQ6ICdlcnJvcjInIH07XG4gICAgICBcbiAgICAgIG1vY2tBbmFseXplci5hbmFseXplLm1vY2tSZXR1cm5WYWx1ZU9uY2UobW9ja0Vycm9yMSkubW9ja1JldHVyblZhbHVlT25jZShtb2NrRXJyb3IyKTtcblxuICAgICAgYXdhaXQgZXJyb3JIYW5kbGVyU2VydmljZS5oYW5kbGVFcnJvcignRXJyb3IgMScpO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwKSk7IC8vIFNtYWxsIGRlbGF5XG4gICAgICBhd2FpdCBlcnJvckhhbmRsZXJTZXJ2aWNlLmhhbmRsZUVycm9yKCdFcnJvciAyJyk7XG5cbiAgICAgIGVycm9ySGFuZGxlclNlcnZpY2UubWFya0Vycm9yUmVzb2x2ZWQoJ2Vycm9yMScpO1xuICAgICAgZXJyb3JIYW5kbGVyU2VydmljZS5tYXJrRXJyb3JSZXNvbHZlZCgnZXJyb3IyJyk7XG5cbiAgICAgIGNvbnN0IG1ldHJpY3MgPSBlcnJvckhhbmRsZXJTZXJ2aWNlLmdldE1ldHJpY3MoKTtcbiAgICAgIGV4cGVjdChtZXRyaWNzLmF2ZXJhZ2VSZXNvbHV0aW9uVGltZSkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBsaW1pdCByZXNvbHV0aW9uIHRpbWUgaGlzdG9yeSB0byAxMDAgZW50cmllcycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSAxMDEgZXJyb3JzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG1vY2tFcnJvcjogRXhvY29ydGV4RXJyb3IgPSB7IC4uLmNyZWF0ZU1vY2tFeG9jb3J0ZXhFcnJvcigpLCBpZDogYGVycm9yJHtpfWAgfTtcbiAgICAgICAgbW9ja0FuYWx5emVyLmFuYWx5emUubW9ja1JldHVyblZhbHVlKG1vY2tFcnJvcik7XG4gICAgICAgIFxuICAgICAgICBhd2FpdCBlcnJvckhhbmRsZXJTZXJ2aWNlLmhhbmRsZUVycm9yKGBFcnJvciAke2l9YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgdGlueSBkZWxheSB0byBlbnN1cmUgcmVzb2x1dGlvbiB0aW1lID4gMFxuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGVycm9ySGFuZGxlclNlcnZpY2UubWFya0Vycm9yUmVzb2x2ZWQoYGVycm9yJHtpfWApO1xuICAgICAgfVxuXG4gICAgICAvLyBTaG91bGQgbWFpbnRhaW4gb25seSAxMDAgcmVzb2x1dGlvbiB0aW1lc1xuICAgICAgY29uc3QgbWV0cmljcyA9IGVycm9ySGFuZGxlclNlcnZpY2UuZ2V0TWV0cmljcygpO1xuICAgICAgZXhwZWN0KG1ldHJpY3MuYXZlcmFnZVJlc29sdXRpb25UaW1lKS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnbG9nZ2luZyBtZXRob2RzJywgKCkgPT4ge1xuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgZXJyb3JIYW5kbGVyU2VydmljZSA9IG5ldyBFcnJvckhhbmRsZXJTZXJ2aWNlKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGxvZyBjcml0aWNhbCBlcnJvcnMgdG8gY29uc29sZS5lcnJvcicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tFcnJvcjogRXhvY29ydGV4RXJyb3IgPSB7XG4gICAgICAgIC4uLmNyZWF0ZU1vY2tFeG9jb3J0ZXhFcnJvcigpLFxuICAgICAgICBzZXZlcml0eTogRXJyb3JTZXZlcml0eS5DUklUSUNBTFxuICAgICAgfTtcbiAgICAgIG1vY2tBbmFseXplci5hbmFseXplLm1vY2tSZXR1cm5WYWx1ZShtb2NrRXJyb3IpO1xuXG4gICAgICBhd2FpdCBlcnJvckhhbmRsZXJTZXJ2aWNlLmhhbmRsZUVycm9yKCdDcml0aWNhbCBlcnJvcicpO1xuXG4gICAgICBleHBlY3QoY29uc29sZUVycm9yU3B5KS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGxvZyB3YXJuaW5ncyB0byBjb25zb2xlLndhcm4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRXJyb3I6IEV4b2NvcnRleEVycm9yID0ge1xuICAgICAgICAuLi5jcmVhdGVNb2NrRXhvY29ydGV4RXJyb3IoKSxcbiAgICAgICAgc2V2ZXJpdHk6IEVycm9yU2V2ZXJpdHkuV0FSTklOR1xuICAgICAgfTtcbiAgICAgIG1vY2tBbmFseXplci5hbmFseXplLm1vY2tSZXR1cm5WYWx1ZShtb2NrRXJyb3IpO1xuXG4gICAgICBhd2FpdCBlcnJvckhhbmRsZXJTZXJ2aWNlLmhhbmRsZUVycm9yKCdXYXJuaW5nIGVycm9yJyk7XG5cbiAgICAgIGV4cGVjdChjb25zb2xlV2FyblNweSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBsb2cgaW5mbyBtZXNzYWdlcyB0byBjb25zb2xlLmluZm8nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRXJyb3I6IEV4b2NvcnRleEVycm9yID0ge1xuICAgICAgICAuLi5jcmVhdGVNb2NrRXhvY29ydGV4RXJyb3IoKSxcbiAgICAgICAgc2V2ZXJpdHk6IEVycm9yU2V2ZXJpdHkuSU5GT1xuICAgICAgfTtcbiAgICAgIG1vY2tBbmFseXplci5hbmFseXplLm1vY2tSZXR1cm5WYWx1ZShtb2NrRXJyb3IpO1xuXG4gICAgICBhd2FpdCBlcnJvckhhbmRsZXJTZXJ2aWNlLmhhbmRsZUVycm9yKCdJbmZvIG1lc3NhZ2UnKTtcblxuICAgICAgZXhwZWN0KGNvbnNvbGVJbmZvU3B5KS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGZvcm1hdCBlcnJvciBtZXNzYWdlIHdpdGggbG9jYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRXJyb3I6IEV4b2NvcnRleEVycm9yID0ge1xuICAgICAgICAuLi5jcmVhdGVNb2NrRXhvY29ydGV4RXJyb3IoKSxcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgIG9wZXJhdGlvbjogJ3Rlc3QnLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgICBsb2NhdGlvbjogeyBsaW5lOiA0MiwgY29sdW1uOiAxMCwgZmlsZTogJ3Rlc3Quc3BhcnFsJyB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBtb2NrQW5hbHl6ZXIuYW5hbHl6ZS5tb2NrUmV0dXJuVmFsdWUobW9ja0Vycm9yKTtcblxuICAgICAgYXdhaXQgZXJyb3JIYW5kbGVyU2VydmljZS5oYW5kbGVFcnJvcignRXJyb3Igd2l0aCBsb2NhdGlvbicpO1xuXG4gICAgICBleHBlY3QoY29uc29sZUVycm9yU3B5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJyhMaW5lIDQyOjEwKScpLFxuICAgICAgICBleHBlY3QuYW55KE9iamVjdClcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBzdHJpbmcgbG9jYXRpb24gY29udGV4dCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tFcnJvcjogRXhvY29ydGV4RXJyb3IgPSB7XG4gICAgICAgIC4uLmNyZWF0ZU1vY2tFeG9jb3J0ZXhFcnJvcigpLFxuICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgb3BlcmF0aW9uOiAndGVzdCcsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgIGxvY2F0aW9uOiAnU29tZSBsb2NhdGlvbiBzdHJpbmcnXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBtb2NrQW5hbHl6ZXIuYW5hbHl6ZS5tb2NrUmV0dXJuVmFsdWUobW9ja0Vycm9yKTtcblxuICAgICAgYXdhaXQgZXJyb3JIYW5kbGVyU2VydmljZS5oYW5kbGVFcnJvcignRXJyb3Igd2l0aCBzdHJpbmcgbG9jYXRpb24nKTtcblxuICAgICAgZXhwZWN0KGNvbnNvbGVFcnJvclNweSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgndXNlciBub3RpZmljYXRpb25zJywgKCkgPT4ge1xuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgZXJyb3JIYW5kbGVyU2VydmljZSA9IG5ldyBFcnJvckhhbmRsZXJTZXJ2aWNlKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHNob3cgbG9uZ2VyIG5vdGlmaWNhdGlvbiBmb3IgY3JpdGljYWwgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0Vycm9yOiBFeG9jb3J0ZXhFcnJvciA9IHtcbiAgICAgICAgLi4uY3JlYXRlTW9ja0V4b2NvcnRleEVycm9yKCksXG4gICAgICAgIHNldmVyaXR5OiBFcnJvclNldmVyaXR5LkNSSVRJQ0FMXG4gICAgICB9O1xuICAgICAgbW9ja0FuYWx5emVyLmFuYWx5emUubW9ja1JldHVyblZhbHVlKG1vY2tFcnJvcik7XG5cbiAgICAgIGF3YWl0IGVycm9ySGFuZGxlclNlcnZpY2UuaGFuZGxlRXJyb3IoJ0NyaXRpY2FsIGVycm9yJyk7XG5cbiAgICAgIGV4cGVjdChtb2NrTm90aWNlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3QuYW55KFN0cmluZyksIDEwMDAwKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc2hvdyBzaG9ydGVyIG5vdGlmaWNhdGlvbiBmb3IgaW5mbyBtZXNzYWdlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tFcnJvcjogRXhvY29ydGV4RXJyb3IgPSB7XG4gICAgICAgIC4uLmNyZWF0ZU1vY2tFeG9jb3J0ZXhFcnJvcigpLFxuICAgICAgICBzZXZlcml0eTogRXJyb3JTZXZlcml0eS5JTkZPXG4gICAgICB9O1xuICAgICAgbW9ja0FuYWx5emVyLmFuYWx5emUubW9ja1JldHVyblZhbHVlKG1vY2tFcnJvcik7XG5cbiAgICAgIGF3YWl0IGVycm9ySGFuZGxlclNlcnZpY2UuaGFuZGxlRXJyb3IoJ0luZm8gbWVzc2FnZScpO1xuXG4gICAgICBleHBlY3QobW9ja05vdGljZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0LmFueShTdHJpbmcpLCAzMDAwKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaW5jbHVkZSBzdWdnZXN0aW9uIGluIG5vdGlmaWNhdGlvbiBtZXNzYWdlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1N1Z2dlc3Rpb246IEZpeFN1Z2dlc3Rpb24gPSB7XG4gICAgICAgIHRpdGxlOiAnUXVpY2sgRml4JyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdUcnkgdGhpcyBzb2x1dGlvbidcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IG1vY2tFcnJvcjogRXhvY29ydGV4RXJyb3IgPSB7XG4gICAgICAgIC4uLmNyZWF0ZU1vY2tFeG9jb3J0ZXhFcnJvcigpLFxuICAgICAgICBzdWdnZXN0aW9uczogW21vY2tTdWdnZXN0aW9uXVxuICAgICAgfTtcbiAgICAgIG1vY2tBbmFseXplci5hbmFseXplLm1vY2tSZXR1cm5WYWx1ZShtb2NrRXJyb3IpO1xuXG4gICAgICBhd2FpdCBlcnJvckhhbmRsZXJTZXJ2aWNlLmhhbmRsZUVycm9yKCdFcnJvciB3aXRoIHN1Z2dlc3Rpb24nKTtcblxuICAgICAgZXhwZWN0KG1vY2tOb3RpY2UpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygn8J+SoSBRdWljayBGaXgnKSxcbiAgICAgICAgZXhwZWN0LmFueShOdW1iZXIpXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZXJyb3Igd2l0aG91dCBzdWdnZXN0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tFcnJvcjogRXhvY29ydGV4RXJyb3IgPSB7XG4gICAgICAgIC4uLmNyZWF0ZU1vY2tFeG9jb3J0ZXhFcnJvcigpLFxuICAgICAgICBzdWdnZXN0aW9uczogW11cbiAgICAgIH07XG4gICAgICBtb2NrQW5hbHl6ZXIuYW5hbHl6ZS5tb2NrUmV0dXJuVmFsdWUobW9ja0Vycm9yKTtcblxuICAgICAgYXdhaXQgZXJyb3JIYW5kbGVyU2VydmljZS5oYW5kbGVFcnJvcignRXJyb3Igd2l0aG91dCBzdWdnZXN0aW9ucycpO1xuXG4gICAgICBleHBlY3QobW9ja05vdGljZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5ub3Quc3RyaW5nQ29udGFpbmluZygn8J+SoScpLFxuICAgICAgICBleHBlY3QuYW55KE51bWJlcilcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdlcnJvciBoaXN0b3J5IG1hbmFnZW1lbnQnLCAoKSA9PiB7XG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBlcnJvckhhbmRsZXJTZXJ2aWNlID0gbmV3IEVycm9ySGFuZGxlclNlcnZpY2UoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbWFpbnRhaW4gZXJyb3IgaGlzdG9yeSBpbiBMSUZPIG9yZGVyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0Vycm9yMTogRXhvY29ydGV4RXJyb3IgPSB7IC4uLmNyZWF0ZU1vY2tFeG9jb3J0ZXhFcnJvcigpLCBpZDogJ2Vycm9yMScsIHRpdGxlOiAnRmlyc3QgRXJyb3InIH07XG4gICAgICBjb25zdCBtb2NrRXJyb3IyOiBFeG9jb3J0ZXhFcnJvciA9IHsgLi4uY3JlYXRlTW9ja0V4b2NvcnRleEVycm9yKCksIGlkOiAnZXJyb3IyJywgdGl0bGU6ICdTZWNvbmQgRXJyb3InIH07XG4gICAgICBcbiAgICAgIG1vY2tBbmFseXplci5hbmFseXplLm1vY2tSZXR1cm5WYWx1ZU9uY2UobW9ja0Vycm9yMSkubW9ja1JldHVyblZhbHVlT25jZShtb2NrRXJyb3IyKTtcblxuICAgICAgYXdhaXQgZXJyb3JIYW5kbGVyU2VydmljZS5oYW5kbGVFcnJvcignRmlyc3QgZXJyb3InKTtcbiAgICAgIGF3YWl0IGVycm9ySGFuZGxlclNlcnZpY2UuaGFuZGxlRXJyb3IoJ1NlY29uZCBlcnJvcicpO1xuXG4gICAgICBjb25zdCBoaXN0b3J5ID0gZXJyb3JIYW5kbGVyU2VydmljZS5nZXRFcnJvckhpc3RvcnkoKTtcbiAgICAgIGV4cGVjdChoaXN0b3J5WzBdLnRpdGxlKS50b0JlKCdTZWNvbmQgRXJyb3InKTtcbiAgICAgIGV4cGVjdChoaXN0b3J5WzFdLnRpdGxlKS50b0JlKCdGaXJzdCBFcnJvcicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBsaW1pdCBoaXN0b3J5IHRvIG1heGltdW0gc2l6ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFkZCAxMDEgZXJyb3JzIHRvIGV4Y2VlZCB0aGUgbGltaXRcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTAxOyBpKyspIHtcbiAgICAgICAgY29uc3QgbW9ja0Vycm9yOiBFeG9jb3J0ZXhFcnJvciA9IHsgLi4uY3JlYXRlTW9ja0V4b2NvcnRleEVycm9yKCksIGlkOiBgZXJyb3Ike2l9YCB9O1xuICAgICAgICBtb2NrQW5hbHl6ZXIuYW5hbHl6ZS5tb2NrUmV0dXJuVmFsdWUobW9ja0Vycm9yKTtcbiAgICAgICAgYXdhaXQgZXJyb3JIYW5kbGVyU2VydmljZS5oYW5kbGVFcnJvcihgRXJyb3IgJHtpfWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBoaXN0b3J5ID0gZXJyb3JIYW5kbGVyU2VydmljZS5nZXRFcnJvckhpc3RvcnkoKTtcbiAgICAgIGV4cGVjdChoaXN0b3J5KS50b0hhdmVMZW5ndGgoMTAwKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY2xlYXIgaGlzdG9yeSBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRXJyb3I6IEV4b2NvcnRleEVycm9yID0gY3JlYXRlTW9ja0V4b2NvcnRleEVycm9yKCk7XG4gICAgICBtb2NrQW5hbHl6ZXIuYW5hbHl6ZS5tb2NrUmV0dXJuVmFsdWUobW9ja0Vycm9yKTtcblxuICAgICAgYXdhaXQgZXJyb3JIYW5kbGVyU2VydmljZS5oYW5kbGVFcnJvcignVGVzdCBlcnJvcicpO1xuICAgICAgZXhwZWN0KGVycm9ySGFuZGxlclNlcnZpY2UuZ2V0RXJyb3JIaXN0b3J5KCkpLnRvSGF2ZUxlbmd0aCgxKTtcblxuICAgICAgZXJyb3JIYW5kbGVyU2VydmljZS5jbGVhckhpc3RvcnkoKTtcbiAgICAgIGV4cGVjdChlcnJvckhhbmRsZXJTZXJ2aWNlLmdldEVycm9ySGlzdG9yeSgpKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNsZWFyIGVycm9yIHN0YXJ0IHRpbWVzIHdoZW4gY2xlYXJpbmcgaGlzdG9yeScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tFcnJvcjogRXhvY29ydGV4RXJyb3IgPSBjcmVhdGVNb2NrRXhvY29ydGV4RXJyb3IoKTtcbiAgICAgIG1vY2tBbmFseXplci5hbmFseXplLm1vY2tSZXR1cm5WYWx1ZShtb2NrRXJyb3IpO1xuXG4gICAgICBhd2FpdCBlcnJvckhhbmRsZXJTZXJ2aWNlLmhhbmRsZUVycm9yKCdUZXN0IGVycm9yJyk7XG4gICAgICBlcnJvckhhbmRsZXJTZXJ2aWNlLmNsZWFySGlzdG9yeSgpO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgbm90IHRocm93IHdoZW4gdHJ5aW5nIHRvIG1hcmsgcmVzb2x2ZWQgYWZ0ZXIgY2xlYXJcbiAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgIGVycm9ySGFuZGxlclNlcnZpY2UubWFya0Vycm9yUmVzb2x2ZWQobW9ja0Vycm9yLmlkKTtcbiAgICAgIH0pLm5vdC50b1Rocm93KCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdnZXRTdWdnZXN0aW9ucycsICgpID0+IHtcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIGVycm9ySGFuZGxlclNlcnZpY2UgPSBuZXcgRXJyb3JIYW5kbGVyU2VydmljZSgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gc3VnZ2VzdGlvbnMgZm9yIHN0cmluZyBlcnJvcicsICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTdWdnZXN0aW9uczogRml4U3VnZ2VzdGlvbltdID0gW1xuICAgICAgICB7IHRpdGxlOiAnRml4IDEnLCBkZXNjcmlwdGlvbjogJ0ZpcnN0IGZpeCcgfSxcbiAgICAgICAgeyB0aXRsZTogJ0ZpeCAyJywgZGVzY3JpcHRpb246ICdTZWNvbmQgZml4JyB9XG4gICAgICBdO1xuICAgICAgXG4gICAgICBjb25zdCBtb2NrRXJyb3I6IEV4b2NvcnRleEVycm9yID0ge1xuICAgICAgICAuLi5jcmVhdGVNb2NrRXhvY29ydGV4RXJyb3IoKSxcbiAgICAgICAgc3VnZ2VzdGlvbnM6IG1vY2tTdWdnZXN0aW9uc1xuICAgICAgfTtcbiAgICAgIG1vY2tBbmFseXplci5hbmFseXplLm1vY2tSZXR1cm5WYWx1ZShtb2NrRXJyb3IpO1xuXG4gICAgICBjb25zdCBzdWdnZXN0aW9ucyA9IGVycm9ySGFuZGxlclNlcnZpY2UuZ2V0U3VnZ2VzdGlvbnMoJ1Rlc3QgZXJyb3InKTtcblxuICAgICAgZXhwZWN0KHN1Z2dlc3Rpb25zKS50b0VxdWFsKG1vY2tTdWdnZXN0aW9ucyk7XG4gICAgICBleHBlY3QobW9ja0FuYWx5emVyLmFuYWx5emUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdUZXN0IGVycm9yJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBzdWdnZXN0aW9ucyBmb3IgRXJyb3Igb2JqZWN0JywgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1N1Z2dlc3Rpb25zOiBGaXhTdWdnZXN0aW9uW10gPSBbXG4gICAgICAgIHsgdGl0bGU6ICdFcnJvciBGaXgnLCBkZXNjcmlwdGlvbjogJ0ZpeCBmb3IgZXJyb3Igb2JqZWN0JyB9XG4gICAgICBdO1xuICAgICAgXG4gICAgICBjb25zdCBtb2NrRXJyb3I6IEV4b2NvcnRleEVycm9yID0ge1xuICAgICAgICAuLi5jcmVhdGVNb2NrRXhvY29ydGV4RXJyb3IoKSxcbiAgICAgICAgc3VnZ2VzdGlvbnM6IG1vY2tTdWdnZXN0aW9uc1xuICAgICAgfTtcbiAgICAgIG1vY2tBbmFseXplci5hbmFseXplLm1vY2tSZXR1cm5WYWx1ZShtb2NrRXJyb3IpO1xuICAgICAgXG4gICAgICBjb25zdCBlcnJvck9iamVjdCA9IG5ldyBFcnJvcignVGVzdCBlcnJvciBvYmplY3QnKTtcbiAgICAgIGNvbnN0IHN1Z2dlc3Rpb25zID0gZXJyb3JIYW5kbGVyU2VydmljZS5nZXRTdWdnZXN0aW9ucyhlcnJvck9iamVjdCk7XG5cbiAgICAgIGV4cGVjdChzdWdnZXN0aW9ucykudG9FcXVhbChtb2NrU3VnZ2VzdGlvbnMpO1xuICAgICAgZXhwZWN0KG1vY2tBbmFseXplci5hbmFseXplKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChlcnJvck9iamVjdCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBlbXB0eSBhcnJheSB3aGVuIG5vIHN1Z2dlc3Rpb25zIGF2YWlsYWJsZScsICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tFcnJvcjogRXhvY29ydGV4RXJyb3IgPSB7XG4gICAgICAgIC4uLmNyZWF0ZU1vY2tFeG9jb3J0ZXhFcnJvcigpLFxuICAgICAgICBzdWdnZXN0aW9uczogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgICAgbW9ja0FuYWx5emVyLmFuYWx5emUubW9ja1JldHVyblZhbHVlKG1vY2tFcnJvcik7XG5cbiAgICAgIGNvbnN0IHN1Z2dlc3Rpb25zID0gZXJyb3JIYW5kbGVyU2VydmljZS5nZXRTdWdnZXN0aW9ucygnRXJyb3Igd2l0aG91dCBzdWdnZXN0aW9ucycpO1xuXG4gICAgICBleHBlY3Qoc3VnZ2VzdGlvbnMpLnRvRXF1YWwoW10pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnYW5hbHl6ZUVycm9yJywgKCkgPT4ge1xuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgZXJyb3JIYW5kbGVyU2VydmljZSA9IG5ldyBFcnJvckhhbmRsZXJTZXJ2aWNlKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBhbmFseXplZCBFeG9jb3J0ZXhFcnJvciBmb3Igc3RyaW5nJywgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0Vycm9yOiBFeG9jb3J0ZXhFcnJvciA9IGNyZWF0ZU1vY2tFeG9jb3J0ZXhFcnJvcigpO1xuICAgICAgbW9ja0FuYWx5emVyLmFuYWx5emUubW9ja1JldHVyblZhbHVlKG1vY2tFcnJvcik7XG5cbiAgICAgIGNvbnN0IGFuYWx5emVkID0gZXJyb3JIYW5kbGVyU2VydmljZS5hbmFseXplRXJyb3IoJ1Rlc3QgZXJyb3InKTtcblxuICAgICAgZXhwZWN0KGFuYWx5emVkKS50b0VxdWFsKG1vY2tFcnJvcik7XG4gICAgICBleHBlY3QobW9ja0FuYWx5emVyLmFuYWx5emUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdUZXN0IGVycm9yJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBhbmFseXplZCBFeG9jb3J0ZXhFcnJvciBmb3IgRXJyb3Igb2JqZWN0JywgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0Vycm9yOiBFeG9jb3J0ZXhFcnJvciA9IGNyZWF0ZU1vY2tFeG9jb3J0ZXhFcnJvcigpO1xuICAgICAgbW9ja0FuYWx5emVyLmFuYWx5emUubW9ja1JldHVyblZhbHVlKG1vY2tFcnJvcik7XG4gICAgICBcbiAgICAgIGNvbnN0IGVycm9yT2JqZWN0ID0gbmV3IEVycm9yKCdUZXN0IGVycm9yIG9iamVjdCcpO1xuICAgICAgY29uc3QgYW5hbHl6ZWQgPSBlcnJvckhhbmRsZXJTZXJ2aWNlLmFuYWx5emVFcnJvcihlcnJvck9iamVjdCk7XG5cbiAgICAgIGV4cGVjdChhbmFseXplZCkudG9FcXVhbChtb2NrRXJyb3IpO1xuICAgICAgZXhwZWN0KG1vY2tBbmFseXplci5hbmFseXplKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChlcnJvck9iamVjdCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdyZWNvdmVyeSBtZWNoYW5pc20nLCAoKSA9PiB7XG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBlcnJvckhhbmRsZXJTZXJ2aWNlID0gbmV3IEVycm9ySGFuZGxlclNlcnZpY2UoeyBhdXRvUmVjb3ZlcjogdHJ1ZSB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbm90IGF0dGVtcHQgcmVjb3ZlcnkgZm9yIG5vbi1yZWNvdmVyYWJsZSBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrU3VnZ2VzdGlvbjogRml4U3VnZ2VzdGlvbiA9IHtcbiAgICAgICAgdGl0bGU6ICdNYW51YWwgRml4JyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdSZXF1aXJlcyBtYW51YWwgaW50ZXJ2ZW50aW9uJyxcbiAgICAgICAgY29uZmlkZW5jZTogMC45NSxcbiAgICAgICAgYWN0aW9uOiB7XG4gICAgICAgICAgbGFiZWw6ICdBcHBseScsXG4gICAgICAgICAgaGFuZGxlcjogamVzdC5mbigpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IG1vY2tFcnJvcjogRXhvY29ydGV4RXJyb3IgPSB7XG4gICAgICAgIC4uLmNyZWF0ZU1vY2tFeG9jb3J0ZXhFcnJvcigpLFxuICAgICAgICByZWNvdmVyYWJsZTogZmFsc2UsXG4gICAgICAgIHN1Z2dlc3Rpb25zOiBbbW9ja1N1Z2dlc3Rpb25dXG4gICAgICB9O1xuICAgICAgbW9ja0FuYWx5emVyLmFuYWx5emUubW9ja1JldHVyblZhbHVlKG1vY2tFcnJvcik7XG5cbiAgICAgIGF3YWl0IGVycm9ySGFuZGxlclNlcnZpY2UuaGFuZGxlRXJyb3IoJ05vbi1yZWNvdmVyYWJsZSBlcnJvcicpO1xuXG4gICAgICBleHBlY3QobW9ja1N1Z2dlc3Rpb24uYWN0aW9uIS5oYW5kbGVyKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBub3QgYXR0ZW1wdCByZWNvdmVyeSBmb3IgbG93LWNvbmZpZGVuY2Ugc3VnZ2VzdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrU3VnZ2VzdGlvbjogRml4U3VnZ2VzdGlvbiA9IHtcbiAgICAgICAgdGl0bGU6ICdVbmNlcnRhaW4gRml4JyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdMb3cgY29uZmlkZW5jZSBmaXgnLFxuICAgICAgICBjb25maWRlbmNlOiAwLjUsXG4gICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgIGxhYmVsOiAnVHJ5JyxcbiAgICAgICAgICBoYW5kbGVyOiBqZXN0LmZuKClcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgbW9ja0Vycm9yOiBFeG9jb3J0ZXhFcnJvciA9IHtcbiAgICAgICAgLi4uY3JlYXRlTW9ja0V4b2NvcnRleEVycm9yKCksXG4gICAgICAgIHJlY292ZXJhYmxlOiB0cnVlLFxuICAgICAgICBzdWdnZXN0aW9uczogW21vY2tTdWdnZXN0aW9uXVxuICAgICAgfTtcbiAgICAgIG1vY2tBbmFseXplci5hbmFseXplLm1vY2tSZXR1cm5WYWx1ZShtb2NrRXJyb3IpO1xuXG4gICAgICBhd2FpdCBlcnJvckhhbmRsZXJTZXJ2aWNlLmhhbmRsZUVycm9yKCdMb3cgY29uZmlkZW5jZSBlcnJvcicpO1xuXG4gICAgICBleHBlY3QobW9ja1N1Z2dlc3Rpb24uYWN0aW9uIS5oYW5kbGVyKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgcmVjb3ZlcnkgZmFpbHVyZSBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1N1Z2dlc3Rpb246IEZpeFN1Z2dlc3Rpb24gPSB7XG4gICAgICAgIHRpdGxlOiAnRmFpbGluZyBGaXgnLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1RoaXMgZml4IHdpbGwgZmFpbCcsXG4gICAgICAgIGNvbmZpZGVuY2U6IDAuOTUsXG4gICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgIGxhYmVsOiAnQXBwbHknLFxuICAgICAgICAgIGhhbmRsZXI6IGplc3QuZm4oKS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ1JlY292ZXJ5IGZhaWxlZCcpKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCBtb2NrRXJyb3I6IEV4b2NvcnRleEVycm9yID0ge1xuICAgICAgICAuLi5jcmVhdGVNb2NrRXhvY29ydGV4RXJyb3IoKSxcbiAgICAgICAgcmVjb3ZlcmFibGU6IHRydWUsXG4gICAgICAgIHN1Z2dlc3Rpb25zOiBbbW9ja1N1Z2dlc3Rpb25dXG4gICAgICB9O1xuICAgICAgbW9ja0FuYWx5emVyLmFuYWx5emUubW9ja1JldHVyblZhbHVlKG1vY2tFcnJvcik7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGVycm9ySGFuZGxlclNlcnZpY2UuaGFuZGxlRXJyb3IoJ0ZhaWxpbmcgcmVjb3ZlcnkgZXJyb3InKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7IC8vIE1haW4gZXJyb3IgaGFuZGxpbmcgc2hvdWxkIHN0aWxsIHN1Y2NlZWRcbiAgICAgIGV4cGVjdChjb25zb2xlRXJyb3JTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdBdXRvLXJlY292ZXJ5IGZhaWxlZDonLCBleHBlY3QuYW55KEVycm9yKSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHNob3cgcmVjb3Zlcnkgbm90aWZpY2F0aW9uIG9uIHN1Y2Nlc3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrU3VnZ2VzdGlvbjogRml4U3VnZ2VzdGlvbiA9IHtcbiAgICAgICAgdGl0bGU6ICdTdWNjZXNzZnVsIEZpeCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnVGhpcyBmaXggd2lsbCBzdWNjZWVkJyxcbiAgICAgICAgY29uZmlkZW5jZTogMC45NSxcbiAgICAgICAgYWN0aW9uOiB7XG4gICAgICAgICAgbGFiZWw6ICdBcHBseScsXG4gICAgICAgICAgaGFuZGxlcjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZClcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgbW9ja0Vycm9yOiBFeG9jb3J0ZXhFcnJvciA9IHtcbiAgICAgICAgLi4uY3JlYXRlTW9ja0V4b2NvcnRleEVycm9yKCksXG4gICAgICAgIHJlY292ZXJhYmxlOiB0cnVlLFxuICAgICAgICBzdWdnZXN0aW9uczogW21vY2tTdWdnZXN0aW9uXVxuICAgICAgfTtcbiAgICAgIG1vY2tBbmFseXplci5hbmFseXplLm1vY2tSZXR1cm5WYWx1ZShtb2NrRXJyb3IpO1xuXG4gICAgICBhd2FpdCBlcnJvckhhbmRsZXJTZXJ2aWNlLmhhbmRsZUVycm9yKCdSZWNvdmVyYWJsZSBlcnJvcicpO1xuXG4gICAgICBleHBlY3QobW9ja05vdGljZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ0F1dG8tcmVjb3Zlcnk6IFN1Y2Nlc3NmdWwgRml4JywgMzAwMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdlZGdlIGNhc2VzIGFuZCBib3VuZGFyeSBjb25kaXRpb25zJywgKCkgPT4ge1xuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgZXJyb3JIYW5kbGVyU2VydmljZSA9IG5ldyBFcnJvckhhbmRsZXJTZXJ2aWNlKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBlbXB0eSBzdHJpbmcgZXJyb3InLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrRXJyb3I6IEV4b2NvcnRleEVycm9yID0gY3JlYXRlTW9ja0V4b2NvcnRleEVycm9yKCk7XG4gICAgICBtb2NrQW5hbHl6ZXIuYW5hbHl6ZS5tb2NrUmV0dXJuVmFsdWUobW9ja0Vycm9yKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXJyb3JIYW5kbGVyU2VydmljZS5oYW5kbGVFcnJvcignJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuaXNTdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KG1vY2tBbmFseXplci5hbmFseXplKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBudWxsIGNvbnRleHQgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tFcnJvcjogRXhvY29ydGV4RXJyb3IgPSBjcmVhdGVNb2NrRXhvY29ydGV4RXJyb3IoKTtcbiAgICAgIG1vY2tBbmFseXplci5hbmFseXplLm1vY2tSZXR1cm5WYWx1ZShtb2NrRXJyb3IpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBlcnJvckhhbmRsZXJTZXJ2aWNlLmhhbmRsZUVycm9yKCdUZXN0IGVycm9yJywgbnVsbCBhcyBhbnkpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmlzU3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHVuZGVmaW5lZCBzdWdnZXN0aW9ucyBhcnJheScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tFcnJvcjogRXhvY29ydGV4RXJyb3IgPSB7XG4gICAgICAgIC4uLmNyZWF0ZU1vY2tFeG9jb3J0ZXhFcnJvcigpLFxuICAgICAgICBzdWdnZXN0aW9uczogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgICAgbW9ja0FuYWx5emVyLmFuYWx5emUubW9ja1JldHVyblZhbHVlKG1vY2tFcnJvcik7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGVycm9ySGFuZGxlclNlcnZpY2UuaGFuZGxlRXJyb3IoJ0Vycm9yIHdpdGhvdXQgc3VnZ2VzdGlvbnMnKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBlcnJvciB3aXRoIG51bGwgYWN0aW9uIGluIHN1Z2dlc3Rpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrU3VnZ2VzdGlvbjogRml4U3VnZ2VzdGlvbiA9IHtcbiAgICAgICAgdGl0bGU6ICdObyBBY3Rpb24gRml4JyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdTdWdnZXN0aW9uIHdpdGhvdXQgYWN0aW9uJyxcbiAgICAgICAgY29uZmlkZW5jZTogMC45NSxcbiAgICAgICAgYWN0aW9uOiBudWxsIGFzIGFueVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgbW9ja0Vycm9yOiBFeG9jb3J0ZXhFcnJvciA9IHtcbiAgICAgICAgLi4uY3JlYXRlTW9ja0V4b2NvcnRleEVycm9yKCksXG4gICAgICAgIHJlY292ZXJhYmxlOiB0cnVlLFxuICAgICAgICBzdWdnZXN0aW9uczogW21vY2tTdWdnZXN0aW9uXVxuICAgICAgfTtcbiAgICAgIG1vY2tBbmFseXplci5hbmFseXplLm1vY2tSZXR1cm5WYWx1ZShtb2NrRXJyb3IpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBlcnJvckhhbmRsZXJTZXJ2aWNlLmhhbmRsZUVycm9yKCdFcnJvciB3aXRoIG51bGwgYWN0aW9uJyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuaXNTdWNjZXNzKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgdmVyeSBsYXJnZSBlcnJvciBtZXNzYWdlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGxhcmdlTWVzc2FnZSA9ICdMYXJnZSBlcnJvciBtZXNzYWdlOiAnICsgJ3gnLnJlcGVhdCgxMDAwMCk7XG4gICAgICBjb25zdCBtb2NrRXJyb3I6IEV4b2NvcnRleEVycm9yID0ge1xuICAgICAgICAuLi5jcmVhdGVNb2NrRXhvY29ydGV4RXJyb3IoKSxcbiAgICAgICAgbWVzc2FnZTogbGFyZ2VNZXNzYWdlXG4gICAgICB9O1xuICAgICAgbW9ja0FuYWx5emVyLmFuYWx5emUubW9ja1JldHVyblZhbHVlKG1vY2tFcnJvcik7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGVycm9ySGFuZGxlclNlcnZpY2UuaGFuZGxlRXJyb3IobGFyZ2VNZXNzYWdlKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5pc1N1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgbW9jayBFeG9jb3J0ZXhFcnJvclxuICBmdW5jdGlvbiBjcmVhdGVNb2NrRXhvY29ydGV4RXJyb3IoKTogRXhvY29ydGV4RXJyb3Ige1xuICAgIHJldHVybiB7XG4gICAgICBpZDogJ3Rlc3QtZXJyb3ItaWQnLFxuICAgICAgc2V2ZXJpdHk6IEVycm9yU2V2ZXJpdHkuRVJST1IsXG4gICAgICBjYXRlZ29yeTogRXJyb3JDYXRlZ29yeS5WQUxJREFUSU9OLFxuICAgICAgdGl0bGU6ICdUZXN0IEVycm9yJyxcbiAgICAgIG1lc3NhZ2U6ICdUaGlzIGlzIGEgdGVzdCBlcnJvciBtZXNzYWdlJyxcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgb3BlcmF0aW9uOiAndGVzdC1vcGVyYXRpb24nLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKClcbiAgICAgIH0sXG4gICAgICByZWNvdmVyYWJsZTogZmFsc2VcbiAgICB9O1xuICB9XG59KTsiXSwidmVyc2lvbiI6M30=