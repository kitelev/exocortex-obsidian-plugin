eaec08c03718878b72980428753a527a
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const obsidian_1 = require("obsidian");
const ObsidianOntologyRepository_1 = require("../../../../src/infrastructure/repositories/ObsidianOntologyRepository");
const Ontology_1 = require("../../../../src/domain/entities/Ontology");
const OntologyPrefix_1 = require("../../../../src/domain/value-objects/OntologyPrefix");
describe('ObsidianOntologyRepository', () => {
    let repository;
    let mockApp;
    let mockVault;
    let mockMetadataCache;
    beforeEach(() => {
        // Create mock app with vault and metadata cache
        mockVault = {
            getAbstractFileByPath: jest.fn(),
            getMarkdownFiles: jest.fn(),
            create: jest.fn(),
            modify: jest.fn()
        };
        mockMetadataCache = {
            getFileCache: jest.fn()
        };
        mockApp = {
            vault: mockVault,
            metadataCache: mockMetadataCache
        };
        repository = new ObsidianOntologyRepository_1.ObsidianOntologyRepository(mockApp);
    });
    afterEach(() => {
        jest.clearAllMocks();
    });
    describe('Constructor and Initialization', () => {
        it('should initialize with app reference', () => {
            expect(repository).toBeInstanceOf(ObsidianOntologyRepository_1.ObsidianOntologyRepository);
        });
        it('should handle null app gracefully', () => {
            expect(() => new ObsidianOntologyRepository_1.ObsidianOntologyRepository(null)).not.toThrow();
        });
    });
    describe('findByPrefix', () => {
        const mockPrefix = OntologyPrefix_1.OntologyPrefix.create('test').getValue();
        const mockFile = new obsidian_1.TFile('!test.md');
        beforeEach(() => {
            // Mock Ontology.fromFrontmatter static method
            jest.spyOn(Ontology_1.Ontology, 'fromFrontmatter').mockImplementation((frontmatter) => {
                return {
                    getPrefix: () => mockPrefix,
                    getNamespace: () => 'http://example.org/test#',
                    getClasses: () => [],
                    getProperties: () => []
                };
            });
        });
        it('should find ontology by prefix when file exists', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockFrontmatter = {
                'exo__Ontology_prefix': 'test',
                'exo__Ontology_namespace': 'http://example.org/test#'
            };
            mockVault.getAbstractFileByPath.mockReturnValue(mockFile);
            mockMetadataCache.getFileCache.mockReturnValue({
                frontmatter: mockFrontmatter
            });
            const result = yield repository.findByPrefix(mockPrefix);
            expect(mockVault.getAbstractFileByPath).toHaveBeenCalledWith('!test.md');
            expect(mockMetadataCache.getFileCache).toHaveBeenCalledWith(mockFile);
            expect(result).toBeDefined();
            expect(Ontology_1.Ontology.fromFrontmatter).toHaveBeenCalledWith(mockFrontmatter);
        }));
        it('should return null when file does not exist', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            mockVault.getAbstractFileByPath.mockReturnValue(null);
            const result = yield repository.findByPrefix(mockPrefix);
            expect(result).toBeNull();
            expect(mockMetadataCache.getFileCache).not.toHaveBeenCalled();
        }));
        it('should return null when file exists but has no frontmatter', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            mockVault.getAbstractFileByPath.mockReturnValue(mockFile);
            mockMetadataCache.getFileCache.mockReturnValue({});
            const result = yield repository.findByPrefix(mockPrefix);
            expect(result).toBeNull();
        }));
        it('should return null when file cache is null', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            mockVault.getAbstractFileByPath.mockReturnValue(mockFile);
            mockMetadataCache.getFileCache.mockReturnValue(null);
            const result = yield repository.findByPrefix(mockPrefix);
            expect(result).toBeNull();
        }));
        it('should handle non-TFile return from getAbstractFileByPath', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockFolder = { name: '!test.md' }; // Not a TFile
            mockVault.getAbstractFileByPath.mockReturnValue(mockFolder);
            const result = yield repository.findByPrefix(mockPrefix);
            expect(result).toBeNull();
        }));
        it('should handle fromFrontmatter errors gracefully', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            mockVault.getAbstractFileByPath.mockReturnValue(mockFile);
            mockMetadataCache.getFileCache.mockReturnValue({ frontmatter: {} });
            jest.spyOn(Ontology_1.Ontology, 'fromFrontmatter').mockImplementation(() => {
                throw new Error('Invalid frontmatter');
            });
            yield expect(repository.findByPrefix(mockPrefix)).rejects.toThrow('Invalid frontmatter');
        }));
    });
    describe('findAll', () => {
        beforeEach(() => {
            jest.spyOn(Ontology_1.Ontology, 'fromFrontmatter').mockImplementation((frontmatter) => ({
                getPrefix: () => OntologyPrefix_1.OntologyPrefix.create(frontmatter['exo__Ontology_prefix']).getValue(),
                getNamespace: () => frontmatter['exo__Ontology_namespace'],
                getClasses: () => [],
                getProperties: () => []
            }));
        });
        it('should return all ontology files', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockFiles = [
                { name: '!test1.md', path: '!test1.md' },
                { name: '!test2.md', path: '!test2.md' },
                { name: 'regular-file.md', path: 'regular-file.md' },
                { name: '!test3.md', path: '!test3.md' }
            ];
            mockVault.getMarkdownFiles.mockReturnValue(mockFiles);
            // Mock metadata cache responses
            mockMetadataCache.getFileCache.mockImplementation((file) => {
                if (file.name.startsWith('!')) {
                    return {
                        frontmatter: {
                            'exo__Ontology_prefix': file.name.replace('!', '').replace('.md', ''),
                            'exo__Ontology_namespace': `http://example.org/${file.name.replace('!', '').replace('.md', '')}#`
                        }
                    };
                }
                return {};
            });
            const result = yield repository.findAll();
            expect(result).toHaveLength(3); // Only the files starting with '!'
            expect(mockVault.getMarkdownFiles).toHaveBeenCalled();
        }));
        it('should return empty array when no ontology files exist', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            mockVault.getMarkdownFiles.mockReturnValue([]);
            const result = yield repository.findAll();
            expect(result).toEqual([]);
        }));
        it('should filter out files without ontology prefix in frontmatter', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockFiles = [
                { name: '!valid.md', path: '!valid.md' },
                { name: '!invalid.md', path: '!invalid.md' }
            ];
            mockVault.getMarkdownFiles.mockReturnValue(mockFiles);
            mockMetadataCache.getFileCache.mockImplementation((file) => {
                if (file.name === '!valid.md') {
                    return {
                        frontmatter: {
                            'exo__Ontology_prefix': 'valid',
                            'exo__Ontology_namespace': 'http://example.org/valid#'
                        }
                    };
                }
                // Invalid file has no ontology prefix
                return { frontmatter: {} };
            });
            const result = yield repository.findAll();
            expect(result).toHaveLength(1);
        }));
        it('should handle missing frontmatter gracefully', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockFiles = [{ name: '!test.md', path: '!test.md' }];
            mockVault.getMarkdownFiles.mockReturnValue(mockFiles);
            mockMetadataCache.getFileCache.mockReturnValue(null);
            const result = yield repository.findAll();
            expect(result).toEqual([]);
        }));
        it('should handle fromFrontmatter errors gracefully', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockFiles = [{ name: '!test.md', path: '!test.md' }];
            mockVault.getMarkdownFiles.mockReturnValue(mockFiles);
            mockMetadataCache.getFileCache.mockReturnValue({
                frontmatter: { 'exo__Ontology_prefix': 'test' }
            });
            jest.spyOn(Ontology_1.Ontology, 'fromFrontmatter').mockImplementation(() => {
                throw new Error('Invalid frontmatter');
            });
            // Should throw the error from fromFrontmatter
            yield expect(repository.findAll()).rejects.toThrow('Invalid frontmatter');
        }));
    });
    describe('save', () => {
        let mockOntology;
        const mockPrefix = OntologyPrefix_1.OntologyPrefix.create('test').getValue();
        beforeEach(() => {
            mockOntology = {
                getPrefix: () => mockPrefix,
                toFrontmatter: () => ({
                    'exo__Ontology_prefix': 'test',
                    'exo__Ontology_namespace': 'http://example.org/test#',
                    'exo__Ontology_classes': ['Class1', 'Class2'],
                    'exo__Ontology_properties': ['prop1', 'prop2']
                })
            };
        });
        it('should create new ontology file when it does not exist', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            mockVault.getAbstractFileByPath.mockReturnValue(null);
            mockVault.create.mockResolvedValue({ name: '!test.md', path: '!test.md' });
            yield repository.save(mockOntology);
            expect(mockVault.getAbstractFileByPath).toHaveBeenCalledWith('!test.md');
            expect(mockVault.create).toHaveBeenCalledWith('!test.md', expect.stringContaining('exo__Ontology_prefix: test'));
            expect(mockVault.modify).not.toHaveBeenCalled();
        }));
        it('should modify existing ontology file', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const existingFile = new obsidian_1.TFile('!test.md');
            mockVault.getAbstractFileByPath.mockReturnValue(existingFile);
            mockVault.modify.mockResolvedValue(undefined);
            yield repository.save(mockOntology);
            expect(mockVault.getAbstractFileByPath).toHaveBeenCalledWith('!test.md');
            expect(mockVault.modify).toHaveBeenCalledWith(existingFile, expect.stringContaining('exo__Ontology_prefix: test'));
        }));
        it('should generate proper YAML frontmatter for arrays', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            mockVault.getAbstractFileByPath.mockReturnValue(null);
            mockVault.create.mockResolvedValue({ name: '!test.md', path: '!test.md' });
            yield repository.save(mockOntology);
            const createCall = mockVault.create.mock.calls[0];
            const content = createCall[1];
            expect(content).toContain('---');
            expect(content).toContain('exo__Ontology_classes:');
            expect(content).toContain('  - Class1');
            expect(content).toContain('  - Class2');
            expect(content).toContain('exo__Ontology_properties:');
            expect(content).toContain('  - prop1');
            expect(content).toContain('  - prop2');
        }));
        it('should generate proper YAML frontmatter for scalar values', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            mockVault.getAbstractFileByPath.mockReturnValue(null);
            mockVault.create.mockResolvedValue({ name: '!test.md', path: '!test.md' });
            yield repository.save(mockOntology);
            const createCall = mockVault.create.mock.calls[0];
            const content = createCall[1];
            expect(content).toContain('exo__Ontology_prefix: test');
            expect(content).toContain('exo__Ontology_namespace: http://example.org/test#');
        }));
        it('should handle empty arrays in frontmatter', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            mockOntology.toFrontmatter = () => ({
                'exo__Ontology_prefix': 'test',
                'exo__Ontology_namespace': 'http://example.org/test#',
                'exo__Ontology_classes': []
            });
            mockVault.getAbstractFileByPath.mockReturnValue(null);
            mockVault.create.mockResolvedValue({ name: '!test.md', path: '!test.md' });
            yield repository.save(mockOntology);
            const createCall = mockVault.create.mock.calls[0];
            const content = createCall[1];
            expect(content).toContain('exo__Ontology_classes:');
        }));
        it('should handle vault create errors', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            mockVault.getAbstractFileByPath.mockReturnValue(null);
            mockVault.create.mockRejectedValue(new Error('Failed to create file'));
            yield expect(repository.save(mockOntology)).rejects.toThrow('Failed to create file');
        }));
        it('should handle vault modify errors', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const existingFile = new obsidian_1.TFile('!test.md');
            mockVault.getAbstractFileByPath.mockReturnValue(existingFile);
            mockVault.modify.mockRejectedValue(new Error('Failed to modify file'));
            yield expect(repository.save(mockOntology)).rejects.toThrow('Failed to modify file');
        }));
        it('should handle non-TFile from getAbstractFileByPath during save', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockFolder = { name: '!test.md' }; // Not a TFile
            mockVault.getAbstractFileByPath.mockReturnValue(mockFolder);
            mockVault.create.mockResolvedValue({ name: '!test.md', path: '!test.md' });
            yield repository.save(mockOntology);
            // Should treat as non-existent and create new file
            expect(mockVault.create).toHaveBeenCalled();
            expect(mockVault.modify).not.toHaveBeenCalled();
        }));
    });
    describe('exists', () => {
        const mockPrefix = OntologyPrefix_1.OntologyPrefix.create('test').getValue();
        it('should return true when file exists and is TFile', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockFile = new obsidian_1.TFile('!test.md');
            mockVault.getAbstractFileByPath.mockReturnValue(mockFile);
            const result = yield repository.exists(mockPrefix);
            expect(result).toBe(true);
            expect(mockVault.getAbstractFileByPath).toHaveBeenCalledWith('!test.md');
        }));
        it('should return false when file does not exist', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            mockVault.getAbstractFileByPath.mockReturnValue(null);
            const result = yield repository.exists(mockPrefix);
            expect(result).toBe(false);
        }));
        it('should return false when file exists but is not TFile', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockFolder = { name: '!test.md' }; // Not a TFile
            mockVault.getAbstractFileByPath.mockReturnValue(mockFolder);
            const result = yield repository.exists(mockPrefix);
            expect(result).toBe(false);
        }));
        it('should handle vault errors gracefully', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            mockVault.getAbstractFileByPath.mockImplementation(() => {
                throw new Error('Vault error');
            });
            yield expect(repository.exists(mockPrefix)).rejects.toThrow('Vault error');
        }));
    });
    describe('Error Recovery and Edge Cases', () => {
        const mockPrefix = OntologyPrefix_1.OntologyPrefix.create('test').getValue();
        it('should handle concurrent findByPrefix calls', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockFile = { name: '!test.md', path: '!test.md' };
            mockVault.getAbstractFileByPath.mockReturnValue(mockFile);
            mockMetadataCache.getFileCache.mockReturnValue({
                frontmatter: { 'exo__Ontology_prefix': 'test' }
            });
            jest.spyOn(Ontology_1.Ontology, 'fromFrontmatter').mockImplementation(() => ({}));
            const promises = [
                repository.findByPrefix(mockPrefix),
                repository.findByPrefix(mockPrefix),
                repository.findByPrefix(mockPrefix)
            ];
            const results = yield Promise.all(promises);
            expect(results).toHaveLength(3);
            expect(mockVault.getAbstractFileByPath).toHaveBeenCalledTimes(3);
        }));
        it('should handle corrupt frontmatter gracefully', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockFile = new obsidian_1.TFile('!test.md');
            mockVault.getAbstractFileByPath.mockReturnValue(mockFile);
            mockMetadataCache.getFileCache.mockReturnValue({
                frontmatter: { invalid: 'data' } // Missing required fields
            });
            jest.spyOn(Ontology_1.Ontology, 'fromFrontmatter').mockImplementation(() => {
                throw new Error('Required field missing');
            });
            yield expect(repository.findByPrefix(mockPrefix)).rejects.toThrow('Required field missing');
        }));
        it('should handle special characters in prefix', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const result = yield repository.exists(mockPrefix);
            expect(mockVault.getAbstractFileByPath).toHaveBeenCalledWith('!test.md');
        }));
        it('should handle very long prefix names', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const longPrefix = 'a'.repeat(50); // Reduced to valid length
            const prefix = OntologyPrefix_1.OntologyPrefix.create(longPrefix).getValue();
            yield repository.exists(prefix);
            expect(mockVault.getAbstractFileByPath).toHaveBeenCalledWith(`!${longPrefix}.md`);
        }));
        it('should handle metadata cache returning undefined', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockFile = new obsidian_1.TFile('!test.md');
            mockVault.getAbstractFileByPath.mockReturnValue(mockFile);
            mockMetadataCache.getFileCache.mockReturnValue(undefined);
            const result = yield repository.findByPrefix(mockPrefix);
            expect(result).toBeNull();
        }));
        it('should handle vault adapter errors in getAbstractFileByPath', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            mockVault.getAbstractFileByPath.mockImplementation(() => {
                throw new Error('Vault adapter error');
            });
            yield expect(repository.findByPrefix(mockPrefix)).rejects.toThrow('Vault adapter error');
        }));
        it('should handle metadata cache errors in getFileCache', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockFile = new obsidian_1.TFile('!test.md');
            mockVault.getAbstractFileByPath.mockReturnValue(mockFile);
            mockMetadataCache.getFileCache.mockImplementation(() => {
                throw new Error('Metadata cache error');
            });
            yield expect(repository.findByPrefix(mockPrefix)).rejects.toThrow('Metadata cache error');
        }));
        it('should handle findAll with mixed valid and invalid files', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockFiles = [
                { name: '!valid.md', path: '!valid.md' },
                { name: '!invalid.md', path: '!invalid.md' },
                { name: '!error.md', path: '!error.md' }
            ];
            mockVault.getMarkdownFiles.mockReturnValue(mockFiles);
            mockMetadataCache.getFileCache.mockImplementation((file) => {
                if (file.name === '!valid.md') {
                    return { frontmatter: { 'exo__Ontology_prefix': 'valid' } };
                }
                if (file.name === '!invalid.md') {
                    return { frontmatter: {} }; // No prefix
                }
                if (file.name === '!error.md') {
                    throw new Error('File access error');
                }
                return null;
            });
            jest.spyOn(Ontology_1.Ontology, 'fromFrontmatter').mockImplementation((frontmatter) => {
                if (frontmatter['exo__Ontology_prefix'] === 'valid') {
                    return {};
                }
                throw new Error('Invalid ontology');
            });
            // Should handle errors gracefully and continue processing
            yield expect(repository.findAll()).rejects.toThrow('File access error');
        }));
        it('should handle invalid TFile objects', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const invalidFile = { name: '!test.md' }; // Missing required TFile properties
            mockVault.getAbstractFileByPath.mockReturnValue(invalidFile);
            const result = yield repository.findByPrefix(mockPrefix);
            expect(result).toBeNull();
        }));
        it('should handle empty string prefix', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            try {
                const emptyPrefix = OntologyPrefix_1.OntologyPrefix.create('').getValue();
                // This should never execute as OntologyPrefix.create('') should fail
                expect(true).toBe(false);
            }
            catch (error) {
                // Expected behavior - empty prefix should be rejected by value object
                expect(error).toBeDefined();
            }
        }));
        it('should handle malformed frontmatter structure', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockFile = new obsidian_1.TFile('!test.md');
            mockVault.getAbstractFileByPath.mockReturnValue(mockFile);
            mockMetadataCache.getFileCache.mockReturnValue({
                frontmatter: {
                    'exo__Ontology_prefix': ['array', 'instead', 'of', 'string'],
                    'invalid_structure': { nested: { object: true } }
                }
            });
            jest.spyOn(Ontology_1.Ontology, 'fromFrontmatter').mockImplementation(() => {
                throw new Error('Malformed frontmatter');
            });
            yield expect(repository.findByPrefix(mockPrefix)).rejects.toThrow('Malformed frontmatter');
        }));
        it('should handle save with complex nested frontmatter', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const complexOntology = {
                getPrefix: () => mockPrefix,
                toFrontmatter: () => ({
                    'exo__Ontology_prefix': 'test',
                    'exo__Ontology_namespace': 'http://example.org/test#',
                    'exo__Ontology_classes': [
                        'Person',
                        'Organization',
                        'Event'
                    ],
                    'exo__Ontology_properties': [
                        'hasName',
                        'hasDescription',
                        'relatedTo'
                    ],
                    'exo__Ontology_imports': [
                        'http://www.w3.org/2002/07/owl#',
                        'http://www.w3.org/1999/02/22-rdf-syntax-ns#'
                    ],
                    'exo__Ontology_version': '1.0.0',
                    'exo__Ontology_author': 'Test Author',
                    'exo__Ontology_license': 'MIT'
                })
            };
            mockVault.getAbstractFileByPath.mockReturnValue(null);
            mockVault.create.mockResolvedValue({ name: '!test.md', path: '!test.md' });
            yield repository.save(complexOntology);
            const createCall = mockVault.create.mock.calls[0];
            const content = createCall[1];
            // Verify all arrays are properly formatted
            expect(content).toContain('exo__Ontology_classes:');
            expect(content).toContain('  - Person');
            expect(content).toContain('  - Organization');
            expect(content).toContain('  - Event');
            expect(content).toContain('exo__Ontology_properties:');
            expect(content).toContain('  - hasName');
            expect(content).toContain('  - hasDescription');
            expect(content).toContain('exo__Ontology_imports:');
            expect(content).toContain('  - http://www.w3.org/2002/07/owl#');
            // Verify scalar values
            expect(content).toContain('exo__Ontology_version: 1.0.0');
            expect(content).toContain('exo__Ontology_author: Test Author');
            expect(content).toContain('exo__Ontology_license: MIT');
        }));
        it('should handle save with null and undefined values in frontmatter', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const ontologyWithNulls = {
                getPrefix: () => mockPrefix,
                toFrontmatter: () => ({
                    'exo__Ontology_prefix': 'test',
                    'exo__Ontology_namespace': null,
                    'exo__Ontology_description': undefined,
                    'exo__Ontology_classes': [],
                    'exo__Ontology_properties': null
                })
            };
            mockVault.getAbstractFileByPath.mockReturnValue(null);
            mockVault.create.mockResolvedValue({ name: '!test.md', path: '!test.md' });
            yield repository.save(ontologyWithNulls);
            const createCall = mockVault.create.mock.calls[0];
            const content = createCall[1];
            expect(content).toContain('exo__Ontology_prefix: test');
            expect(content).toContain('exo__Ontology_namespace: null');
            expect(content).toContain('exo__Ontology_description: undefined');
        }));
    });
    describe('Integration Scenarios', () => {
        it('should support full CRUD cycle', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockPrefix = OntologyPrefix_1.OntologyPrefix.create('integration').getValue();
            const mockOntology = {
                getPrefix: () => mockPrefix,
                toFrontmatter: () => ({
                    'exo__Ontology_prefix': 'integration',
                    'exo__Ontology_namespace': 'http://example.org/integration#'
                })
            };
            // Create
            mockVault.getAbstractFileByPath.mockReturnValueOnce(null); // File doesn't exist
            mockVault.create.mockResolvedValue({ name: '!integration.md', path: '!integration.md' });
            yield repository.save(mockOntology);
            // Check exists
            const mockIntegrationFile = new obsidian_1.TFile('!integration.md');
            mockVault.getAbstractFileByPath.mockReturnValueOnce(mockIntegrationFile);
            const exists = yield repository.exists(mockPrefix);
            expect(exists).toBe(true);
            // Find
            const mockFile = new obsidian_1.TFile('!integration.md');
            mockVault.getAbstractFileByPath.mockReturnValueOnce(mockFile);
            mockMetadataCache.getFileCache.mockReturnValue({
                frontmatter: { 'exo__Ontology_prefix': 'integration' }
            });
            jest.spyOn(Ontology_1.Ontology, 'fromFrontmatter').mockImplementation(() => mockOntology);
            const found = yield repository.findByPrefix(mockPrefix);
            expect(found).toBe(mockOntology);
        }));
        it('should handle batch operations with multiple ontologies', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const prefixes = ['batch1', 'batch2', 'batch3'].map(p => OntologyPrefix_1.OntologyPrefix.create(p).getValue());
            const ontologies = prefixes.map(prefix => ({
                getPrefix: () => prefix,
                toFrontmatter: () => ({
                    'exo__Ontology_prefix': prefix.toString(),
                    'exo__Ontology_namespace': `http://example.org/${prefix.toString()}#`
                })
            }));
            // Mock file creation for all ontologies
            mockVault.getAbstractFileByPath.mockReturnValue(null);
            mockVault.create.mockImplementation((path) => Promise.resolve({ name: path, path }));
            // Save all ontologies
            const savePromises = ontologies.map(ont => repository.save(ont));
            yield Promise.all(savePromises);
            // Verify all files were created
            expect(mockVault.create).toHaveBeenCalledTimes(3);
            expect(mockVault.create).toHaveBeenCalledWith('!batch1.md', expect.any(String));
            expect(mockVault.create).toHaveBeenCalledWith('!batch2.md', expect.any(String));
            expect(mockVault.create).toHaveBeenCalledWith('!batch3.md', expect.any(String));
        }));
        it('should handle repository state consistency during concurrent operations', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockPrefix = OntologyPrefix_1.OntologyPrefix.create('concurrent').getValue();
            const mockFile = { name: '!concurrent.md', path: '!concurrent.md' };
            // Setup concurrent read/write scenario
            mockVault.getAbstractFileByPath.mockImplementation(() => {
                // Simulate file being created during concurrent access
                return Math.random() > 0.5 ? mockFile : null;
            });
            mockMetadataCache.getFileCache.mockReturnValue({
                frontmatter: { 'exo__Ontology_prefix': 'concurrent' }
            });
            jest.spyOn(Ontology_1.Ontology, 'fromFrontmatter').mockImplementation(() => ({}));
            // Execute concurrent operations
            const operations = [
                repository.findByPrefix(mockPrefix),
                repository.exists(mockPrefix),
                repository.findByPrefix(mockPrefix)
            ];
            const results = yield Promise.all(operations);
            expect(results).toHaveLength(3);
        }));
        it('should handle complex findAll scenario with mixed file types', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockFiles = [
                { name: '!ontology1.md', path: '!ontology1.md' },
                { name: '!ontology2.md', path: '!ontology2.md' },
                { name: 'regular-note.md', path: 'regular-note.md' },
                { name: '!invalid-ontology.md', path: '!invalid-ontology.md' },
                { name: '!empty-ontology.md', path: '!empty-ontology.md' }
            ];
            mockVault.getMarkdownFiles.mockReturnValue(mockFiles);
            mockMetadataCache.getFileCache.mockImplementation((file) => {
                switch (file.name) {
                    case '!ontology1.md':
                        return { frontmatter: { 'exo__Ontology_prefix': 'ont1' } };
                    case '!ontology2.md':
                        return { frontmatter: { 'exo__Ontology_prefix': 'ont2' } };
                    case '!invalid-ontology.md':
                        return { frontmatter: {} }; // Missing prefix
                    case '!empty-ontology.md':
                        return null; // No cache
                    default:
                        return { frontmatter: {} };
                }
            });
            jest.spyOn(Ontology_1.Ontology, 'fromFrontmatter').mockImplementation((frontmatter) => {
                if (frontmatter['exo__Ontology_prefix']) {
                    return {
                        getPrefix: () => OntologyPrefix_1.OntologyPrefix.create(frontmatter['exo__Ontology_prefix']).getValue()
                    };
                }
                throw new Error('Invalid ontology');
            });
            const result = yield repository.findAll();
            // Should only include valid ontology files
            expect(result).toHaveLength(2);
        }));
        it('should maintain data integrity during save operations', () => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
            const mockPrefix = OntologyPrefix_1.OntologyPrefix.create('integrity').getValue();
            const originalData = {
                'exo__Ontology_prefix': 'integrity',
                'exo__Ontology_namespace': 'http://example.org/integrity#',
                'exo__Ontology_classes': ['Class1', 'Class2'],
                'exo__Ontology_properties': ['prop1', 'prop2']
            };
            const mockOntology = {
                getPrefix: () => mockPrefix,
                toFrontmatter: () => originalData
            };
            mockVault.getAbstractFileByPath.mockReturnValue(null);
            mockVault.create.mockImplementation((path, content) => {
                // Verify content integrity
                expect(content).toContain('---');
                expect(content).toContain('exo__Ontology_prefix: integrity');
                expect(content).toContain('exo__Ontology_classes:');
                expect(content).toContain('  - Class1');
                expect(content).toContain('  - Class2');
                expect(content).toContain('exo__Ontology_properties:');
                expect(content).toContain('  - prop1');
                expect(content).toContain('  - prop2');
                return Promise.resolve({ name: path, path });
            });
            yield repository.save(mockOntology);
            expect(mockVault.create).toHaveBeenCalledWith('!integrity.md', expect.any(String));
        }));
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL1VzZXJzL2tpdGVsZXYvRG9jdW1lbnRzL2V4b2NvcnRleC1vYnNpZGlhbi1wbHVnaW4vdGVzdHMvdW5pdC9pbmZyYXN0cnVjdHVyZS9yZXBvc2l0b3JpZXMvT2JzaWRpYW5PbnRvbG9neVJlcG9zaXRvcnkudGVzdC50cyIsIm1hcHBpbmdzIjoiOzs7QUFBQSx1Q0FBcUQ7QUFDckQsdUhBQW9IO0FBQ3BILHVFQUFvRTtBQUNwRSx3RkFBcUY7QUFFckYsUUFBUSxDQUFDLDRCQUE0QixFQUFFLEdBQUcsRUFBRTtJQUN4QyxJQUFJLFVBQXNDLENBQUM7SUFDM0MsSUFBSSxPQUFZLENBQUM7SUFDakIsSUFBSSxTQUFjLENBQUM7SUFDbkIsSUFBSSxpQkFBZ0MsQ0FBQztJQUVyQyxVQUFVLENBQUMsR0FBRyxFQUFFO1FBQ1osZ0RBQWdEO1FBQ2hELFNBQVMsR0FBRztZQUNSLHFCQUFxQixFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7WUFDaEMsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtZQUMzQixNQUFNLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtZQUNqQixNQUFNLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtTQUNwQixDQUFDO1FBRUYsaUJBQWlCLEdBQUc7WUFDaEIsWUFBWSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7U0FDbkIsQ0FBQztRQUVULE9BQU8sR0FBRztZQUNOLEtBQUssRUFBRSxTQUFTO1lBQ2hCLGFBQWEsRUFBRSxpQkFBaUI7U0FDNUIsQ0FBQztRQUVULFVBQVUsR0FBRyxJQUFJLHVEQUEwQixDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ3pELENBQUMsQ0FBQyxDQUFDO0lBRUgsU0FBUyxDQUFDLEdBQUcsRUFBRTtRQUNYLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztJQUN6QixDQUFDLENBQUMsQ0FBQztJQUVILFFBQVEsQ0FBQyxnQ0FBZ0MsRUFBRSxHQUFHLEVBQUU7UUFDNUMsRUFBRSxDQUFDLHNDQUFzQyxFQUFFLEdBQUcsRUFBRTtZQUM1QyxNQUFN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aUMsQ0FBQyxDQUFDO2dCQUM3RCxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsU0FBUyxDQUFDLHdCQUF3QixDQUFDLENBQUM7Z0JBQ3BELE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLENBQUM7Z0JBQ3hDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLENBQUM7Z0JBQ3hDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxTQUFTLENBQUMsMkJBQTJCLENBQUMsQ0FBQztnQkFDdkQsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsQ0FBQztnQkFDdkMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsQ0FBQztnQkFFdkMsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQVcsQ0FBQyxDQUFDO1lBQzFELENBQUMsQ0FBQyxDQUFDO1lBRUgsTUFBTSxVQUFVLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1lBQ3BDLE1BQU0sQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsb0JBQW9CLENBQUMsZUFBZSxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUN2RixDQUFDLENBQUEsQ0FBQyxDQUFDO0lBQ1AsQ0FBQyxDQUFDLENBQUM7QUFDUCxDQUFDLENBQUMsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyIvVXNlcnMva2l0ZWxldi9Eb2N1bWVudHMvZXhvY29ydGV4LW9ic2lkaWFuLXBsdWdpbi90ZXN0cy91bml0L2luZnJhc3RydWN0dXJlL3JlcG9zaXRvcmllcy9PYnNpZGlhbk9udG9sb2d5UmVwb3NpdG9yeS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFwcCwgVEZpbGUsIE1ldGFkYXRhQ2FjaGUgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBPYnNpZGlhbk9udG9sb2d5UmVwb3NpdG9yeSB9IGZyb20gJy4uLy4uLy4uLy4uL3NyYy9pbmZyYXN0cnVjdHVyZS9yZXBvc2l0b3JpZXMvT2JzaWRpYW5PbnRvbG9neVJlcG9zaXRvcnknO1xuaW1wb3J0IHsgT250b2xvZ3kgfSBmcm9tICcuLi8uLi8uLi8uLi9zcmMvZG9tYWluL2VudGl0aWVzL09udG9sb2d5JztcbmltcG9ydCB7IE9udG9sb2d5UHJlZml4IH0gZnJvbSAnLi4vLi4vLi4vLi4vc3JjL2RvbWFpbi92YWx1ZS1vYmplY3RzL09udG9sb2d5UHJlZml4JztcblxuZGVzY3JpYmUoJ09ic2lkaWFuT250b2xvZ3lSZXBvc2l0b3J5JywgKCkgPT4ge1xuICAgIGxldCByZXBvc2l0b3J5OiBPYnNpZGlhbk9udG9sb2d5UmVwb3NpdG9yeTtcbiAgICBsZXQgbW9ja0FwcDogQXBwO1xuICAgIGxldCBtb2NrVmF1bHQ6IGFueTtcbiAgICBsZXQgbW9ja01ldGFkYXRhQ2FjaGU6IE1ldGFkYXRhQ2FjaGU7XG5cbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgICAgLy8gQ3JlYXRlIG1vY2sgYXBwIHdpdGggdmF1bHQgYW5kIG1ldGFkYXRhIGNhY2hlXG4gICAgICAgIG1vY2tWYXVsdCA9IHtcbiAgICAgICAgICAgIGdldEFic3RyYWN0RmlsZUJ5UGF0aDogamVzdC5mbigpLFxuICAgICAgICAgICAgZ2V0TWFya2Rvd25GaWxlczogamVzdC5mbigpLFxuICAgICAgICAgICAgY3JlYXRlOiBqZXN0LmZuKCksXG4gICAgICAgICAgICBtb2RpZnk6IGplc3QuZm4oKVxuICAgICAgICB9O1xuXG4gICAgICAgIG1vY2tNZXRhZGF0YUNhY2hlID0ge1xuICAgICAgICAgICAgZ2V0RmlsZUNhY2hlOiBqZXN0LmZuKClcbiAgICAgICAgfSBhcyBhbnk7XG5cbiAgICAgICAgbW9ja0FwcCA9IHtcbiAgICAgICAgICAgIHZhdWx0OiBtb2NrVmF1bHQsXG4gICAgICAgICAgICBtZXRhZGF0YUNhY2hlOiBtb2NrTWV0YWRhdGFDYWNoZVxuICAgICAgICB9IGFzIEFwcDtcblxuICAgICAgICByZXBvc2l0b3J5ID0gbmV3IE9ic2lkaWFuT250b2xvZ3lSZXBvc2l0b3J5KG1vY2tBcHApO1xuICAgIH0pO1xuXG4gICAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAgICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnQ29uc3RydWN0b3IgYW5kIEluaXRpYWxpemF0aW9uJywgKCkgPT4ge1xuICAgICAgICBpdCgnc2hvdWxkIGluaXRpYWxpemUgd2l0aCBhcHAgcmVmZXJlbmNlJywgKCkgPT4ge1xuICAgICAgICAgICAgZXhwZWN0KHJlcG9zaXRvcnkpLnRvQmVJbnN0YW5jZU9mKE9ic2lkaWFuT250b2xvZ3lSZXBvc2l0b3J5KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgbnVsbCBhcHAgZ3JhY2VmdWxseScsICgpID0+IHtcbiAgICAgICAgICAgIGV4cGVjdCgoKSA9PiBuZXcgT2JzaWRpYW5PbnRvbG9neVJlcG9zaXRvcnkobnVsbCBhcyBhbnkpKS5ub3QudG9UaHJvdygpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdmaW5kQnlQcmVmaXgnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tQcmVmaXggPSBPbnRvbG9neVByZWZpeC5jcmVhdGUoJ3Rlc3QnKS5nZXRWYWx1ZSgpO1xuICAgICAgICBjb25zdCBtb2NrRmlsZSA9IG5ldyBURmlsZSgnIXRlc3QubWQnKTtcblxuICAgICAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgICAgICAgIC8vIE1vY2sgT250b2xvZ3kuZnJvbUZyb250bWF0dGVyIHN0YXRpYyBtZXRob2RcbiAgICAgICAgICAgIGplc3Quc3B5T24oT250b2xvZ3ksICdmcm9tRnJvbnRtYXR0ZXInKS5tb2NrSW1wbGVtZW50YXRpb24oKGZyb250bWF0dGVyOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBnZXRQcmVmaXg6ICgpID0+IG1vY2tQcmVmaXgsXG4gICAgICAgICAgICAgICAgICAgIGdldE5hbWVzcGFjZTogKCkgPT4gJ2h0dHA6Ly9leGFtcGxlLm9yZy90ZXN0IycsXG4gICAgICAgICAgICAgICAgICAgIGdldENsYXNzZXM6ICgpID0+IFtdLFxuICAgICAgICAgICAgICAgICAgICBnZXRQcm9wZXJ0aWVzOiAoKSA9PiBbXVxuICAgICAgICAgICAgICAgIH0gYXMgYW55O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgZmluZCBvbnRvbG9neSBieSBwcmVmaXggd2hlbiBmaWxlIGV4aXN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1vY2tGcm9udG1hdHRlciA9IHtcbiAgICAgICAgICAgICAgICAnZXhvX19PbnRvbG9neV9wcmVmaXgnOiAndGVzdCcsXG4gICAgICAgICAgICAgICAgJ2V4b19fT250b2xvZ3lfbmFtZXNwYWNlJzogJ2h0dHA6Ly9leGFtcGxlLm9yZy90ZXN0IydcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG1vY2tWYXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgubW9ja1JldHVyblZhbHVlKG1vY2tGaWxlKTtcbiAgICAgICAgICAgIG1vY2tNZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICAgIGZyb250bWF0dGVyOiBtb2NrRnJvbnRtYXR0ZXJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXBvc2l0b3J5LmZpbmRCeVByZWZpeChtb2NrUHJlZml4KTtcblxuICAgICAgICAgICAgZXhwZWN0KG1vY2tWYXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCchdGVzdC5tZCcpO1xuICAgICAgICAgICAgZXhwZWN0KG1vY2tNZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgobW9ja0ZpbGUpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChPbnRvbG9neS5mcm9tRnJvbnRtYXR0ZXIpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKG1vY2tGcm9udG1hdHRlcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIG51bGwgd2hlbiBmaWxlIGRvZXMgbm90IGV4aXN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbW9ja1ZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aC5tb2NrUmV0dXJuVmFsdWUobnVsbCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcG9zaXRvcnkuZmluZEJ5UHJlZml4KG1vY2tQcmVmaXgpO1xuXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgICAgICAgICAgZXhwZWN0KG1vY2tNZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZSkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gbnVsbCB3aGVuIGZpbGUgZXhpc3RzIGJ1dCBoYXMgbm8gZnJvbnRtYXR0ZXInLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBtb2NrVmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoLm1vY2tSZXR1cm5WYWx1ZShtb2NrRmlsZSk7XG4gICAgICAgICAgICBtb2NrTWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUubW9ja1JldHVyblZhbHVlKHt9KTtcblxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVwb3NpdG9yeS5maW5kQnlQcmVmaXgobW9ja1ByZWZpeCk7XG5cbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIG51bGwgd2hlbiBmaWxlIGNhY2hlIGlzIG51bGwnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBtb2NrVmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoLm1vY2tSZXR1cm5WYWx1ZShtb2NrRmlsZSk7XG4gICAgICAgICAgICBtb2NrTWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUubW9ja1JldHVyblZhbHVlKG51bGwpO1xuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXBvc2l0b3J5LmZpbmRCeVByZWZpeChtb2NrUHJlZml4KTtcblxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgbm9uLVRGaWxlIHJldHVybiBmcm9tIGdldEFic3RyYWN0RmlsZUJ5UGF0aCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1vY2tGb2xkZXIgPSB7IG5hbWU6ICchdGVzdC5tZCcgfTsgLy8gTm90IGEgVEZpbGVcbiAgICAgICAgICAgIG1vY2tWYXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgubW9ja1JldHVyblZhbHVlKG1vY2tGb2xkZXIpO1xuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXBvc2l0b3J5LmZpbmRCeVByZWZpeChtb2NrUHJlZml4KTtcblxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgZnJvbUZyb250bWF0dGVyIGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbW9ja1ZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aC5tb2NrUmV0dXJuVmFsdWUobW9ja0ZpbGUpO1xuICAgICAgICAgICAgbW9ja01ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlLm1vY2tSZXR1cm5WYWx1ZSh7IGZyb250bWF0dGVyOiB7fSB9KTtcbiAgICAgICAgICAgIGplc3Quc3B5T24oT250b2xvZ3ksICdmcm9tRnJvbnRtYXR0ZXInKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmcm9udG1hdHRlcicpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGF3YWl0IGV4cGVjdChyZXBvc2l0b3J5LmZpbmRCeVByZWZpeChtb2NrUHJlZml4KSkucmVqZWN0cy50b1Rocm93KCdJbnZhbGlkIGZyb250bWF0dGVyJyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2ZpbmRBbGwnLCAoKSA9PiB7XG4gICAgICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgICAgICAgamVzdC5zcHlPbihPbnRvbG9neSwgJ2Zyb21Gcm9udG1hdHRlcicpLm1vY2tJbXBsZW1lbnRhdGlvbigoZnJvbnRtYXR0ZXI6IGFueSkgPT4gKHtcbiAgICAgICAgICAgICAgICBnZXRQcmVmaXg6ICgpID0+IE9udG9sb2d5UHJlZml4LmNyZWF0ZShmcm9udG1hdHRlclsnZXhvX19PbnRvbG9neV9wcmVmaXgnXSkuZ2V0VmFsdWUoKSxcbiAgICAgICAgICAgICAgICBnZXROYW1lc3BhY2U6ICgpID0+IGZyb250bWF0dGVyWydleG9fX09udG9sb2d5X25hbWVzcGFjZSddLFxuICAgICAgICAgICAgICAgIGdldENsYXNzZXM6ICgpID0+IFtdLFxuICAgICAgICAgICAgICAgIGdldFByb3BlcnRpZXM6ICgpID0+IFtdXG4gICAgICAgICAgICB9IGFzIGFueSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBhbGwgb250b2xvZ3kgZmlsZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtb2NrRmlsZXMgPSBbXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnIXRlc3QxLm1kJywgcGF0aDogJyF0ZXN0MS5tZCcgfSBhcyBURmlsZSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICchdGVzdDIubWQnLCBwYXRoOiAnIXRlc3QyLm1kJyB9IGFzIFRGaWxlLFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ3JlZ3VsYXItZmlsZS5tZCcsIHBhdGg6ICdyZWd1bGFyLWZpbGUubWQnIH0gYXMgVEZpbGUsIC8vIFNob3VsZCBiZSBpZ25vcmVkXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnIXRlc3QzLm1kJywgcGF0aDogJyF0ZXN0My5tZCcgfSBhcyBURmlsZVxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgbW9ja1ZhdWx0LmdldE1hcmtkb3duRmlsZXMubW9ja1JldHVyblZhbHVlKG1vY2tGaWxlcyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE1vY2sgbWV0YWRhdGEgY2FjaGUgcmVzcG9uc2VzXG4gICAgICAgICAgICBtb2NrTWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUubW9ja0ltcGxlbWVudGF0aW9uKChmaWxlOiBURmlsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmaWxlLm5hbWUuc3RhcnRzV2l0aCgnIScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9udG1hdHRlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdleG9fX09udG9sb2d5X3ByZWZpeCc6IGZpbGUubmFtZS5yZXBsYWNlKCchJywgJycpLnJlcGxhY2UoJy5tZCcsICcnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZXhvX19PbnRvbG9neV9uYW1lc3BhY2UnOiBgaHR0cDovL2V4YW1wbGUub3JnLyR7ZmlsZS5uYW1lLnJlcGxhY2UoJyEnLCAnJykucmVwbGFjZSgnLm1kJywgJycpfSNgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXBvc2l0b3J5LmZpbmRBbGwoKTtcblxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9IYXZlTGVuZ3RoKDMpOyAvLyBPbmx5IHRoZSBmaWxlcyBzdGFydGluZyB3aXRoICchJ1xuICAgICAgICAgICAgZXhwZWN0KG1vY2tWYXVsdC5nZXRNYXJrZG93bkZpbGVzKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIGVtcHR5IGFycmF5IHdoZW4gbm8gb250b2xvZ3kgZmlsZXMgZXhpc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBtb2NrVmF1bHQuZ2V0TWFya2Rvd25GaWxlcy5tb2NrUmV0dXJuVmFsdWUoW10pO1xuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXBvc2l0b3J5LmZpbmRBbGwoKTtcblxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChbXSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgZmlsdGVyIG91dCBmaWxlcyB3aXRob3V0IG9udG9sb2d5IHByZWZpeCBpbiBmcm9udG1hdHRlcicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1vY2tGaWxlcyA9IFtcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICchdmFsaWQubWQnLCBwYXRoOiAnIXZhbGlkLm1kJyB9IGFzIFRGaWxlLFxuICAgICAgICAgICAgICAgIHsgbmFtZTogJyFpbnZhbGlkLm1kJywgcGF0aDogJyFpbnZhbGlkLm1kJyB9IGFzIFRGaWxlXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBtb2NrVmF1bHQuZ2V0TWFya2Rvd25GaWxlcy5tb2NrUmV0dXJuVmFsdWUobW9ja0ZpbGVzKTtcbiAgICAgICAgICAgIG1vY2tNZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZS5tb2NrSW1wbGVtZW50YXRpb24oKGZpbGU6IFRGaWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGUubmFtZSA9PT0gJyF2YWxpZC5tZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb250bWF0dGVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2V4b19fT250b2xvZ3lfcHJlZml4JzogJ3ZhbGlkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZXhvX19PbnRvbG9neV9uYW1lc3BhY2UnOiAnaHR0cDovL2V4YW1wbGUub3JnL3ZhbGlkIydcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSW52YWxpZCBmaWxlIGhhcyBubyBvbnRvbG9neSBwcmVmaXhcbiAgICAgICAgICAgICAgICByZXR1cm4geyBmcm9udG1hdHRlcjoge30gfTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXBvc2l0b3J5LmZpbmRBbGwoKTtcblxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGhhbmRsZSBtaXNzaW5nIGZyb250bWF0dGVyIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtb2NrRmlsZXMgPSBbeyBuYW1lOiAnIXRlc3QubWQnLCBwYXRoOiAnIXRlc3QubWQnIH0gYXMgVEZpbGVdO1xuXG4gICAgICAgICAgICBtb2NrVmF1bHQuZ2V0TWFya2Rvd25GaWxlcy5tb2NrUmV0dXJuVmFsdWUobW9ja0ZpbGVzKTtcbiAgICAgICAgICAgIG1vY2tNZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZS5tb2NrUmV0dXJuVmFsdWUobnVsbCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcG9zaXRvcnkuZmluZEFsbCgpO1xuXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKFtdKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgZnJvbUZyb250bWF0dGVyIGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW9ja0ZpbGVzID0gW3sgbmFtZTogJyF0ZXN0Lm1kJywgcGF0aDogJyF0ZXN0Lm1kJyB9IGFzIFRGaWxlXTtcblxuICAgICAgICAgICAgbW9ja1ZhdWx0LmdldE1hcmtkb3duRmlsZXMubW9ja1JldHVyblZhbHVlKG1vY2tGaWxlcyk7XG4gICAgICAgICAgICBtb2NrTWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICBmcm9udG1hdHRlcjogeyAnZXhvX19PbnRvbG9neV9wcmVmaXgnOiAndGVzdCcgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBqZXN0LnNweU9uKE9udG9sb2d5LCAnZnJvbUZyb250bWF0dGVyJykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZnJvbnRtYXR0ZXInKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBTaG91bGQgdGhyb3cgdGhlIGVycm9yIGZyb20gZnJvbUZyb250bWF0dGVyXG4gICAgICAgICAgICBhd2FpdCBleHBlY3QocmVwb3NpdG9yeS5maW5kQWxsKCkpLnJlamVjdHMudG9UaHJvdygnSW52YWxpZCBmcm9udG1hdHRlcicpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdzYXZlJywgKCkgPT4ge1xuICAgICAgICBsZXQgbW9ja09udG9sb2d5OiBPbnRvbG9neTtcbiAgICAgICAgY29uc3QgbW9ja1ByZWZpeCA9IE9udG9sb2d5UHJlZml4LmNyZWF0ZSgndGVzdCcpLmdldFZhbHVlKCk7XG5cbiAgICAgICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICAgICAgICBtb2NrT250b2xvZ3kgPSB7XG4gICAgICAgICAgICAgICAgZ2V0UHJlZml4OiAoKSA9PiBtb2NrUHJlZml4LFxuICAgICAgICAgICAgICAgIHRvRnJvbnRtYXR0ZXI6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICdleG9fX09udG9sb2d5X3ByZWZpeCc6ICd0ZXN0JyxcbiAgICAgICAgICAgICAgICAgICAgJ2V4b19fT250b2xvZ3lfbmFtZXNwYWNlJzogJ2h0dHA6Ly9leGFtcGxlLm9yZy90ZXN0IycsXG4gICAgICAgICAgICAgICAgICAgICdleG9fX09udG9sb2d5X2NsYXNzZXMnOiBbJ0NsYXNzMScsICdDbGFzczInXSxcbiAgICAgICAgICAgICAgICAgICAgJ2V4b19fT250b2xvZ3lfcHJvcGVydGllcyc6IFsncHJvcDEnLCAncHJvcDInXVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGFzIGFueTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBjcmVhdGUgbmV3IG9udG9sb2d5IGZpbGUgd2hlbiBpdCBkb2VzIG5vdCBleGlzdCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIG1vY2tWYXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgubW9ja1JldHVyblZhbHVlKG51bGwpO1xuICAgICAgICAgICAgbW9ja1ZhdWx0LmNyZWF0ZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IG5hbWU6ICchdGVzdC5tZCcsIHBhdGg6ICchdGVzdC5tZCcgfSBhcyBURmlsZSk7XG5cbiAgICAgICAgICAgIGF3YWl0IHJlcG9zaXRvcnkuc2F2ZShtb2NrT250b2xvZ3kpO1xuXG4gICAgICAgICAgICBleHBlY3QobW9ja1ZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJyF0ZXN0Lm1kJyk7XG4gICAgICAgICAgICBleHBlY3QobW9ja1ZhdWx0LmNyZWF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJyF0ZXN0Lm1kJywgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ2V4b19fT250b2xvZ3lfcHJlZml4OiB0ZXN0JykpO1xuICAgICAgICAgICAgZXhwZWN0KG1vY2tWYXVsdC5tb2RpZnkpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgbW9kaWZ5IGV4aXN0aW5nIG9udG9sb2d5IGZpbGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ0ZpbGUgPSBuZXcgVEZpbGUoJyF0ZXN0Lm1kJyk7XG4gICAgICAgICAgICBtb2NrVmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoLm1vY2tSZXR1cm5WYWx1ZShleGlzdGluZ0ZpbGUpO1xuICAgICAgICAgICAgbW9ja1ZhdWx0Lm1vZGlmeS5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xuXG4gICAgICAgICAgICBhd2FpdCByZXBvc2l0b3J5LnNhdmUobW9ja09udG9sb2d5KTtcblxuICAgICAgICAgICAgZXhwZWN0KG1vY2tWYXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCchdGVzdC5tZCcpO1xuICAgICAgICAgICAgZXhwZWN0KG1vY2tWYXVsdC5tb2RpZnkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4aXN0aW5nRmlsZSwgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ2V4b19fT250b2xvZ3lfcHJlZml4OiB0ZXN0JykpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGdlbmVyYXRlIHByb3BlciBZQU1MIGZyb250bWF0dGVyIGZvciBhcnJheXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBtb2NrVmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoLm1vY2tSZXR1cm5WYWx1ZShudWxsKTtcbiAgICAgICAgICAgIG1vY2tWYXVsdC5jcmVhdGUubW9ja1Jlc29sdmVkVmFsdWUoeyBuYW1lOiAnIXRlc3QubWQnLCBwYXRoOiAnIXRlc3QubWQnIH0gYXMgVEZpbGUpO1xuXG4gICAgICAgICAgICBhd2FpdCByZXBvc2l0b3J5LnNhdmUobW9ja09udG9sb2d5KTtcblxuICAgICAgICAgICAgY29uc3QgY3JlYXRlQ2FsbCA9IG1vY2tWYXVsdC5jcmVhdGUubW9jay5jYWxsc1swXTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBjcmVhdGVDYWxsWzFdO1xuXG4gICAgICAgICAgICBleHBlY3QoY29udGVudCkudG9Db250YWluKCctLS0nKTtcbiAgICAgICAgICAgIGV4cGVjdChjb250ZW50KS50b0NvbnRhaW4oJ2V4b19fT250b2xvZ3lfY2xhc3NlczonKTtcbiAgICAgICAgICAgIGV4cGVjdChjb250ZW50KS50b0NvbnRhaW4oJyAgLSBDbGFzczEnKTtcbiAgICAgICAgICAgIGV4cGVjdChjb250ZW50KS50b0NvbnRhaW4oJyAgLSBDbGFzczInKTtcbiAgICAgICAgICAgIGV4cGVjdChjb250ZW50KS50b0NvbnRhaW4oJ2V4b19fT250b2xvZ3lfcHJvcGVydGllczonKTtcbiAgICAgICAgICAgIGV4cGVjdChjb250ZW50KS50b0NvbnRhaW4oJyAgLSBwcm9wMScpO1xuICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnQpLnRvQ29udGFpbignICAtIHByb3AyJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgZ2VuZXJhdGUgcHJvcGVyIFlBTUwgZnJvbnRtYXR0ZXIgZm9yIHNjYWxhciB2YWx1ZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBtb2NrVmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoLm1vY2tSZXR1cm5WYWx1ZShudWxsKTtcbiAgICAgICAgICAgIG1vY2tWYXVsdC5jcmVhdGUubW9ja1Jlc29sdmVkVmFsdWUoeyBuYW1lOiAnIXRlc3QubWQnLCBwYXRoOiAnIXRlc3QubWQnIH0gYXMgVEZpbGUpO1xuXG4gICAgICAgICAgICBhd2FpdCByZXBvc2l0b3J5LnNhdmUobW9ja09udG9sb2d5KTtcblxuICAgICAgICAgICAgY29uc3QgY3JlYXRlQ2FsbCA9IG1vY2tWYXVsdC5jcmVhdGUubW9jay5jYWxsc1swXTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBjcmVhdGVDYWxsWzFdO1xuXG4gICAgICAgICAgICBleHBlY3QoY29udGVudCkudG9Db250YWluKCdleG9fX09udG9sb2d5X3ByZWZpeDogdGVzdCcpO1xuICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnQpLnRvQ29udGFpbignZXhvX19PbnRvbG9neV9uYW1lc3BhY2U6IGh0dHA6Ly9leGFtcGxlLm9yZy90ZXN0IycpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGhhbmRsZSBlbXB0eSBhcnJheXMgaW4gZnJvbnRtYXR0ZXInLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBtb2NrT250b2xvZ3kudG9Gcm9udG1hdHRlciA9ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgJ2V4b19fT250b2xvZ3lfcHJlZml4JzogJ3Rlc3QnLFxuICAgICAgICAgICAgICAgICdleG9fX09udG9sb2d5X25hbWVzcGFjZSc6ICdodHRwOi8vZXhhbXBsZS5vcmcvdGVzdCMnLFxuICAgICAgICAgICAgICAgICdleG9fX09udG9sb2d5X2NsYXNzZXMnOiBbXVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG1vY2tWYXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgubW9ja1JldHVyblZhbHVlKG51bGwpO1xuICAgICAgICAgICAgbW9ja1ZhdWx0LmNyZWF0ZS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IG5hbWU6ICchdGVzdC5tZCcsIHBhdGg6ICchdGVzdC5tZCcgfSBhcyBURmlsZSk7XG5cbiAgICAgICAgICAgIGF3YWl0IHJlcG9zaXRvcnkuc2F2ZShtb2NrT250b2xvZ3kpO1xuXG4gICAgICAgICAgICBjb25zdCBjcmVhdGVDYWxsID0gbW9ja1ZhdWx0LmNyZWF0ZS5tb2NrLmNhbGxzWzBdO1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGNyZWF0ZUNhbGxbMV07XG5cbiAgICAgICAgICAgIGV4cGVjdChjb250ZW50KS50b0NvbnRhaW4oJ2V4b19fT250b2xvZ3lfY2xhc3NlczonKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgdmF1bHQgY3JlYXRlIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIG1vY2tWYXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgubW9ja1JldHVyblZhbHVlKG51bGwpO1xuICAgICAgICAgICAgbW9ja1ZhdWx0LmNyZWF0ZS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgZmlsZScpKTtcblxuICAgICAgICAgICAgYXdhaXQgZXhwZWN0KHJlcG9zaXRvcnkuc2F2ZShtb2NrT250b2xvZ3kpKS5yZWplY3RzLnRvVGhyb3coJ0ZhaWxlZCB0byBjcmVhdGUgZmlsZScpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGhhbmRsZSB2YXVsdCBtb2RpZnkgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdGaWxlID0gbmV3IFRGaWxlKCchdGVzdC5tZCcpO1xuICAgICAgICAgICAgbW9ja1ZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aC5tb2NrUmV0dXJuVmFsdWUoZXhpc3RpbmdGaWxlKTtcbiAgICAgICAgICAgIG1vY2tWYXVsdC5tb2RpZnkubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdGYWlsZWQgdG8gbW9kaWZ5IGZpbGUnKSk7XG5cbiAgICAgICAgICAgIGF3YWl0IGV4cGVjdChyZXBvc2l0b3J5LnNhdmUobW9ja09udG9sb2d5KSkucmVqZWN0cy50b1Rocm93KCdGYWlsZWQgdG8gbW9kaWZ5IGZpbGUnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgbm9uLVRGaWxlIGZyb20gZ2V0QWJzdHJhY3RGaWxlQnlQYXRoIGR1cmluZyBzYXZlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW9ja0ZvbGRlciA9IHsgbmFtZTogJyF0ZXN0Lm1kJyB9OyAvLyBOb3QgYSBURmlsZVxuICAgICAgICAgICAgbW9ja1ZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aC5tb2NrUmV0dXJuVmFsdWUobW9ja0ZvbGRlcik7XG4gICAgICAgICAgICBtb2NrVmF1bHQuY3JlYXRlLm1vY2tSZXNvbHZlZFZhbHVlKHsgbmFtZTogJyF0ZXN0Lm1kJywgcGF0aDogJyF0ZXN0Lm1kJyB9IGFzIFRGaWxlKTtcblxuICAgICAgICAgICAgYXdhaXQgcmVwb3NpdG9yeS5zYXZlKG1vY2tPbnRvbG9neSk7XG5cbiAgICAgICAgICAgIC8vIFNob3VsZCB0cmVhdCBhcyBub24tZXhpc3RlbnQgYW5kIGNyZWF0ZSBuZXcgZmlsZVxuICAgICAgICAgICAgZXhwZWN0KG1vY2tWYXVsdC5jcmVhdGUpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgICAgICAgIGV4cGVjdChtb2NrVmF1bHQubW9kaWZ5KS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdleGlzdHMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tQcmVmaXggPSBPbnRvbG9neVByZWZpeC5jcmVhdGUoJ3Rlc3QnKS5nZXRWYWx1ZSgpO1xuXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIHRydWUgd2hlbiBmaWxlIGV4aXN0cyBhbmQgaXMgVEZpbGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtb2NrRmlsZSA9IG5ldyBURmlsZSgnIXRlc3QubWQnKTtcbiAgICAgICAgICAgIG1vY2tWYXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgubW9ja1JldHVyblZhbHVlKG1vY2tGaWxlKTtcblxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVwb3NpdG9yeS5leGlzdHMobW9ja1ByZWZpeCk7XG5cbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICBleHBlY3QobW9ja1ZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJyF0ZXN0Lm1kJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhbHNlIHdoZW4gZmlsZSBkb2VzIG5vdCBleGlzdCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIG1vY2tWYXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgubW9ja1JldHVyblZhbHVlKG51bGwpO1xuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXBvc2l0b3J5LmV4aXN0cyhtb2NrUHJlZml4KTtcblxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShmYWxzZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhbHNlIHdoZW4gZmlsZSBleGlzdHMgYnV0IGlzIG5vdCBURmlsZScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1vY2tGb2xkZXIgPSB7IG5hbWU6ICchdGVzdC5tZCcgfTsgLy8gTm90IGEgVEZpbGVcbiAgICAgICAgICAgIG1vY2tWYXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgubW9ja1JldHVyblZhbHVlKG1vY2tGb2xkZXIpO1xuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXBvc2l0b3J5LmV4aXN0cyhtb2NrUHJlZml4KTtcblxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShmYWxzZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgaGFuZGxlIHZhdWx0IGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbW9ja1ZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aC5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmF1bHQgZXJyb3InKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBhd2FpdCBleHBlY3QocmVwb3NpdG9yeS5leGlzdHMobW9ja1ByZWZpeCkpLnJlamVjdHMudG9UaHJvdygnVmF1bHQgZXJyb3InKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnRXJyb3IgUmVjb3ZlcnkgYW5kIEVkZ2UgQ2FzZXMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tQcmVmaXggPSBPbnRvbG9neVByZWZpeC5jcmVhdGUoJ3Rlc3QnKS5nZXRWYWx1ZSgpO1xuXG4gICAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGNvbmN1cnJlbnQgZmluZEJ5UHJlZml4IGNhbGxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW9ja0ZpbGUgPSB7IG5hbWU6ICchdGVzdC5tZCcsIHBhdGg6ICchdGVzdC5tZCcgfSBhcyBURmlsZTtcbiAgICAgICAgICAgIG1vY2tWYXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgubW9ja1JldHVyblZhbHVlKG1vY2tGaWxlKTtcbiAgICAgICAgICAgIG1vY2tNZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICAgIGZyb250bWF0dGVyOiB7ICdleG9fX09udG9sb2d5X3ByZWZpeCc6ICd0ZXN0JyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGplc3Quc3B5T24oT250b2xvZ3ksICdmcm9tRnJvbnRtYXR0ZXInKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gKHt9IGFzIGFueSkpO1xuXG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtcbiAgICAgICAgICAgICAgICByZXBvc2l0b3J5LmZpbmRCeVByZWZpeChtb2NrUHJlZml4KSxcbiAgICAgICAgICAgICAgICByZXBvc2l0b3J5LmZpbmRCeVByZWZpeChtb2NrUHJlZml4KSxcbiAgICAgICAgICAgICAgICByZXBvc2l0b3J5LmZpbmRCeVByZWZpeChtb2NrUHJlZml4KVxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzKS50b0hhdmVMZW5ndGgoMyk7XG4gICAgICAgICAgICBleHBlY3QobW9ja1ZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDMpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb3JydXB0IGZyb250bWF0dGVyIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtb2NrRmlsZSA9IG5ldyBURmlsZSgnIXRlc3QubWQnKTtcbiAgICAgICAgICAgIG1vY2tWYXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgubW9ja1JldHVyblZhbHVlKG1vY2tGaWxlKTtcbiAgICAgICAgICAgIG1vY2tNZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICAgIGZyb250bWF0dGVyOiB7IGludmFsaWQ6ICdkYXRhJyB9IC8vIE1pc3NpbmcgcmVxdWlyZWQgZmllbGRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGplc3Quc3B5T24oT250b2xvZ3ksICdmcm9tRnJvbnRtYXR0ZXInKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVxdWlyZWQgZmllbGQgbWlzc2luZycpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGF3YWl0IGV4cGVjdChyZXBvc2l0b3J5LmZpbmRCeVByZWZpeChtb2NrUHJlZml4KSkucmVqZWN0cy50b1Rocm93KCdSZXF1aXJlZCBmaWVsZCBtaXNzaW5nJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgaGFuZGxlIHNwZWNpYWwgY2hhcmFjdGVycyBpbiBwcmVmaXgnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXBvc2l0b3J5LmV4aXN0cyhtb2NrUHJlZml4KTtcbiAgICAgICAgICAgIGV4cGVjdChtb2NrVmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnIXRlc3QubWQnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgdmVyeSBsb25nIHByZWZpeCBuYW1lcycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxvbmdQcmVmaXggPSAnYScucmVwZWF0KDUwKTsgLy8gUmVkdWNlZCB0byB2YWxpZCBsZW5ndGhcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IE9udG9sb2d5UHJlZml4LmNyZWF0ZShsb25nUHJlZml4KS5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBhd2FpdCByZXBvc2l0b3J5LmV4aXN0cyhwcmVmaXgpO1xuICAgICAgICAgICAgZXhwZWN0KG1vY2tWYXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGAhJHtsb25nUHJlZml4fS5tZGApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGhhbmRsZSBtZXRhZGF0YSBjYWNoZSByZXR1cm5pbmcgdW5kZWZpbmVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW9ja0ZpbGUgPSBuZXcgVEZpbGUoJyF0ZXN0Lm1kJyk7XG4gICAgICAgICAgICBtb2NrVmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoLm1vY2tSZXR1cm5WYWx1ZShtb2NrRmlsZSk7XG4gICAgICAgICAgICBtb2NrTWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUubW9ja1JldHVyblZhbHVlKHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcG9zaXRvcnkuZmluZEJ5UHJlZml4KG1vY2tQcmVmaXgpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgdmF1bHQgYWRhcHRlciBlcnJvcnMgaW4gZ2V0QWJzdHJhY3RGaWxlQnlQYXRoJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbW9ja1ZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aC5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmF1bHQgYWRhcHRlciBlcnJvcicpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGF3YWl0IGV4cGVjdChyZXBvc2l0b3J5LmZpbmRCeVByZWZpeChtb2NrUHJlZml4KSkucmVqZWN0cy50b1Rocm93KCdWYXVsdCBhZGFwdGVyIGVycm9yJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgaGFuZGxlIG1ldGFkYXRhIGNhY2hlIGVycm9ycyBpbiBnZXRGaWxlQ2FjaGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtb2NrRmlsZSA9IG5ldyBURmlsZSgnIXRlc3QubWQnKTtcbiAgICAgICAgICAgIG1vY2tWYXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgubW9ja1JldHVyblZhbHVlKG1vY2tGaWxlKTtcbiAgICAgICAgICAgIG1vY2tNZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0YWRhdGEgY2FjaGUgZXJyb3InKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBhd2FpdCBleHBlY3QocmVwb3NpdG9yeS5maW5kQnlQcmVmaXgobW9ja1ByZWZpeCkpLnJlamVjdHMudG9UaHJvdygnTWV0YWRhdGEgY2FjaGUgZXJyb3InKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgZmluZEFsbCB3aXRoIG1peGVkIHZhbGlkIGFuZCBpbnZhbGlkIGZpbGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW9ja0ZpbGVzID0gW1xuICAgICAgICAgICAgICAgIHsgbmFtZTogJyF2YWxpZC5tZCcsIHBhdGg6ICchdmFsaWQubWQnIH0gYXMgVEZpbGUsXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnIWludmFsaWQubWQnLCBwYXRoOiAnIWludmFsaWQubWQnIH0gYXMgVEZpbGUsXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnIWVycm9yLm1kJywgcGF0aDogJyFlcnJvci5tZCcgfSBhcyBURmlsZVxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgbW9ja1ZhdWx0LmdldE1hcmtkb3duRmlsZXMubW9ja1JldHVyblZhbHVlKG1vY2tGaWxlcyk7XG4gICAgICAgICAgICBtb2NrTWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUubW9ja0ltcGxlbWVudGF0aW9uKChmaWxlOiBURmlsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmaWxlLm5hbWUgPT09ICchdmFsaWQubWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGZyb250bWF0dGVyOiB7ICdleG9fX09udG9sb2d5X3ByZWZpeCc6ICd2YWxpZCcgfSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmlsZS5uYW1lID09PSAnIWludmFsaWQubWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGZyb250bWF0dGVyOiB7fSB9OyAvLyBObyBwcmVmaXhcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZpbGUubmFtZSA9PT0gJyFlcnJvci5tZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWxlIGFjY2VzcyBlcnJvcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBqZXN0LnNweU9uKE9udG9sb2d5LCAnZnJvbUZyb250bWF0dGVyJykubW9ja0ltcGxlbWVudGF0aW9uKChmcm9udG1hdHRlcjogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGZyb250bWF0dGVyWydleG9fX09udG9sb2d5X3ByZWZpeCddID09PSAndmFsaWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7fSBhcyBhbnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBvbnRvbG9neScpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFNob3VsZCBoYW5kbGUgZXJyb3JzIGdyYWNlZnVsbHkgYW5kIGNvbnRpbnVlIHByb2Nlc3NpbmdcbiAgICAgICAgICAgIGF3YWl0IGV4cGVjdChyZXBvc2l0b3J5LmZpbmRBbGwoKSkucmVqZWN0cy50b1Rocm93KCdGaWxlIGFjY2VzcyBlcnJvcicpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGhhbmRsZSBpbnZhbGlkIFRGaWxlIG9iamVjdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnZhbGlkRmlsZSA9IHsgbmFtZTogJyF0ZXN0Lm1kJyB9OyAvLyBNaXNzaW5nIHJlcXVpcmVkIFRGaWxlIHByb3BlcnRpZXNcbiAgICAgICAgICAgIG1vY2tWYXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgubW9ja1JldHVyblZhbHVlKGludmFsaWRGaWxlKTtcblxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVwb3NpdG9yeS5maW5kQnlQcmVmaXgobW9ja1ByZWZpeCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGhhbmRsZSBlbXB0eSBzdHJpbmcgcHJlZml4JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbXB0eVByZWZpeCA9IE9udG9sb2d5UHJlZml4LmNyZWF0ZSgnJykuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBleGVjdXRlIGFzIE9udG9sb2d5UHJlZml4LmNyZWF0ZSgnJykgc2hvdWxkIGZhaWxcbiAgICAgICAgICAgICAgICBleHBlY3QodHJ1ZSkudG9CZShmYWxzZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIEV4cGVjdGVkIGJlaGF2aW9yIC0gZW1wdHkgcHJlZml4IHNob3VsZCBiZSByZWplY3RlZCBieSB2YWx1ZSBvYmplY3RcbiAgICAgICAgICAgICAgICBleHBlY3QoZXJyb3IpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgaGFuZGxlIG1hbGZvcm1lZCBmcm9udG1hdHRlciBzdHJ1Y3R1cmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtb2NrRmlsZSA9IG5ldyBURmlsZSgnIXRlc3QubWQnKTtcbiAgICAgICAgICAgIG1vY2tWYXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgubW9ja1JldHVyblZhbHVlKG1vY2tGaWxlKTtcbiAgICAgICAgICAgIG1vY2tNZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICAgIGZyb250bWF0dGVyOiB7XG4gICAgICAgICAgICAgICAgICAgICdleG9fX09udG9sb2d5X3ByZWZpeCc6IFsnYXJyYXknLCAnaW5zdGVhZCcsICdvZicsICdzdHJpbmcnXSxcbiAgICAgICAgICAgICAgICAgICAgJ2ludmFsaWRfc3RydWN0dXJlJzogeyBuZXN0ZWQ6IHsgb2JqZWN0OiB0cnVlIH0gfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBqZXN0LnNweU9uKE9udG9sb2d5LCAnZnJvbUZyb250bWF0dGVyJykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBmcm9udG1hdHRlcicpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGF3YWl0IGV4cGVjdChyZXBvc2l0b3J5LmZpbmRCeVByZWZpeChtb2NrUHJlZml4KSkucmVqZWN0cy50b1Rocm93KCdNYWxmb3JtZWQgZnJvbnRtYXR0ZXInKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBoYW5kbGUgc2F2ZSB3aXRoIGNvbXBsZXggbmVzdGVkIGZyb250bWF0dGVyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29tcGxleE9udG9sb2d5ID0ge1xuICAgICAgICAgICAgICAgIGdldFByZWZpeDogKCkgPT4gbW9ja1ByZWZpeCxcbiAgICAgICAgICAgICAgICB0b0Zyb250bWF0dGVyOiAoKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAnZXhvX19PbnRvbG9neV9wcmVmaXgnOiAndGVzdCcsXG4gICAgICAgICAgICAgICAgICAgICdleG9fX09udG9sb2d5X25hbWVzcGFjZSc6ICdodHRwOi8vZXhhbXBsZS5vcmcvdGVzdCMnLFxuICAgICAgICAgICAgICAgICAgICAnZXhvX19PbnRvbG9neV9jbGFzc2VzJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1BlcnNvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnT3JnYW5pemF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdFdmVudCdcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ2V4b19fT250b2xvZ3lfcHJvcGVydGllcyc6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdoYXNOYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdoYXNEZXNjcmlwdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAncmVsYXRlZFRvJ1xuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAnZXhvX19PbnRvbG9neV9pbXBvcnRzJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHA6Ly93d3cudzMub3JnLzIwMDIvMDcvb3dsIycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIydcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ2V4b19fT250b2xvZ3lfdmVyc2lvbic6ICcxLjAuMCcsXG4gICAgICAgICAgICAgICAgICAgICdleG9fX09udG9sb2d5X2F1dGhvcic6ICdUZXN0IEF1dGhvcicsXG4gICAgICAgICAgICAgICAgICAgICdleG9fX09udG9sb2d5X2xpY2Vuc2UnOiAnTUlUJ1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGFzIGFueTtcblxuICAgICAgICAgICAgbW9ja1ZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aC5tb2NrUmV0dXJuVmFsdWUobnVsbCk7XG4gICAgICAgICAgICBtb2NrVmF1bHQuY3JlYXRlLm1vY2tSZXNvbHZlZFZhbHVlKHsgbmFtZTogJyF0ZXN0Lm1kJywgcGF0aDogJyF0ZXN0Lm1kJyB9IGFzIFRGaWxlKTtcblxuICAgICAgICAgICAgYXdhaXQgcmVwb3NpdG9yeS5zYXZlKGNvbXBsZXhPbnRvbG9neSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZUNhbGwgPSBtb2NrVmF1bHQuY3JlYXRlLm1vY2suY2FsbHNbMF07XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gY3JlYXRlQ2FsbFsxXTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IGFsbCBhcnJheXMgYXJlIHByb3Blcmx5IGZvcm1hdHRlZFxuICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnQpLnRvQ29udGFpbignZXhvX19PbnRvbG9neV9jbGFzc2VzOicpO1xuICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnQpLnRvQ29udGFpbignICAtIFBlcnNvbicpO1xuICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnQpLnRvQ29udGFpbignICAtIE9yZ2FuaXphdGlvbicpO1xuICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnQpLnRvQ29udGFpbignICAtIEV2ZW50Jyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGV4cGVjdChjb250ZW50KS50b0NvbnRhaW4oJ2V4b19fT250b2xvZ3lfcHJvcGVydGllczonKTtcbiAgICAgICAgICAgIGV4cGVjdChjb250ZW50KS50b0NvbnRhaW4oJyAgLSBoYXNOYW1lJyk7XG4gICAgICAgICAgICBleHBlY3QoY29udGVudCkudG9Db250YWluKCcgIC0gaGFzRGVzY3JpcHRpb24nKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnQpLnRvQ29udGFpbignZXhvX19PbnRvbG9neV9pbXBvcnRzOicpO1xuICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnQpLnRvQ29udGFpbignICAtIGh0dHA6Ly93d3cudzMub3JnLzIwMDIvMDcvb3dsIycpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBWZXJpZnkgc2NhbGFyIHZhbHVlc1xuICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnQpLnRvQ29udGFpbignZXhvX19PbnRvbG9neV92ZXJzaW9uOiAxLjAuMCcpO1xuICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnQpLnRvQ29udGFpbignZXhvX19PbnRvbG9neV9hdXRob3I6IFRlc3QgQXV0aG9yJyk7XG4gICAgICAgICAgICBleHBlY3QoY29udGVudCkudG9Db250YWluKCdleG9fX09udG9sb2d5X2xpY2Vuc2U6IE1JVCcpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGhhbmRsZSBzYXZlIHdpdGggbnVsbCBhbmQgdW5kZWZpbmVkIHZhbHVlcyBpbiBmcm9udG1hdHRlcicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9udG9sb2d5V2l0aE51bGxzID0ge1xuICAgICAgICAgICAgICAgIGdldFByZWZpeDogKCkgPT4gbW9ja1ByZWZpeCxcbiAgICAgICAgICAgICAgICB0b0Zyb250bWF0dGVyOiAoKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAnZXhvX19PbnRvbG9neV9wcmVmaXgnOiAndGVzdCcsXG4gICAgICAgICAgICAgICAgICAgICdleG9fX09udG9sb2d5X25hbWVzcGFjZSc6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICdleG9fX09udG9sb2d5X2Rlc2NyaXB0aW9uJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAnZXhvX19PbnRvbG9neV9jbGFzc2VzJzogW10sXG4gICAgICAgICAgICAgICAgICAgICdleG9fX09udG9sb2d5X3Byb3BlcnRpZXMnOiBudWxsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gYXMgYW55O1xuXG4gICAgICAgICAgICBtb2NrVmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoLm1vY2tSZXR1cm5WYWx1ZShudWxsKTtcbiAgICAgICAgICAgIG1vY2tWYXVsdC5jcmVhdGUubW9ja1Jlc29sdmVkVmFsdWUoeyBuYW1lOiAnIXRlc3QubWQnLCBwYXRoOiAnIXRlc3QubWQnIH0gYXMgVEZpbGUpO1xuXG4gICAgICAgICAgICBhd2FpdCByZXBvc2l0b3J5LnNhdmUob250b2xvZ3lXaXRoTnVsbHMpO1xuXG4gICAgICAgICAgICBjb25zdCBjcmVhdGVDYWxsID0gbW9ja1ZhdWx0LmNyZWF0ZS5tb2NrLmNhbGxzWzBdO1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGNyZWF0ZUNhbGxbMV07XG5cbiAgICAgICAgICAgIGV4cGVjdChjb250ZW50KS50b0NvbnRhaW4oJ2V4b19fT250b2xvZ3lfcHJlZml4OiB0ZXN0Jyk7XG4gICAgICAgICAgICBleHBlY3QoY29udGVudCkudG9Db250YWluKCdleG9fX09udG9sb2d5X25hbWVzcGFjZTogbnVsbCcpO1xuICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnQpLnRvQ29udGFpbignZXhvX19PbnRvbG9neV9kZXNjcmlwdGlvbjogdW5kZWZpbmVkJyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ0ludGVncmF0aW9uIFNjZW5hcmlvcycsICgpID0+IHtcbiAgICAgICAgaXQoJ3Nob3VsZCBzdXBwb3J0IGZ1bGwgQ1JVRCBjeWNsZScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1vY2tQcmVmaXggPSBPbnRvbG9neVByZWZpeC5jcmVhdGUoJ2ludGVncmF0aW9uJykuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIGNvbnN0IG1vY2tPbnRvbG9neSA9IHtcbiAgICAgICAgICAgICAgICBnZXRQcmVmaXg6ICgpID0+IG1vY2tQcmVmaXgsXG4gICAgICAgICAgICAgICAgdG9Gcm9udG1hdHRlcjogKCkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgJ2V4b19fT250b2xvZ3lfcHJlZml4JzogJ2ludGVncmF0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgJ2V4b19fT250b2xvZ3lfbmFtZXNwYWNlJzogJ2h0dHA6Ly9leGFtcGxlLm9yZy9pbnRlZ3JhdGlvbiMnXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0gYXMgYW55O1xuXG4gICAgICAgICAgICAvLyBDcmVhdGVcbiAgICAgICAgICAgIG1vY2tWYXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgubW9ja1JldHVyblZhbHVlT25jZShudWxsKTsgLy8gRmlsZSBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgICBtb2NrVmF1bHQuY3JlYXRlLm1vY2tSZXNvbHZlZFZhbHVlKHsgbmFtZTogJyFpbnRlZ3JhdGlvbi5tZCcsIHBhdGg6ICchaW50ZWdyYXRpb24ubWQnIH0gYXMgVEZpbGUpO1xuICAgICAgICAgICAgYXdhaXQgcmVwb3NpdG9yeS5zYXZlKG1vY2tPbnRvbG9neSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENoZWNrIGV4aXN0c1xuICAgICAgICAgICAgY29uc3QgbW9ja0ludGVncmF0aW9uRmlsZSA9IG5ldyBURmlsZSgnIWludGVncmF0aW9uLm1kJyk7XG4gICAgICAgICAgICBtb2NrVmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoLm1vY2tSZXR1cm5WYWx1ZU9uY2UobW9ja0ludGVncmF0aW9uRmlsZSk7XG4gICAgICAgICAgICBjb25zdCBleGlzdHMgPSBhd2FpdCByZXBvc2l0b3J5LmV4aXN0cyhtb2NrUHJlZml4KTtcbiAgICAgICAgICAgIGV4cGVjdChleGlzdHMpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEZpbmRcbiAgICAgICAgICAgIGNvbnN0IG1vY2tGaWxlID0gbmV3IFRGaWxlKCchaW50ZWdyYXRpb24ubWQnKTtcbiAgICAgICAgICAgIG1vY2tWYXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgubW9ja1JldHVyblZhbHVlT25jZShtb2NrRmlsZSk7XG4gICAgICAgICAgICBtb2NrTWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgICAgICBmcm9udG1hdHRlcjogeyAnZXhvX19PbnRvbG9neV9wcmVmaXgnOiAnaW50ZWdyYXRpb24nIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgamVzdC5zcHlPbihPbnRvbG9neSwgJ2Zyb21Gcm9udG1hdHRlcicpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiBtb2NrT250b2xvZ3kpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBmb3VuZCA9IGF3YWl0IHJlcG9zaXRvcnkuZmluZEJ5UHJlZml4KG1vY2tQcmVmaXgpO1xuICAgICAgICAgICAgZXhwZWN0KGZvdW5kKS50b0JlKG1vY2tPbnRvbG9neSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgaGFuZGxlIGJhdGNoIG9wZXJhdGlvbnMgd2l0aCBtdWx0aXBsZSBvbnRvbG9naWVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJlZml4ZXMgPSBbJ2JhdGNoMScsICdiYXRjaDInLCAnYmF0Y2gzJ10ubWFwKHAgPT4gT250b2xvZ3lQcmVmaXguY3JlYXRlKHApLmdldFZhbHVlKCkpO1xuICAgICAgICAgICAgY29uc3Qgb250b2xvZ2llcyA9IHByZWZpeGVzLm1hcChwcmVmaXggPT4gKHtcbiAgICAgICAgICAgICAgICBnZXRQcmVmaXg6ICgpID0+IHByZWZpeCxcbiAgICAgICAgICAgICAgICB0b0Zyb250bWF0dGVyOiAoKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAnZXhvX19PbnRvbG9neV9wcmVmaXgnOiBwcmVmaXgudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgJ2V4b19fT250b2xvZ3lfbmFtZXNwYWNlJzogYGh0dHA6Ly9leGFtcGxlLm9yZy8ke3ByZWZpeC50b1N0cmluZygpfSNgXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pKSBhcyBhbnlbXTtcblxuICAgICAgICAgICAgLy8gTW9jayBmaWxlIGNyZWF0aW9uIGZvciBhbGwgb250b2xvZ2llc1xuICAgICAgICAgICAgbW9ja1ZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aC5tb2NrUmV0dXJuVmFsdWUobnVsbCk7XG4gICAgICAgICAgICBtb2NrVmF1bHQuY3JlYXRlLm1vY2tJbXBsZW1lbnRhdGlvbigocGF0aDogc3RyaW5nKSA9PiBcbiAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoeyBuYW1lOiBwYXRoLCBwYXRoIH0gYXMgVEZpbGUpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBTYXZlIGFsbCBvbnRvbG9naWVzXG4gICAgICAgICAgICBjb25zdCBzYXZlUHJvbWlzZXMgPSBvbnRvbG9naWVzLm1hcChvbnQgPT4gcmVwb3NpdG9yeS5zYXZlKG9udCkpO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoc2F2ZVByb21pc2VzKTtcblxuICAgICAgICAgICAgLy8gVmVyaWZ5IGFsbCBmaWxlcyB3ZXJlIGNyZWF0ZWRcbiAgICAgICAgICAgIGV4cGVjdChtb2NrVmF1bHQuY3JlYXRlKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMyk7XG4gICAgICAgICAgICBleHBlY3QobW9ja1ZhdWx0LmNyZWF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJyFiYXRjaDEubWQnLCBleHBlY3QuYW55KFN0cmluZykpO1xuICAgICAgICAgICAgZXhwZWN0KG1vY2tWYXVsdC5jcmVhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCchYmF0Y2gyLm1kJywgZXhwZWN0LmFueShTdHJpbmcpKTtcbiAgICAgICAgICAgIGV4cGVjdChtb2NrVmF1bHQuY3JlYXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnIWJhdGNoMy5tZCcsIGV4cGVjdC5hbnkoU3RyaW5nKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgaGFuZGxlIHJlcG9zaXRvcnkgc3RhdGUgY29uc2lzdGVuY3kgZHVyaW5nIGNvbmN1cnJlbnQgb3BlcmF0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1vY2tQcmVmaXggPSBPbnRvbG9neVByZWZpeC5jcmVhdGUoJ2NvbmN1cnJlbnQnKS5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgY29uc3QgbW9ja0ZpbGUgPSB7IG5hbWU6ICchY29uY3VycmVudC5tZCcsIHBhdGg6ICchY29uY3VycmVudC5tZCcgfSBhcyBURmlsZTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgY29uY3VycmVudCByZWFkL3dyaXRlIHNjZW5hcmlvXG4gICAgICAgICAgICBtb2NrVmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU2ltdWxhdGUgZmlsZSBiZWluZyBjcmVhdGVkIGR1cmluZyBjb25jdXJyZW50IGFjY2Vzc1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpID4gMC41ID8gbW9ja0ZpbGUgOiBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG1vY2tNZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgICAgIGZyb250bWF0dGVyOiB7ICdleG9fX09udG9sb2d5X3ByZWZpeCc6ICdjb25jdXJyZW50JyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgamVzdC5zcHlPbihPbnRvbG9neSwgJ2Zyb21Gcm9udG1hdHRlcicpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiAoe30gYXMgYW55KSk7XG5cbiAgICAgICAgICAgIC8vIEV4ZWN1dGUgY29uY3VycmVudCBvcGVyYXRpb25zXG4gICAgICAgICAgICBjb25zdCBvcGVyYXRpb25zID0gW1xuICAgICAgICAgICAgICAgIHJlcG9zaXRvcnkuZmluZEJ5UHJlZml4KG1vY2tQcmVmaXgpLFxuICAgICAgICAgICAgICAgIHJlcG9zaXRvcnkuZXhpc3RzKG1vY2tQcmVmaXgpLFxuICAgICAgICAgICAgICAgIHJlcG9zaXRvcnkuZmluZEJ5UHJlZml4KG1vY2tQcmVmaXgpXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwob3BlcmF0aW9ucyk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cykudG9IYXZlTGVuZ3RoKDMpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb21wbGV4IGZpbmRBbGwgc2NlbmFyaW8gd2l0aCBtaXhlZCBmaWxlIHR5cGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW9ja0ZpbGVzID0gW1xuICAgICAgICAgICAgICAgIHsgbmFtZTogJyFvbnRvbG9neTEubWQnLCBwYXRoOiAnIW9udG9sb2d5MS5tZCcgfSBhcyBURmlsZSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICchb250b2xvZ3kyLm1kJywgcGF0aDogJyFvbnRvbG9neTIubWQnIH0gYXMgVEZpbGUsXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAncmVndWxhci1ub3RlLm1kJywgcGF0aDogJ3JlZ3VsYXItbm90ZS5tZCcgfSBhcyBURmlsZSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICchaW52YWxpZC1vbnRvbG9neS5tZCcsIHBhdGg6ICchaW52YWxpZC1vbnRvbG9neS5tZCcgfSBhcyBURmlsZSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICchZW1wdHktb250b2xvZ3kubWQnLCBwYXRoOiAnIWVtcHR5LW9udG9sb2d5Lm1kJyB9IGFzIFRGaWxlXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICBtb2NrVmF1bHQuZ2V0TWFya2Rvd25GaWxlcy5tb2NrUmV0dXJuVmFsdWUobW9ja0ZpbGVzKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbW9ja01ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlLm1vY2tJbXBsZW1lbnRhdGlvbigoZmlsZTogVEZpbGUpID0+IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZpbGUubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICchb250b2xvZ3kxLm1kJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGZyb250bWF0dGVyOiB7ICdleG9fX09udG9sb2d5X3ByZWZpeCc6ICdvbnQxJyB9IH07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJyFvbnRvbG9neTIubWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZnJvbnRtYXR0ZXI6IHsgJ2V4b19fT250b2xvZ3lfcHJlZml4JzogJ29udDInIH0gfTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnIWludmFsaWQtb250b2xvZ3kubWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZnJvbnRtYXR0ZXI6IHt9IH07IC8vIE1pc3NpbmcgcHJlZml4XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJyFlbXB0eS1vbnRvbG9neS5tZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gTm8gY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGZyb250bWF0dGVyOiB7fSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBqZXN0LnNweU9uKE9udG9sb2d5LCAnZnJvbUZyb250bWF0dGVyJykubW9ja0ltcGxlbWVudGF0aW9uKChmcm9udG1hdHRlcjogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGZyb250bWF0dGVyWydleG9fX09udG9sb2d5X3ByZWZpeCddKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRQcmVmaXg6ICgpID0+IE9udG9sb2d5UHJlZml4LmNyZWF0ZShmcm9udG1hdHRlclsnZXhvX19PbnRvbG9neV9wcmVmaXgnXSkuZ2V0VmFsdWUoKVxuICAgICAgICAgICAgICAgICAgICB9IGFzIGFueTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG9udG9sb2d5Jyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVwb3NpdG9yeS5maW5kQWxsKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFNob3VsZCBvbmx5IGluY2x1ZGUgdmFsaWQgb250b2xvZ3kgZmlsZXNcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQpLnRvSGF2ZUxlbmd0aCgyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBtYWludGFpbiBkYXRhIGludGVncml0eSBkdXJpbmcgc2F2ZSBvcGVyYXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW9ja1ByZWZpeCA9IE9udG9sb2d5UHJlZml4LmNyZWF0ZSgnaW50ZWdyaXR5JykuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAnZXhvX19PbnRvbG9neV9wcmVmaXgnOiAnaW50ZWdyaXR5JyxcbiAgICAgICAgICAgICAgICAnZXhvX19PbnRvbG9neV9uYW1lc3BhY2UnOiAnaHR0cDovL2V4YW1wbGUub3JnL2ludGVncml0eSMnLFxuICAgICAgICAgICAgICAgICdleG9fX09udG9sb2d5X2NsYXNzZXMnOiBbJ0NsYXNzMScsICdDbGFzczInXSxcbiAgICAgICAgICAgICAgICAnZXhvX19PbnRvbG9neV9wcm9wZXJ0aWVzJzogWydwcm9wMScsICdwcm9wMiddXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCBtb2NrT250b2xvZ3kgPSB7XG4gICAgICAgICAgICAgICAgZ2V0UHJlZml4OiAoKSA9PiBtb2NrUHJlZml4LFxuICAgICAgICAgICAgICAgIHRvRnJvbnRtYXR0ZXI6ICgpID0+IG9yaWdpbmFsRGF0YVxuICAgICAgICAgICAgfSBhcyBhbnk7XG5cbiAgICAgICAgICAgIG1vY2tWYXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgubW9ja1JldHVyblZhbHVlKG51bGwpO1xuICAgICAgICAgICAgbW9ja1ZhdWx0LmNyZWF0ZS5tb2NrSW1wbGVtZW50YXRpb24oKHBhdGg6IHN0cmluZywgY29udGVudDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVmVyaWZ5IGNvbnRlbnQgaW50ZWdyaXR5XG4gICAgICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnQpLnRvQ29udGFpbignLS0tJyk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnQpLnRvQ29udGFpbignZXhvX19PbnRvbG9neV9wcmVmaXg6IGludGVncml0eScpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChjb250ZW50KS50b0NvbnRhaW4oJ2V4b19fT250b2xvZ3lfY2xhc3NlczonKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoY29udGVudCkudG9Db250YWluKCcgIC0gQ2xhc3MxJyk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnQpLnRvQ29udGFpbignICAtIENsYXNzMicpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChjb250ZW50KS50b0NvbnRhaW4oJ2V4b19fT250b2xvZ3lfcHJvcGVydGllczonKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoY29udGVudCkudG9Db250YWluKCcgIC0gcHJvcDEnKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoY29udGVudCkudG9Db250YWluKCcgIC0gcHJvcDInKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgbmFtZTogcGF0aCwgcGF0aCB9IGFzIFRGaWxlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBhd2FpdCByZXBvc2l0b3J5LnNhdmUobW9ja09udG9sb2d5KTtcbiAgICAgICAgICAgIGV4cGVjdChtb2NrVmF1bHQuY3JlYXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnIWludGVncml0eS5tZCcsIGV4cGVjdC5hbnkoU3RyaW5nKSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufSk7XG4iXSwidmVyc2lvbiI6M30=