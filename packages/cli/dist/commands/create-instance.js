import { Command } from 'commander';
import chalk from 'chalk';
import ora from 'ora';
import * as path from 'path';
import { TaskCreationService, AssetClass } from '@exocortex/core';
import { NodeFsAdapter } from '../adapters/NodeFsAdapter.js';
export function createInstanceCommand() {
    const cmd = new Command('instance');
    cmd
        .description('Create an instance from a prototype')
        .requiredOption('-p, --prototype <path>', 'Path to prototype file')
        .option('-l, --label <label>', 'Instance label')
        .option('--size <size>', 'Task size (for task instances)')
        .option('-r, --root <path>', 'Root directory of vault', process.cwd())
        .action(async (options) => {
        const spinner = ora('Creating instance from prototype...').start();
        try {
            const adapter = new NodeFsAdapter(options.root);
            const service = new TaskCreationService(adapter);
            const prototypePath = path.relative(options.root, options.prototype);
            const metadata = await adapter.getFileMetadata(prototypePath);
            let sourceClass = AssetClass.TASK_PROTOTYPE;
            if (metadata.exo__Instance_class) {
                const classes = Array.isArray(metadata.exo__Instance_class)
                    ? metadata.exo__Instance_class
                    : [metadata.exo__Instance_class];
                const normalizedClass = classes[0]?.replace(/["'[\]]/g, '').trim();
                if (normalizedClass === AssetClass.MEETING_PROTOTYPE) {
                    sourceClass = AssetClass.MEETING_PROTOTYPE;
                }
            }
            const createdPath = await service.createTask(prototypePath, metadata, sourceClass, options.label, options.size || null);
            spinner.succeed(chalk.green(`Instance created: ${createdPath}`));
        }
        catch (error) {
            spinner.fail(chalk.red(`Failed to create instance: ${error.message}`));
            process.exit(1);
        }
    });
    return cmd;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3JlYXRlLWluc3RhbmNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NvbW1hbmRzL2NyZWF0ZS1pbnN0YW5jZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBQ3BDLE9BQU8sS0FBSyxNQUFNLE9BQU8sQ0FBQztBQUMxQixPQUFPLEdBQUcsTUFBTSxLQUFLLENBQUM7QUFDdEIsT0FBTyxLQUFLLElBQUksTUFBTSxNQUFNLENBQUM7QUFDN0IsT0FBTyxFQUFFLG1CQUFtQixFQUFFLFVBQVUsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ2xFLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUU3RCxNQUFNLFVBQVUscUJBQXFCO0lBQ25DLE1BQU0sR0FBRyxHQUFHLElBQUksT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBRXBDLEdBQUc7U0FDQSxXQUFXLENBQUMscUNBQXFDLENBQUM7U0FDbEQsY0FBYyxDQUFDLHdCQUF3QixFQUFFLHdCQUF3QixDQUFDO1NBQ2xFLE1BQU0sQ0FBQyxxQkFBcUIsRUFBRSxnQkFBZ0IsQ0FBQztTQUMvQyxNQUFNLENBQUMsZUFBZSxFQUFFLGdDQUFnQyxDQUFDO1NBQ3pELE1BQU0sQ0FBQyxtQkFBbUIsRUFBRSx5QkFBeUIsRUFBRSxPQUFPLENBQUMsR0FBRyxFQUFFLENBQUM7U0FDckUsTUFBTSxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsRUFBRTtRQUN4QixNQUFNLE9BQU8sR0FBRyxHQUFHLENBQUMscUNBQXFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUVuRSxJQUFJLENBQUM7WUFDSCxNQUFNLE9BQU8sR0FBRyxJQUFJLGFBQWEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDaEQsTUFBTSxPQUFPLEdBQUcsSUFBSSxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUVqRCxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ3JFLE1BQU0sUUFBUSxHQUFHLE1BQU0sT0FBTyxDQUFDLGVBQWUsQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUU5RCxJQUFJLFdBQVcsR0FBRyxVQUFVLENBQUMsY0FBYyxDQUFDO1lBQzVDLElBQUksUUFBUSxDQUFDLG1CQUFtQixFQUFFLENBQUM7Z0JBQ2pDLE1BQU0sT0FBTyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLG1CQUFtQixDQUFDO29CQUN6RCxDQUFDLENBQUMsUUFBUSxDQUFDLG1CQUFtQjtvQkFDOUIsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLG1CQUFtQixDQUFDLENBQUM7Z0JBRW5DLE1BQU0sZUFBZSxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO2dCQUNuRSxJQUFJLGVBQWUsS0FBSyxVQUFVLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztvQkFDckQsV0FBVyxHQUFHLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQztnQkFDN0MsQ0FBQztZQUNILENBQUM7WUFFRCxNQUFNLFdBQVcsR0FBRyxNQUFNLE9BQU8sQ0FBQyxVQUFVLENBQzFDLGFBQWEsRUFDYixRQUFRLEVBQ1IsV0FBVyxFQUNYLE9BQU8sQ0FBQyxLQUFLLEVBQ2IsT0FBTyxDQUFDLElBQUksSUFBSSxJQUFJLENBQ3JCLENBQUM7WUFFRixPQUFPLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMscUJBQXFCLFdBQVcsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNuRSxDQUFDO1FBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztZQUNmLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyw4QkFBK0IsS0FBZSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQztZQUNsRixPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2xCLENBQUM7SUFDSCxDQUFDLENBQUMsQ0FBQztJQUVMLE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbW1hbmQgfSBmcm9tICdjb21tYW5kZXInO1xuaW1wb3J0IGNoYWxrIGZyb20gJ2NoYWxrJztcbmltcG9ydCBvcmEgZnJvbSAnb3JhJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBUYXNrQ3JlYXRpb25TZXJ2aWNlLCBBc3NldENsYXNzIH0gZnJvbSAnQGV4b2NvcnRleC9jb3JlJztcbmltcG9ydCB7IE5vZGVGc0FkYXB0ZXIgfSBmcm9tICcuLi9hZGFwdGVycy9Ob2RlRnNBZGFwdGVyLmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlQ29tbWFuZCgpOiBDb21tYW5kIHtcbiAgY29uc3QgY21kID0gbmV3IENvbW1hbmQoJ2luc3RhbmNlJyk7XG5cbiAgY21kXG4gICAgLmRlc2NyaXB0aW9uKCdDcmVhdGUgYW4gaW5zdGFuY2UgZnJvbSBhIHByb3RvdHlwZScpXG4gICAgLnJlcXVpcmVkT3B0aW9uKCctcCwgLS1wcm90b3R5cGUgPHBhdGg+JywgJ1BhdGggdG8gcHJvdG90eXBlIGZpbGUnKVxuICAgIC5vcHRpb24oJy1sLCAtLWxhYmVsIDxsYWJlbD4nLCAnSW5zdGFuY2UgbGFiZWwnKVxuICAgIC5vcHRpb24oJy0tc2l6ZSA8c2l6ZT4nLCAnVGFzayBzaXplIChmb3IgdGFzayBpbnN0YW5jZXMpJylcbiAgICAub3B0aW9uKCctciwgLS1yb290IDxwYXRoPicsICdSb290IGRpcmVjdG9yeSBvZiB2YXVsdCcsIHByb2Nlc3MuY3dkKCkpXG4gICAgLmFjdGlvbihhc3luYyAob3B0aW9ucykgPT4ge1xuICAgICAgY29uc3Qgc3Bpbm5lciA9IG9yYSgnQ3JlYXRpbmcgaW5zdGFuY2UgZnJvbSBwcm90b3R5cGUuLi4nKS5zdGFydCgpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhZGFwdGVyID0gbmV3IE5vZGVGc0FkYXB0ZXIob3B0aW9ucy5yb290KTtcbiAgICAgICAgY29uc3Qgc2VydmljZSA9IG5ldyBUYXNrQ3JlYXRpb25TZXJ2aWNlKGFkYXB0ZXIpO1xuXG4gICAgICAgIGNvbnN0IHByb3RvdHlwZVBhdGggPSBwYXRoLnJlbGF0aXZlKG9wdGlvbnMucm9vdCwgb3B0aW9ucy5wcm90b3R5cGUpO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IGFkYXB0ZXIuZ2V0RmlsZU1ldGFkYXRhKHByb3RvdHlwZVBhdGgpO1xuXG4gICAgICAgIGxldCBzb3VyY2VDbGFzcyA9IEFzc2V0Q2xhc3MuVEFTS19QUk9UT1RZUEU7XG4gICAgICAgIGlmIChtZXRhZGF0YS5leG9fX0luc3RhbmNlX2NsYXNzKSB7XG4gICAgICAgICAgY29uc3QgY2xhc3NlcyA9IEFycmF5LmlzQXJyYXkobWV0YWRhdGEuZXhvX19JbnN0YW5jZV9jbGFzcylcbiAgICAgICAgICAgID8gbWV0YWRhdGEuZXhvX19JbnN0YW5jZV9jbGFzc1xuICAgICAgICAgICAgOiBbbWV0YWRhdGEuZXhvX19JbnN0YW5jZV9jbGFzc107XG5cbiAgICAgICAgICBjb25zdCBub3JtYWxpemVkQ2xhc3MgPSBjbGFzc2VzWzBdPy5yZXBsYWNlKC9bXCInW1xcXV0vZywgJycpLnRyaW0oKTtcbiAgICAgICAgICBpZiAobm9ybWFsaXplZENsYXNzID09PSBBc3NldENsYXNzLk1FRVRJTkdfUFJPVE9UWVBFKSB7XG4gICAgICAgICAgICBzb3VyY2VDbGFzcyA9IEFzc2V0Q2xhc3MuTUVFVElOR19QUk9UT1RZUEU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY3JlYXRlZFBhdGggPSBhd2FpdCBzZXJ2aWNlLmNyZWF0ZVRhc2soXG4gICAgICAgICAgcHJvdG90eXBlUGF0aCxcbiAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICBzb3VyY2VDbGFzcyxcbiAgICAgICAgICBvcHRpb25zLmxhYmVsLFxuICAgICAgICAgIG9wdGlvbnMuc2l6ZSB8fCBudWxsXG4gICAgICAgICk7XG5cbiAgICAgICAgc3Bpbm5lci5zdWNjZWVkKGNoYWxrLmdyZWVuKGBJbnN0YW5jZSBjcmVhdGVkOiAke2NyZWF0ZWRQYXRofWApKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHNwaW5uZXIuZmFpbChjaGFsay5yZWQoYEZhaWxlZCB0byBjcmVhdGUgaW5zdGFuY2U6ICR7KGVycm9yIGFzIEVycm9yKS5tZXNzYWdlfWApKTtcbiAgICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIHJldHVybiBjbWQ7XG59XG4iXX0=